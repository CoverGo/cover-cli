# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
	query: Query
	mutation: Mutation
	subscription: Subscription
}

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer(
	"Deferred when true."
	if: Boolean,
	"If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to."
	label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`."
directive @stream(
	"Streamed when true."
	if: Boolean,
	"The initial elements that shall be send down to the consumer."
	initialCount: Int! = 0,
	"If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to."
	label: String
) on FIELD

"Delegates a resolver to a remote schema."
directive @delegate(
	"The path to the field on the remote schema."
	path: String,
	"The name of the schema to which this field shall be delegated to."
	schema: Name!
) on FIELD_DEFINITION

directive @computed(
	"Specifies the fields on which a computed field is dependent on."
	dependantOn: [Name!]
) on FIELD_DEFINITION

"Annotates the original name of a type."
directive @source(
	"The original name of the annotated type."
	name: Name!,
	"The name of the schema to which this type belongs to."
	schema: Name!
) on OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION

directive @authorize(
	"Defines when when the resolver shall be executed.By default the resolver is executed after the policy has determined that the current user is allowed to access the field."
	apply: ApplyPolicy! = BEFORE_RESOLVER,
	"The name of the authorization policy that determines access to the annotated resource."
	policy: String,
	"Roles that are allowed to access the annotated resource."
	roles: [String!]
) on SCHEMA | OBJECT | FIELD_DEFINITION

directive @oneOf on INPUT_OBJECT

interface billing_IPaymentChannel {
	fields: String
	holderId: String
	type: billing_PaymentChannelType!
}

"A customer interface. Can be an individual or a company"
interface customerInterface {
	achievements: [achievement]
	addresses: [address]
	associatedLogin: login
	attachments: [attachment]
	contacts: [contact]
	courseProgressions(
		"a course progression filter"
		where: courseProgressionWhereInput
	): [courseProgression]
	createdAt: DateTime
	createdBy: login
	entityType: String
	events: [eventLog]
	facts: [fact]
	fields: String
	id: String!
	identities: [identity]
	internalCode: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	notes: [note]
	notificationList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): notifications
	notifications(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): [notification]
	paymentMethods: [paymentMethodInterface]
	photoPath: String
	relationshipList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): relationships
	relationships(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): [relationship]
	reviews(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: reviewWhereInput
	): reviews
	source: String
	status: String
	subscriptions: [subscription]
	tags: [String]
}

"An entity interface. Can be an internal, an individual, a company, an object, or any custom entities"
interface entityInterface {
	achievements: [achievement]
	addresses: [address]
	associatedLogin: login
	attachments: [attachment]
	contacts: [contact]
	courseProgressions(
		"a course progression filter"
		where: courseProgressionWhereInput
	): [courseProgression]
	createdAt: DateTime
	createdBy: login
	entityType: String
	events: [eventLog]
	facts: [fact]
	fields: String
	id: String!
	identities: [identity]
	internalCode: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	notes: [note]
	notificationList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): notifications
	notifications(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): [notification]
	paymentMethods: [paymentMethodInterface]
	photoPath: String
	relationshipList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): relationships
	relationships(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): [relationship]
	reviews(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: reviewWhereInput
	): reviews
	source: String
	status: String
	subscriptions: [subscription]
	tags: [String]
}

"a payment method interface"
interface paymentMethodInterface {
	createdAt: DateTime
	createdBy: login
	entityId: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
}

interface policies_FieldValidationError {
	code: String!
	message: String!
	propertyPath: String!
}

interface policies_UserError {
	code: String!
	message: String!
}

interface requestManager_IBusinessError {
	code: String!
	errorClass: String!
	message: String!
	translationKey: String!
}

"A template interface"
interface templateInterface {
	createdAt: DateTime
	createdBy: login
	description: String
	events: [eventLog]
	graphQlQuery: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	logicalId: String
	name: String
	tags: [String]!
	type: String
}

union objectUnion = claim | endorsement | policy | proposal

union policies_AddPolicyMemberError = policies_FieldInvalidOptionError | policies_FieldInvalidTypeError | policies_FieldNoExtraAllowedError | policies_FieldOneOfError | policies_FieldRequiredError | policies_FieldUniqueError | policies_MemberNotFoundError | policies_PolicyContractHolderNotFoundError | policies_PolicyIssuedError | policies_PolicyMemberExistsError | policies_PolicyNotFoundError | policies_ProductNotFoundError | policies_ProductPlanNotFoundError

union policies_DeletePolicyMemberError = policies_ArgumentError | policies_PolicyContractHolderNotFoundError | policies_PolicyIssuedError | policies_PolicyNotFoundError

union policies_DeletePolicyMembersError = policies_ArgumentError | policies_PolicyContractHolderNotFoundError | policies_PolicyIssuedError | policies_PolicyNotFoundError

union policies_IssueCertificateError = policies_RequiredArgumentError

union policies_RegisterPolicyMemberUploadError = policies_BadFileContentError | policies_PolicyNotFoundError | policies_UploadFileNotFoundError

union policies_UpdatePolicyMemberError = policies_FieldInvalidOptionError | policies_FieldInvalidTypeError | policies_FieldNoExtraAllowedError | policies_FieldOneOfError | policies_FieldRequiredError | policies_FieldUniqueError | policies_MemberNotFoundError | policies_PolicyContractHolderNotFoundError | policies_PolicyIssuedError | policies_PolicyMemberExistsError | policies_PolicyMemberNotFoundError | policies_PolicyNotFoundError | policies_ProductNotFoundError | policies_ProductPlanNotFoundError

type AddFactCommandGraphType {
	addedBy: login
	commandId: String
	entityId: String
	id: String
	timestamp: DateTime
	type: String
	value: scalarValue
}

"A connection to a list of items."
type AggregateAddressesConnection {
	"A list of edges."
	edges: [AggregateAddressesEdge!]
	"A flattened list of the nodes."
	nodes: [OpenAddressReadModel!]
	"Information to aid in pagination."
	pageInfo: PageInfo!
}

"An edge in a connection."
type AggregateAddressesEdge {
	"A cursor for use in pagination."
	cursor: String!
	"The item at the end of the edge."
	node: OpenAddressReadModel!
}

"A connection to a list of items."
type AggregateCommandsConnection {
	"A list of edges."
	edges: [AggregateCommandsEdge!]
	"A flattened list of the nodes."
	nodes: [AggregateDefinedCommandReadModel!]
	"Information to aid in pagination."
	pageInfo: PageInfo!
}

"An edge in a connection."
type AggregateCommandsEdge {
	"A cursor for use in pagination."
	cursor: String!
	"The item at the end of the edge."
	node: AggregateDefinedCommandReadModel!
}

type AggregateDefinedCommandDto {
	aggregate: OpenTypeDto!
	command: OpenTypeDto!
}

type AggregateDefinedCommandReadModel {
	aggregate: OpenTypeReadModel!
	commandType: OpenTypeReadModel!
	date: DateTime!
	engine: String!
	id: String!
	version: Int
}

type AggregateDefinedEventDto {
	aggregateTypeId: String!
	declaringEngine: String!
	eventType: OpenTypeDto!
	eventVersion: Int!
}

type AggregateStateDto {
	aggregate: OpenAddressDto!
	created: DateTime!
}

"A connection to a list of items."
type AggregateStateSchemasConnection {
	"A list of edges."
	edges: [AggregateStateSchemasEdge!]
	"A flattened list of the nodes."
	nodes: [StateDescriptionReadModel!]
	"Information to aid in pagination."
	pageInfo: PageInfo!
}

"An edge in a connection."
type AggregateStateSchemasEdge {
	"A cursor for use in pagination."
	cursor: String!
	"The item at the end of the edge."
	node: StateDescriptionReadModel!
}

type ApplicationVersionInfoListGraphType {
	"Application Version Info List"
	list: [applicationVersionInfo]
}

type ClaimInvestigationModel {
	approverName: String
	closedAt: DateTime
	consentRequests: [ConsentRequestModel!]
	createdAt: DateTime!
	escalatedClaim: EscalatedClaimModel
	evidenceRequests: [EvidenceRequestModel!]
	findings: FindingsSummaryModel
	handlerName: String
	id: ID!
	openedAt: DateTime!
	status: ClaimInvestigationStatus!
	updatedAt: DateTime!
}

type ClaimInvestigationModelCollectionSegment {
	items: [ClaimInvestigationModel!]
	"Information to aid in pagination."
	pageInfo: CollectionSegmentInfo!
	totalCount: Int!
}

"Information about the offset pagination."
type CollectionSegmentInfo {
	"Indicates whether more items exist following the set defined by the clients arguments."
	hasNextPage: Boolean!
	"Indicates whether more items exist prior the set defined by the clients arguments."
	hasPreviousPage: Boolean!
}

type ConsentRequestModel {
	approvedAt: DateTime
	approvedBy: UserModel
	cancelledAt: DateTime
	cancelledBy: UserModel
	createdAt: DateTime!
	documents: [FileModel!]
	email: EmailModel
	id: ID!
	reasons: [String!]
	rejectedAt: DateTime
	rejectedBy: UserModel
	reminders: [ReminderModel!]
	sentAt: DateTime!
	sentBy: UserModel
	status: ConsentRequestStatus!
	updatedAt: DateTime!
}

type EmailModel {
	cc: String!
	recipientName: String
	replyTo: String!
	to: String!
}

type EntityModel {
	id: String!
	internalCode: String!
	name: String!
}

type Error {
	code: String
	message: String
}

type EscalatedClaimModel {
	claimId: String
	claimIssuerNumber: String
	claimantId: String
	escalatedDate: DateTime
	id: ID!
	isInvestigationOpened: Boolean!
	memberInternalCode: String
	memberName: String
	policyHolder: EntityModel
	policyId: String
	policyIssuerNumber: String
	status: EscalatedClaimStatus!
}

type EscalatedClaimModelCollectionSegment {
	items: [EscalatedClaimModel!]
	"Information to aid in pagination."
	pageInfo: CollectionSegmentInfo!
	totalCount: Int!
}

type Event {
	id: ID
	metadata: [MetadataItem!]
	sequence: Int
	source: OpenAddress
	state: String
	type: OpenType
}

type EvidenceRequestModel {
	cancelledAt: DateTime
	collectedAt: DateTime
	collectedBy: UserModel
	createdAt: DateTime!
	email: EmailModel
	files: [FileModel!]
	id: ID!
	message: String
	notes: String
	receivedAt: DateTime
	receivedBy: UserModel
	reminders: [ReminderModel!]
	requestedDocuments: [RequestedDocumentsModel!]
	sentAt: DateTime
	sentBy: UserModel
	status: EvidenceRequestStatus!
	summary: String
	uploadedDocuments: [FileModel!]
}

type ExportedTree {
	lockStatus: LockStatus
	raw: String
	referencedExternalTables: [String!]
}

type Expression {
	"Could be: ClearScript, GraphQL, Constant, LocalFormula, ContextFormula"
	language: Language
	text: String
}

type FieldDescription {
	alias: String
	ref: String
	resolver: Expression
	type: String
}

type FieldReference {
	field: String
	node: NodeReference
	value: String
}

type FileModel {
	key: String!
	name: String!
}

type FindingsSummaryModel {
	summary: String
	uploadedFiles: [FileModel!]
}

type KeyValuePairOfStringAndDouble {
	key: String!
	value: Float!
}

"Lesson completion"
type LessonCompletion {
	createdAt: DateTime
	createdBy: login
	id: String!
	isPassed: Boolean
	itemAnswers: [lessonItemAnswer]
	lastModifiedAt: DateTime
	lastModifiedBy: login
	lesson: lesson
	score: Float
}

type LockStatus {
	isLocked: Boolean!
	lockedById: String
}

type MetadataItem {
	key: String
	value: String
}

type Mutation {
	acceptEndorsement(
		"the endorsement identifier"
		endorsementId: String!,
		"the policy identifier"
		policyId: String!
	): result
	addAddClauseToEndorsement(
		"the endorsement identifier"
		endorsementId: String,
		"the clause input"
		input: addClauseInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"Adds an address to an entity"
	addAddress(
		"The address input"
		addressInput: addressInput!,
		"The entity identifier"
		entityId: String!
	): createdStatusResult
	addAssociatedContractToPolicy(
		"the associated contract identifier"
		associatedContractId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the policy identifier"
		policyId: String!
	): result
	addAssociatedContractToProposalOffer(
		"the associated contract identifier"
		associatedContractId: String!,
		"the case identifier"
		caseId: String!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	"Adds a beneficiary eligibility"
	addBeneficiaryEligibility(
		"the information of the  beneficiary eligibility to update"
		beneficiaryEligibilityInput: beneficiaryEligibilityInput!,
		"the identifier of the policy"
		policyId: String!
	): result
	"Adds a beneficiary eligibility to a case"
	addBeneficiaryEligibilityToCase(
		"The case id"
		caseId: String!,
		"the beneficiary eligibility input"
		input: beneficiaryEligibilityInput!
	): createdStatusResult
	"Adds a benefit to a custom product"
	addBenefit(
		"the benefit input"
		input: benefitInput!,
		"the product identifier"
		productId: productIdInput!
	): result!
	"Adds a benefit to a claim"
	addBenefitToClaim(
		"the claim identifier"
		claimId: ID!,
		"The input"
		input: addBenefitToClaimInput!
	): result
	"Adds an attachment to a claim"
	addClaimAttachment(
		"The claim identifier"
		claimId: ID!,
		"The attachment input"
		input: attachmentInput!
	): result
	"Adds a note to a claim"
	addClaimNote(
		"The claim identifier"
		claimId: ID!,
		"The note input"
		input: addNoteInput!
	): result
	addClauseToPolicy(
		"the clause input"
		input: addClauseInput!,
		"the case identifier"
		policyId: String!
	): createdStatusResult
	addClauseToProposalOffer(
		"the case identifier"
		caseId: String!,
		"the clause input"
		input: addClauseInput!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): createdStatusResult
	"Adds a commission split to a policy"
	addCommission(
		"The commission input"
		input: commissionInput!,
		"The policy id"
		policyId: String!
	): result
	"Adds a commission split to an offer"
	addCommissionToOffer(
		"The case id"
		caseId: String!,
		"The commission input"
		input: commissionInput!,
		"The offer id"
		offerId: String!,
		"The proposal id"
		proposalId: String!
	): result
	"Adds a contact detail to a entity"
	addContact(
		"The contact input"
		contactInput: addContactInput!,
		"The entity identifier"
		entityId: String!
	): createdStatusResult
	addContractHolderAddress(
		"the endorsement identifier"
		endorsementId: String,
		"the clause input"
		input: addressInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addContractHolderContact(
		"the endorsement identifier"
		endorsementId: String,
		"the clause input"
		input: addContactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addContractHolderFact(
		"the endorsement identifier"
		endorsementId: String,
		"the fact input"
		input: addFactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addContractHolderIdentity(
		"the endorsement identifier"
		endorsementId: String,
		"the clause input"
		input: addIdentityInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addContractInsured(
		"the endorsement identifier"
		endorsementId: String,
		"the entityId identifier"
		entityId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addContractInsuredAddress(
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the clause input"
		input: addressInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addContractInsuredContact(
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the clause input"
		input: addContactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addContractInsuredFact(
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the fact input"
		input: addFactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addContractInsuredIdentity(
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the clause input"
		input: addIdentityInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addDataSchemaToProductType(
		"Add a dataSchema to the productType"
		input: addDataSchemaToProductTypeInput!
	): result
	"Add a diagnosis into a disability"
	addDiagnosisToDisability(
		"The diagnosis identifier"
		diagnosisId: String!,
		"The disability identifier"
		disabilityId: String!
	): result
	"Add a disability into an individual"
	addDisabilityToIndividual(
		"The disability identifier"
		disabilityId: String!,
		"The individual identifier"
		individualId: String!
	): result
	addDiscount(
		"the endorsement identifier"
		endorsementId: String,
		"the discount input"
		input: addDiscountToOfferInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"adds a discount to an offer"
	addDiscountToOffer(
		"the discount to be added"
		input: addDiscountToOfferInput!,
		"The identfier of the offer"
		offerId: String!,
		"the identifier of the policy"
		policyId: String!
	): result
	addDiscountToProposalOffer(
		"the case identifier"
		caseId: String!,
		"the discount input"
		input: addDiscountToOfferInput!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): createdStatusResult
	"Adds a dynamic value to a dynamic template"
	addDynamicValueToTemplate(
		"The input"
		input: addDynamicValueToTemplateInput!,
		"The template id to update"
		templateId: String!
	): result
	"Adds an email attachment reference"
	addEmailAttachmentReference(
		"The input"
		input: addEmailAttachmentReferenceInput!,
		"The email template id on which to attach the attachment reference"
		templateId: String!
	): result
	"Adds an email attachment template"
	addEmailAttachmentTemplate(
		"The input"
		input: addEmailAttachmentTemplateInput!,
		"The email template id on which to attach the attachment template"
		templateId: String!
	): result
	addEndorsement(
		"cancellation motive"
		cancellationMotive: String,
		"reason of change"
		effectiveDate: DateTimeOffset,
		"determines whether this is draft"
		isDraft: Boolean,
		"the policy identifier"
		policyId: String!,
		"reason of change"
		reasonOfChange: String,
		"ui source"
		source: endorsementSource,
		"endorsement type"
		type: String
	): createdStatusResult
	"Adds a note to a entity"
	addEntityNote(
		"The entity identifier"
		entityId: String!,
		"The note input"
		noteInput: addNoteInput!
	): result
	"adds an entity to a notification subscription"
	addEntityToNotificationSubscription(
		"the id of the entity to add"
		entityId: String!,
		"the id of the subscription"
		id: String,
		"the topic name of the subscription"
		topicName: String
	): result
	"adds an exclusion to a policy"
	addExclusionToOffer(
		"the exclusionInput"
		input: exclusionInput!,
		"the identifier of the policy"
		policyId: String!
	): result
	addExclusionToPolicy(
		"the exclusion input"
		input: exclusionInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addExclusionToProposalOffer(
		"the case identifier"
		caseId: String!,
		"the exclusion input"
		input: exclusionInput!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): createdStatusResult
	"Adds a fact to a entity"
	addFact(
		"The entity identifier"
		entityId: String!,
		"The fact input"
		factInput: addFactInput!
	): createdStatusResult
	"adds a fact to a binder"
	addFactToBinder(
		"the binder identifier"
		binderId: String!,
		"the fact to be added"
		input: addFactInput!
	): createdStatusResult
	"adds a fact to a case"
	addFactToCase(
		"the case identifier"
		caseId: String!,
		"the fact to be added"
		input: addFactInput!
	): createdStatusResult
	"Adds a fact to a claim"
	addFactToClaim(
		"the claim identifier"
		claimId: ID!,
		"The input"
		input: addFactInput!
	): createdStatusResult
	"adds a fact to a custom product"
	addFactToProduct(
		"the fact identifier"
		input: addFactInput!,
		"the product identifier"
		productId: productIdInput!
	): createdStatusResult
	addFactToProposalOffer(
		"the case identifier"
		caseId: String!,
		"the fact input"
		input: addFactInput!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): createdStatusResult
	"Adds a fact to a transaction"
	addFactToTransaction(
		"the fact to add"
		input: addFactInput!,
		"the identifier of the transaction"
		transactionId: String!
	): createdStatusResult
	"Adds an attachment to a guarantee of payment"
	addGOPAttachment(
		"The gop identifier"
		gopId: ID!,
		"The attachment input"
		input: attachmentInput!
	): result
	"Adds a note to a guarantee of payment"
	addGOPNote(
		"The gop identifier"
		gopId: ID!,
		"The note input"
		input: addNoteInput!
	): result
	addGOPToClaim(
		"the claim identifier"
		claimId: String!,
		"the gop identifier"
		gopId: String!
	): result
	"adds a host to the tenant settings"
	addHostToTenantSettings(
		"the host to add"
		host: String
	): result
	"Adds an identity to an entity"
	addIdentity(
		"The entity identifier"
		entityId: String!,
		"The identity input"
		identityInput: addIdentityInput!
	): createdStatusResult
	"Adds a login to inherit from to a login"
	addInheritedLoginToLogin(
		"The login id of the the login whose permission will be added."
		loginId: String!,
		"The id of the login to inherit from."
		loginIdToInheritFrom: String!
	): result
	"Adds a login to inherited from to a permission group."
	addInheritedLoginToPermissionGroup(
		"The id of the permission group."
		id: String!,
		"The id of the login to inherit from."
		loginId: String!
	): result
	"adds an input to a function template"
	addInputToFunctionTemplate(
		"the template identifier"
		id: String!,
		"The input"
		input: functionInputInput!
	): createdStatusResult
	"adds an insured to a policy"
	addInsured(
		"the identitifier of the entity to add"
		entityId: String!,
		"the identitifier of the policy to update"
		policyId: String!
	): result
	"add an internal review to a custom product"
	addInternalReviewToProduct(
		"the review identifier"
		input: internalReviewInput!,
		"the product identifier"
		productId: productIdInput!
	): createdStatusResult
	"Adds a lesson completion to a course progression"
	addLessonCompletionToCourseProgression(
		"The course progression identifier"
		courseProgressionId: String!,
		"The input"
		input: addLessonCompletionInput!
	): createdStatusResult
	"Adds an item to a lesson"
	addLessonItem(
		"the course identifier"
		courseId: String!,
		"The input"
		input: addLessonItemInput,
		"the lesson identifier"
		lessonId: String!
	): createdStatusResult
	"Adds a lesson to a section of a course"
	addLessonToSection(
		"the course identifier"
		courseId: String!,
		"The input"
		input: addLessonToSectionInput,
		"the section identifier"
		sectionId: String!
	): createdStatusResult
	"Creates a link between two entities"
	addLink(
		"The link input"
		linkInput: createLinkInput!
	): createdStatusResult
	addLoading(
		"the endorsement identifier"
		endorsementId: String,
		"the loading input"
		input: loadingInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"adds a loading to an offer"
	addLoadingToOffer(
		"the loading to be added"
		input: loadingInput!,
		"the identifier of the policy"
		policyId: String!
	): result
	addLoadingToProposalOffer(
		"the case identifier"
		caseId: String!,
		"the loading input"
		input: loadingInput!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): createdStatusResult
	"Adds metadata to file"
	addMetadata(
		"File and metadata"
		input: AddMetadataGraphType!
	): result
	"Adds an address to the authenticated login"
	addMyAddress(
		"The address input"
		addressInput: addressInput!
	): createdStatusResult
	"Adds a contact detail to an authenticated login"
	addMyContact(
		"The contact input"
		contactInput: addContactInput!
	): createdStatusResult
	"Adds a device to the authenticated user."
	addMyDevice(
		"The id. Can be a registration token"
		deviceId: String!,
		"The device type. Can be any key"
		deviceType: String!
	): result
	"Adds a fact to an authenticated user"
	addMyFact(
		"The fact input"
		factInput: addFactInput!
	): createdStatusResult
	"Adds an identity to the authenticated login"
	addMyIdentity(
		"The identity input"
		identityInput: addIdentityInput!
	): createdStatusResult
	"Adds a link to the authenticated login"
	addMyLink(
		"The link input"
		link: String!,
		"The link input"
		targetId: String!
	): createdStatusResult
	"""

	Changes a field in a given Node state
	If field is missing, adds it
	If field is presented, assign the provided resolver to it
	If provided resolver is empty, detaches the existing resolver from the field
	Can change only user-defined field, e.g.
	cannot change name, id, parent, children, type
	"""
	addNodeField(field: NodeFieldInput!, nodeId: ID!): ID!
	addNodeFields(fields: [NodeFieldInput!]!, nodeId: ID!): ID!
	addNoteToCase(
		"the case identifier"
		caseId: String!,
		"the note to be added"
		input: addNoteInput!
	): result
	"adds an offer to a policy"
	addOffer(
		"the information of the offer"
		offerInput: addOfferInput!,
		"the identifier of the quote"
		policyId: String!
	): createdStatusResult
	"adds an offer to a proposal"
	addOfferToProposal(
		"the identifier of the case"
		caseId: String!,
		"the offer input"
		input: addOfferInput!,
		"the identifier of the case"
		proposalId: String!
	): createdStatusResult
	addOfferToSubscription(
		"the subscription input"
		input: addOfferInput!,
		"the payment config to use"
		subscriptionId: String!
	): result
	"Adds an option to a lesson item"
	addOptionToLessonItem(
		"the course identifier"
		courseId: String!,
		"The input"
		input: addOptionToLessonItemInput,
		"the lesson identifier"
		itemId: String!,
		"the lesson identifier"
		lessonId: String!
	): createdStatusResult
	addOtherContractHolder(
		"the endorsement identifier"
		endorsementId: String,
		"the entityId identifier"
		entityId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addOtherContractHolderAddress(
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the clause input"
		input: addressInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addOtherContractHolderContact(
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the clause input"
		input: addContactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addOtherContractHolderFact(
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the fact input"
		input: addFactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addOtherContractHolderIdentity(
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the clause input"
		input: addIdentityInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"adds a holder to other holders"
	addOtherHolder(
		"the identitifier of the entity to add"
		entityId: String!,
		"the identitifier of the policy to update"
		policyId: String!
	): result
	"adds an output to a function template"
	addOutputToFunctionTemplate(
		"the template identifier"
		id: String!,
		"The input"
		input: functionOutputInput!
	): createdStatusResult
	"Adds a page object with settings to a wkhtmltopdf template"
	addPageObjectToWkhtmltopdfTemplate(
		"The input"
		input: addPageObjectToWkhtmltopdfTemplateInput!,
		"The template id"
		templateId: String!
	): stringResult
	"Adds an attachment to a panel provider tier"
	addPanelProviderTierAttachment(
		"The attachment input"
		input: attachmentInput!,
		"The panelProviderTier identifier"
		panelProviderTierId: String!
	): result
	"Adds a serviceItemAgreedFee to a panelProviderTier"
	addPanelProviderTierServiceItemAgreedFee(
		"The panelProviderTier identifier"
		panelProviderTierId: String!,
		"The serviceItemAgreedFee identifier"
		serviceItemAgreedFeeId: String!
	): result
	"Adds payment info to a policy"
	addPaymentInfo(
		"The payment info input"
		input: addPaymentInfoInput!,
		"The policy id"
		policyId: String!
	): result
	"Adds payment info to a case"
	addPaymentInfoToCase(
		"The case id"
		caseId: String!,
		"The payment info input"
		input: addPaymentInfoInput!
	): createdStatusResult
	"Adds a drawing to a pdf template"
	addPdfDrawing(
		"The input"
		input: addPdfDrawingInput!,
		"The template id to update"
		templateId: String!
	): stringResult
	"Adds a permission group to a permission group."
	addPermissionGroupToPermissionGroup(
		"The id of the permission group."
		id: String!,
		"The id of the permission group to be added."
		permissionGroupId: String!
	): result
	"Adds a permission to a permission group."
	addPermissionToPermissionGroup(
		"The id of the permission group."
		id: String!,
		"The id of the permission to be added."
		permissionId: String!,
		"The id of the target to be added. Put 'all' to add all targets."
		targetId: String!
	): result
	"Adds an attachment to a policy"
	addPolicyAttachment(
		"The attachment input"
		input: attachmentInput!,
		"The policy identifier"
		policyId: String!
	): result
	addPolicyFact(
		"the endorsement identifier"
		endorsementId: String,
		"the fact input"
		input: addFactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addPolicyMember(input: policies_AddPolicyMemberInput!): policies_AddPolicyMemberPayload!
	"Adds a note to a policy"
	addPolicyNote(
		"The note input"
		noteInput: addNoteInput!,
		"The policy identifier"
		policyId: String!
	): result
	"adds a pricing option to a product"
	addPricingOption(
		"the pricing option"
		input: pricingOptionInput!,
		"the product identifier"
		productId: productIdInput!
	): createdStatusResult!
	"adds a proposal"
	addProposal(
		"the case identifier"
		caseId: String!,
		"the input"
		input: addProposalInput!
	): createdStatusResult
	"Adds a score"
	addScore(
		"The input"
		input: addScoreInput!,
		"The identifier of the review"
		reviewId: String!
	): createdStatusResult
	addScriptToProduct(
		"Add a script to the product"
		input: addScriptToProductInput!
	): result
	"Adds a section to a course"
	addSectionToCourse(
		"the course identifier"
		courseId: String!
	): createdStatusResult
	"Adds a section to an other section"
	addSectionToSection(
		"the course identifier"
		courseId: String!,
		"the section identifier"
		sectionId: String!
	): createdStatusResult
	addStakeholderToCase(
		"the case identifier"
		caseId: String!,
		"the stakeholder input"
		input: addStakeholderInput!
	): createdStatusResult
	addStakeholderToClaim(
		"the claim identifier"
		claimId: String!,
		"the stakeholder input"
		input: addStakeholderInput!
	): createdStatusResult
	addStakeholderToPolicy(
		"the stakeholder input"
		input: addStakeholderInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	addStakeholderToProposal(
		"the case identifier"
		caseId: String!,
		"the stakeholder input"
		input: addStakeholderInput!,
		"the proposal identifier"
		proposalId: String!
	): createdStatusResult
	addStakeholderToProposalOffer(
		"the case identifier"
		caseId: String!,
		"the stakeholder input"
		input: addStakeholderInput!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): createdStatusResult
	addStakeholderToTransaction(
		"the stakeholder input"
		input: addStakeholderInput!,
		"the transaction identifier"
		transactionId: String!
	): createdStatusResult
	"adds a tag to a notification subscription"
	addTagToNotificationSubscription(
		"the notification subscription identifier"
		id: String!,
		"the tag content"
		input: tagInput!
	): createdStatusResult
	addTagToPolicy(
		"the tag input"
		input: tagInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"adds a tag to a custom product"
	addTagToProduct(
		"the tag identifier"
		input: tagInput!,
		"the product identifier"
		productId: productIdInput!
	): createdStatusResult
	addTargetedPermissionSchemaToLogin(
		"Add a permissionSchema to the login"
		input: addTargetedPermissionSchemaToLoginInput!
	): result
	"Adds a permission to a target to a login"
	addTargettedPermission(
		"The input necessary to add a permission to a target to a login"
		addTargettedPermissionInput: addTargettedPermissionInput!,
		"the login id of the the login whose permission will be added."
		loginId: String!
	): result
	"adds a list of targettedPermissions to a login"
	addTargettedPermissions(
		"the targetted permission inputs"
		inputs: [addTargettedPermissionInput]!,
		"the login id of the the login to whom the permissions will be added."
		loginId: String!
	): result
	addTemplateRelationshipToProduct(
		"Add a template relationship to the product"
		input: addTemplateRelationshipToProductInput!
	): result
	"Adds a login to a permission group"
	addToPermissionGroup(
		"The login id of the the login whose permission will be added."
		loginId: String!,
		"The id of the permission group."
		permissionGroupId: String!
	): result
	"Adds an attachment to a transaction"
	addTransactionAttachment(
		"The attachment input"
		input: attachmentInput!,
		"The transaction identifier"
		transactionId: String!
	): result
	"Adds a note to a transaction"
	addTransactionNote(
		"The note input"
		input: addNoteInput!,
		"The transaction identifier"
		transactionId: ID!
	): result
	addUiSchemaToDataSchema(
		"Add a uiSchema to the dataSchema"
		input: addUiSchemaToDataSchemaInput!
	): result
	addUiSchemaToProductSchema(input: UiSchemaInput!, productSchemaId: ID!): Result!
	"Adds an underwriting variable"
	addUnderwritingVariable(
		"The underwriting variable"
		input: addUnderwritingVariableInput!,
		"the product identifier"
		productId: productIdInput!
	): result!
	"Add an update policy to a request"
	addUpdateBeneficiaryEligibilitiesToRequest(
		"The identifier of the beneficiaryEligibility to update"
		beneficiaryEligibilityId: String!,
		"the update policy input"
		input: beneficiaryEligibilityInput!,
		"The policy id to update"
		policyId: String!,
		"The request id to update"
		requestId: String!
	): result @deprecated(reason: "Use `updateBeneficiaryEligibility` instead.")
	"Add an update payment info to a request"
	addUpdatePaymentInfoToRequest(
		"the update payment info input"
		input: paymentInfosToUpdate!,
		"The identifier of the payment info to update"
		paymentInfoId: String!,
		"The policy id to update"
		policyId: String!,
		"The request id to update"
		requestId: String!
	): result @deprecated(reason: "Use `updatePaymentInfo` instead.")
	"Add an update policy to a request"
	addUpdatePolicyToRequest(
		"the update policy input"
		input: updatePolicyInput!,
		"The policy id to update"
		policyId: String!,
		"The request id to update"
		requestId: String!
	): result @deprecated(reason: "Use `updatePolicy2` instead.")
	"Add an upsert benefit option to a request"
	addUpsertBenefitOptionToRequest(
		"the benefit option input"
		input: benefitOptionInput!,
		"the identifier of the offer"
		offerId: String,
		"The policy id to update"
		policyId: String!,
		"The request id to update"
		requestId: String!
	): result @deprecated(reason: "Use `upsertBenefitOption` instead.")
	addressMutationAddressBatch(batch: users_AddressBatchCommandInput): users_Result
	agentReminderMutationBatch(batch: users_GenericAgentReminder3BatchInput): users_Result
	agentReminderMutationCreate(create: users_AgentReminderUpsertInput): users_ResultOfCreatedStatus
	agentReminderMutationDelete(delete: users_AgentReminderUpsertInput): users_Result
	agentReminderMutationUpdate(update: users_AgentReminderUpsertInput): users_Result
	agreedFeeGroupMutationBatch(batch: users_GenericAgreedFeeGroup3BatchInput): users_Result
	agreedFeeGroupMutationCreate(create: users_AgreedFeeGroupUpsertInput): users_ResultOfCreatedStatus
	agreedFeeGroupMutationDelete(delete: users_AgreedFeeGroupUpsertInput): users_Result
	agreedFeeGroupMutationUpdate(update: users_AgreedFeeGroupUpsertInput): users_Result
	agreedFeeMutationBatch(batch: users_GenericAgreedFee3BatchInput): users_Result
	agreedFeeMutationCreate(create: users_AgreedFeeUpsertInput): users_ResultOfCreatedStatus
	agreedFeeMutationDelete(delete: users_AgreedFeeUpsertInput): users_Result
	agreedFeeMutationUpdate(update: users_AgreedFeeUpsertInput): users_Result
	approveConsentRequest(input: ApproveConsentRequestInput!): ClaimInvestigationModel!
	"approves a guarantee of payment"
	approveGOP(
		"the guarantee of payment identifier"
		gopId: ID!,
		"The input"
		input: approveGOPInput
	): result
	"Assigns a login to a permission group"
	assignPermissionGroup(
		"the identifier of the login to assign the permission group to"
		loginId: String!,
		"the identitifer of the permission group to assign"
		permissionGroupId: String!
	): result
	attachNodeFieldResolver(input: AttachNodeFieldResolverInput!, nodeId: ID!): ID! @deprecated(reason: "Use AttachOrReplaceNodeFieldResolver instead")
	attachNodeScript(nodeId: ID!, script: NodeScriptInput!): Result!
	attachOrReplaceNodeFieldResolver(input: AttachNodeFieldResolverInput!, nodeId: ID!): ID!
	authorityLimitMutationBatch(batch: claims_GenericAuthorityLimit3BatchInput): claims_Result
	authorityLimitMutationCreate(create: claims_AuthorityLimitUpsertInput): claims_ResultOfCreatedStatus
	authorityLimitMutationDelete(delete: claims_AuthorityLimitUpsertInput): claims_Result
	authorityLimitMutationUpdate(update: claims_AuthorityLimitUpsertInput): claims_Result
	batchBenefitDefinition(
		"batch benefitDefinition input"
		input: batchBenefitDefinitionInput!
	): result
	batchBenefitDefinitionType(
		"batch benefitDefinitionType input"
		input: batchBenefitDefinitionTypeInput!
	): result
	"Integrate with an issuer a batch of policies"
	batchIntegrate(
		"The date from which to integrate to."
		from: DateTimeOffset!,
		"The issuer id to integrate with"
		issuerId: String!,
		"The date to which to integrate to."
		to: DateTimeOffset!
	): result
	billTriggerAccumulateRevenueOwed: String!
	billTriggerCollectPremium: String!
	billTriggerIssueBills: String!
	billingAccumulateRevenueOwed(billingInfoId: String!): String!
	billingCollectPremium(billingInfoId: String!): String!
	billingCreate(command: billing_CreateBillingInput!): UUID!
	billingDelete(billingInfoId: String!): billing_BillingInfo!
	billingPremiumInstallmentAttachemntsAdd(billingInfoId: String!, command: billing_BillPremiumInstallmentAddAttachmentInput!): billing_BillingInfo!
	billingPremiumInstallmentAttachemntsRemove(billingInfoId: String!, command: billing_BillPremiumInstallmentRemoveAttachmentInput!): billing_BillingInfo!
	billingSetPaymentChannel(billingInfoId: String!, command: billing_BillSetPaymentChannelInput!): billing_BillingBill!
	billingUpdate(billingInfoId: String!, command: billing_UpdateBillingInput!): billing_BillingInfo!
	brokersMutationBatch(batch: cases_GenericBroker3BatchInput): cases_Result
	brokersMutationCreate(create: cases_BrokerUpsertInput): cases_ResultOfCreatedStatus
	brokersMutationDelete(delete: cases_BrokerUpsertInput): cases_Result
	brokersMutationUpdate(update: cases_BrokerUpsertInput): cases_Result
	cancelConsentRequest(input: CancelConsentRequestInput!): ClaimInvestigationModel!
	cancelEvidenceRequest(input: CancelEvidenceRequestInput!): ClaimInvestigationModel!
	"Cancels an issued policy"
	cancelPolicy(
		"the identifier of the policy"
		policyId: String!,
		"the reason why the policy was cancelled"
		reason: String!
	): result
	cancelSubscription(
		"the identifier of the subscription to cancel"
		subscriptionId: String!
	): result
	caseFactBatch(
		"the case identifier"
		caseId: String!,
		"the fact input"
		input: factBatchInput!
	): result
	changeNodeFieldType(input: ChangeNodeFieldTypeInput!, nodeId: ID!): ID!
	"Use when login wants to change password"
	changePassword(
		"Input to change the password"
		changePasswordInput: changePasswordInput!
	): result
	claimBatch(
		"the claim batch input"
		input: claimBatchInput!
	): result
	claimBatchV2(
		"the claim batch input"
		input: claimBatchInput!
	): createdStatusResult
	"A batch of fact operations on a claim"
	claimFactBatch(
		"the claim identifier"
		claimId: ID!,
		"The fact batch input"
		input: factBatchInput!
	): result
	claimMutationAddGuaranteeOfPaymentsBatch(input: claims_GuaranteeOfPaymentBatchCommandInput): claims_ResultOfCreatedStatus
	claimMutationGeneratePaymentNumber(input: claims_ClaimIdsInput): claims_Result
	claimMutationImport(importClaimsCommand: claims_ImportClaimsCommandInput): claims_Result
	claimMutationPreRequestApproval(preRequestApproval: claims_PreRequestApprovalCommandInput): claims_Result
	claimMutationReplayEvents(command: claims_ReplayEventsInput): claims_Result
	claimRejectionCodesMutationBatch(batch: claims_GenericClaimRejectionCode3BatchInput): claims_Result
	claimRejectionCodesMutationCreate(create: claims_ClaimRejectionCodeUpsertInput): claims_ResultOfCreatedStatus
	claimRejectionCodesMutationDelete(delete: claims_ClaimRejectionCodeUpsertInput): claims_Result
	claimRejectionCodesMutationUpdate(update: claims_ClaimRejectionCodeUpsertInput): claims_Result
	claimRejectionReasonMutationBatch(batch: claims_GenericClaimRejectionReason3BatchInput): claims_Result
	claimRejectionReasonMutationCreate(create: claims_ClaimRejectionReasonUpsertInput): claims_ResultOfCreatedStatus
	claimRejectionReasonMutationDelete(delete: claims_ClaimRejectionReasonUpsertInput): claims_Result
	claimRejectionReasonMutationUpdate(update: claims_ClaimRejectionReasonUpsertInput): claims_Result
	claimRemarkAddOrUpdate(input: remarkUpsert!): result
	claimRemarkDelete(
		"remark id to be deleted"
		remarkId: String
	): result
	claimRequestReasonMutationBatch(batch: claims_GenericClaimRequestReason3BatchInput): claims_Result
	claimRequestReasonMutationCreate(create: claims_ClaimRequestReasonUpsertInput): claims_ResultOfCreatedStatus
	claimRequestReasonMutationDelete(delete: claims_ClaimRequestReasonUpsertInput): claims_Result
	claimRequestReasonMutationUpdate(update: claims_ClaimRequestReasonUpsertInput): claims_Result
	claims_AttachedCommandPermissionMutationCreate(command: claims_CreateAttachedRuleCommandOfclaimsAttachedCommandPermissionInput): claims_ResultOfCreatedStatus
	claims_AttachedCommandPermissionMutationDelete(command: claims_DeleteAttachedRuleCommandOfclaimsAttachedCommandPermissionInput): claims_Result
	claims_AttachedCommandPermissionMutationUpdate(command: claims_UpdateAttachedRuleCommandOfclaimsAttachedCommandPermissionInput): claims_Result
	claims_AttachedExternalApiCallMutationCreate(command: claims_CreateAttachedRuleCommandOfclaimsAttachedExternalApiCallInput): claims_ResultOfCreatedStatus
	claims_AttachedExternalApiCallMutationDelete(command: claims_DeleteAttachedRuleCommandOfclaimsAttachedExternalApiCallInput): claims_Result
	claims_AttachedExternalApiCallMutationUpdate(command: claims_UpdateAttachedRuleCommandOfclaimsAttachedExternalApiCallInput): claims_Result
	claims_AttachedFilterMutationCreate(command: claims_CreateAttachedRuleCommandOfclaimsAttachedFilterInput): claims_ResultOfCreatedStatus
	claims_AttachedFilterMutationDelete(command: claims_DeleteAttachedRuleCommandOfclaimsAttachedFilterInput): claims_Result
	claims_AttachedFilterMutationUpdate(command: claims_UpdateAttachedRuleCommandOfclaimsAttachedFilterInput): claims_Result
	claims_AttachedObjectValidationMutationCreate(command: claims_CreateAttachedRuleCommandOfclaimsAttachedObjectValidationInput): claims_ResultOfCreatedStatus
	claims_AttachedObjectValidationMutationDelete(command: claims_DeleteAttachedRuleCommandOfclaimsAttachedObjectValidationInput): claims_Result
	claims_AttachedObjectValidationMutationUpdate(command: claims_UpdateAttachedRuleCommandOfclaimsAttachedObjectValidationInput): claims_Result
	claims_AttachedPostHandleValidationMutationCreate(command: claims_CreateAttachedRuleCommandOfclaimsAttachedPostHandleValidationInput): claims_ResultOfCreatedStatus
	claims_AttachedPostHandleValidationMutationDelete(command: claims_DeleteAttachedRuleCommandOfclaimsAttachedPostHandleValidationInput): claims_Result
	claims_AttachedPostHandleValidationMutationUpdate(command: claims_UpdateAttachedRuleCommandOfclaimsAttachedPostHandleValidationInput): claims_Result
	cleanProductTest(
		"The type of product to clean data of"
		typeId: String!
	): result
	"Clones a product"
	cloneProduct(
		"the cloned product"
		input: cloneProductInput!,
		"the l10n name to upsert"
		name: upsertL10nCloneProductNameInput,
		"the product identifier"
		productId: productIdInput!
	): result!
	cloneTree(nodeId: ID!): ID!
	closeInvestigation(investigationId: ID!): ClaimInvestigationModel!
	collectEvidence(input: CollectEvidenceInput!): ClaimInvestigationModel!
	"compute all achievement types for an entity"
	computeAchievementTypes(
		"the identifier of the entity"
		entityId: String!
	): result
	"Verifies the code that has been sent to the email of the login."
	confirmEmail(
		"The email verificiation code"
		code: String!,
		"The login id"
		loginId: String!,
		"Send a notification part of confirming email"
		sendNotificationInput: sendNotificationInput,
		"the tenant identifier"
		tenantId: String!
	): result
	"Creates a bridge between CoverGo's stripe account and the client's stripe account"
	connectWithStripe(
		"The stripe authorization code of the tenant"
		authorizationCode: String!,
		"The tenant identifier"
		tenantId: String!
	): result
	contractHolderFactBatch(
		"the fact input"
		input: factBatchInput!,
		"the policy identifier"
		policyId: String!
	): result
	"Converts an offer"
	convertOffer(
		"the identifier of the offer"
		offerId: String!,
		"the identifier of the policy"
		policyId: String
	): result
	"Copies multiple files from one location to another"
	copyFiles(
		"The bucket identifier"
		bucketName: String,
		"File to be copied"
		copyFileInputs: [copyFileInput]!
	): result
	"copies a proposal"
	copyProposal(
		"the case identifier"
		caseId: String!,
		"the input"
		input: copyProposalInput!
	): createdStatusResult
	counterMutationIncrease(command: cases_IncreaseCounterCommandInput): cases_ResultOfInt64
	"get access token using otpLogin"
	createAccessTokenFromOtpLogin(
		"the input necessary to get an accessToken using otpLogin"
		input: createAccessTokenFromOtpLoginInput!
	): tokenResult
	"creates an achievement"
	createAchievement(
		"the input"
		input: createAchievementInput!
	): createdStatusResult
	"creates an achievement type"
	createAchievementType(
		"the input"
		input: createAchievementTypeInput!
	): createdStatusResult
	"Creates a new app."
	createApp(
		"The app to be created."
		input: createAppInput!
	): result
	createBenefitDefinition(
		"Create a benefitDefinition"
		input: createBenefitDefinitionInput!
	): createdStatusResult
	createBenefitDefinitionType(
		"Create a benefitDefinitionType"
		input: createBenefitDefinitionTypeInput!
	): createdStatusResult
	"Creates a binder"
	createBinder(
		"The input"
		input: binderInput!
	): createdStatusResult
	"creates a case"
	createCase(
		"the input"
		input: createCaseInput!
	): createdStatusResult
	"Creates a claim"
	createClaim(
		"The input"
		input: createClaimInput!
	): createdStatusResult
	"Creates a clauseHtml template"
	createClauseHtmlTemplate(
		"The input"
		input: createClauseHtmlTemplateInput!
	): createdStatusResult
	"Creates a company"
	createCompany(
		"The company input"
		createCompanyInput: createCompanyInput!
	): createdStatusResult
	"Creates a component"
	createComponent(
		"The input"
		input: createComponentInput!
	): createdStatusResult
	"creates a course"
	createCourse(
		"the input"
		input: createCourseInput!
	): createdStatusResult
	"creates a Course progression"
	createCourseProgression(
		"The input"
		input: createCourseProgressionInput!
	): createdStatusResult
	createDataSchema(
		"Create a dataSchema"
		input: createDataSchemaInput!
	): createdStatusResult
	"Creates a diagnosis"
	createDiagnosis(
		"The input"
		input: diagnosisInput!
	): createdStatusResult
	"Creates a disability"
	createDisability(
		"The input"
		input: disabilityInput!
	): createdStatusResult
	"Creates a dynamic template"
	createDynamicTemplate(
		"The input"
		input: createDynamicTemplateInput!
	): createdStatusResult
	"Creates an email MJML template"
	createEmailMjmlTemplate(
		"The input"
		input: createEmailMjmlTemplateInput!
	): result
	"creates a fileSystemConfig"
	createFileSystemConfig(
		"the config input"
		input: fileSystemConfigInput!
	): createdStatusResult
	"creates a folder."
	createFolder(
		"The bucket identifier"
		bucketName: String,
		"The folder key"
		key: String!
	): result
	"creates a function template"
	createFunctionTemplate(
		"The input"
		input: createFunctionTemplateInput!
	): createdStatusResult
	"Creates a guarantee of payment"
	createGOP(
		"The input"
		input: createGOPInput!
	): createdStatusResult
	"Creates an individual"
	createIndividual(
		"The create individual input"
		createIndividualInput: createIndividualInput!
	): createdStatusResult
	"Creates an insurer"
	createInsurer(
		"The insurer to be created"
		input: createInsurerInput!
	): result!
	"Creates an internal user"
	createInternal(
		"The create internal input"
		createInternalInput: createInternalInput!
	): createdStatusResult
	"Creates a jacket"
	createJacket(
		"The input"
		input: createJacketInput!
	): createdStatusResult
	createJobSchedule(input: jobScheduleInput!): result
	"create applicant for an Individual in eKYC provider"
	createKycApplicant(
		"The individual identifier"
		individualId: String!,
		"Input for creating an KYC applicant"
		input: createKycApplicantInput!
	): stringResult
	"Creates a login"
	createLogin(
		"the input necessary to create a login"
		createLoginInput: createLoginInput!
	): createdStatusResult
	"""

	Create new node with a given state.
	If type is specified, will create a node of the specified type
	In this case node state should contain only field overrides or could be omitted
	Can create many nodes if specified in children or parent
	"""
	createNode(node: CreateNodeInput!): ID!
	"creates a notification config"
	createNotificationConfig(
		"the config input"
		config: createNotificationConfigInput!
	): result
	"creates a notification subscription"
	createNotificationSubscription(
		"the topic name"
		topicName: String!
	): createdStatusResult
	"Creates a notification template"
	createNotificationTemplate(
		"The input"
		input: createNotificationTemplateInput!
	): createdStatusResult
	"Creates a notification trigger"
	createNotificationTrigger(
		"Input to create a notification trigger"
		input: createNotificationTriggerInput!
	): result!
	"Creates an object"
	createObject(
		"The create object input"
		createObjectInput: createObjectInput!
	): createdStatusResult
	"Creates an organization user"
	createOrganization(
		"The create organization input"
		createOrganizationInput: createOrganizationInput!
	): createdStatusResult
	"request an otp login"
	createOtpLogin(
		"the input necessary to create a otpLogin"
		input: createOtpLoginInput!
	): otpLoginResult
	createPanelProviderTier(
		"Create a PanelProviderTier"
		input: createPanelProviderTierInput!
	): createdStatusResult
	createPaymentMethod(
		"the bank input"
		bankInput: bankPaymentMethodInput,
		"the card input"
		cardInput: cardPaymentMethodInput,
		"the identifier of the entity to add the payment method to"
		entityId: String!,
		"the payment config to use"
		providerConfigId: String,
		"the provider token to create the payment method from"
		providerToken: String
	): createdStatusResult
	"adds a paymentProviderConfig"
	createPaymentProviderConfig(
		"The transaction identifier"
		transactionsInput: initializeTenantTransactionsInput!
	): result
	"Creates a PDF Drawing template"
	createPdfDrawingTemplate(
		"The input"
		input: createPdfDrawingTemplateInput!
	): result
	"Creates a group of permissions"
	createPermissionGroup(
		"Input to create permission group"
		createPermissionGroupInput: createPermissionGroupInput!
	): result
	"Creates a new targeted permisstion schema for fields."
	createPermissionSchema(
		"The app to be created."
		input: createPermissionSchemaInput!
	): createdStatusResult
	"creates a plan"
	createPlan(
		"the plan input"
		input: planInput!
	): result
	"creates pricing rules to a plan"
	createPlanPriceLogic(
		"the price logic input"
		input: priceLogicInput!,
		"the plan identifier"
		productId: productIdInput!
	): result!
	"Request an policy update"
	createPolicyUpdateRequest(
		"The policy id to update"
		policyId: String!
	): createdStatusResult @deprecated(reason: "Use `addEndorsement` instead.")
	"request a preOtpLogin for future login using One Time Password"
	createPreOtpLogin(
		"boolean flag to instruct the system to create an new Individual Entity or not"
		createIndividual: Boolean,
		"the template Id for email notification"
		emailTemplateId: String!,
		"boolean flag to instruct the system to generate a unique username or not"
		generateUniqueUsername: Boolean,
		"the input necessary to create a preOtpLogin"
		input: createPreOtpLoginInput!
	): preOtpLoginResult
	"creates pricing rules to a product"
	createPriceLogic(
		"the price logic input"
		input: priceLogicInput!,
		"the product identifier"
		productId: productIdInput!
	): result!
	"Creates a product"
	createProduct(
		"The product to create"
		product: createProductInput
	): product
	"creates a productConfig"
	createProductConfig(
		"the config input"
		input: productConfigInput!
	): createdStatusResult
	createProductSchema(input: ProductSchemaInput!): ResultOfGuid!
	"Creates a product type"
	createProductType(
		"The product type to be created"
		input: createProductTypeInput!
	): result!
	"creates a review"
	createReview(
		"the input"
		input: createReviewInput!
	): createdStatusResult
	createScript(
		"Create a script"
		input: createScriptInput!
	): createdStatusResult
	createServiceItem(
		"Create a ServiceItem"
		input: createServiceItemInput!
	): createdStatusResult
	createServiceItemAgreedFee(
		"Create a serviceItemAgreedFee"
		input: createServiceItemAgreedFeeInput!
	): createdStatusResult
	"Creates an Sms template"
	createSmsTemplate(
		"The input"
		input: createSmsTemplateInput!
	): result
	createSubscription(
		"the identifier of the entity to add the payment method to"
		entityId: String!,
		"the subscription input"
		input: createSubscriptionInput!,
		"the identifier of the payment method to use"
		paymentMethodId: String,
		"the payment config to use"
		providerConfigId: String
	): createdStatusResult
	createTenant(tenantId: String!): OpenAddressDto!
	"Creates a transaction"
	createTransaction(
		"the create transaction input"
		input: createTransactionInput!
	): createdStatusResult
	"Creates a treatment"
	createTreatment(
		"The input"
		input: treatmentInput!
	): createdStatusResult
	createUiSchema(
		"Create a uiSchema"
		input: createUiSchemaInput!
	): createdStatusResult
	createUserStorageItem(
		"UserStorageItem create input"
		input: userStorageItemCreateInput
	): result
	"Creates a wkhtmltopdf template"
	createWkhtmltopdfTemplate(
		"The input"
		input: createWkhtmltopdfTemplateInput!
	): createdStatusResult
	"""

	Can be called again for the same type for update
	Differs from DefineJSClass as node types will support more operations in future, like adding fields, checking formulas, etc
	"""
	defineNodeType(fields: [NodeFieldInput!], typeName: String!): ID!
	defineOpenType(engine: String!, group: String!, parentType: OpenTypeDtoInput, payload: String!, typeName: String!): OpenAddressDto!
	"deletes an achievement"
	deleteAchievement(
		"the identifier of the achievement"
		id: String!
	): result
	"deletes an achievement type"
	deleteAchievementType(
		"the identifier of the achievement type"
		id: String!
	): result
	"Deletes an address of a entity"
	deleteAddress(
		"The entity identifier"
		entityId: String!,
		"The address identifier"
		id: String!
	): result @deprecated(reason: "Use 'remove' call to align with proper naming convention")
	"deletes all l10n for a certain key"
	deleteAllL10n(
		"The key to delete"
		key: String!
	): result
	"deletes an app"
	deleteApp(
		"The app identifier"
		appId: String!
	): result
	deleteBenefitDefinition(
		"Delete a benefitDefinition"
		input: deleteBenefitDefinitionInput!
	): result
	deleteBenefitDefinitionType(
		"Delete a benefitDefinitionType"
		input: deleteBenefitDefinitionTypeInput!
	): result
	"Deletes a binder"
	deleteBinder(
		"The binder identifier"
		binderId: ID!
	): result
	"deletes a case"
	deleteCase(
		"the identifier of the case"
		id: String!
	): result
	"Deletes a claim"
	deleteClaim(
		"the claim identifier"
		claimId: ID!
	): result
	"Deletes a cms config"
	deleteCmsConfig(
		"The application identifier"
		appId: String!
	): result
	"Deletes a component"
	deleteComponent(
		"The component's id"
		id: String!
	): result
	"Deletes a contact of an entity"
	deleteContact(
		"The entity identifier"
		entityId: String!,
		"The contact identifier"
		id: String!
	): result @deprecated(reason: "Use 'remove' call to align with proper naming convention")
	"deletes a course"
	deleteCourse(
		"the identifier of the course"
		id: String!
	): result
	"deletes a Course progression"
	deleteCourseProgression(
		"The course progression identifier"
		id: String!
	): result
	deleteDataSchema(
		"Delete a dataSchema"
		input: deleteDataSchemaInput!
	): result
	"Deletes a diagnosis"
	deleteDiagnosis(
		"The diagnosis identifier"
		diagnosisId: String!
	): result
	"Deletes a disability"
	deleteDisability(
		"The disability identifier"
		disabilityId: String!
	): result
	"deletes an entity"
	deleteEntity(
		"the id of the entity to delete"
		id: String!
	): result
	"Deletes a fact of an entity"
	deleteFact(
		"The entity identifier"
		entityId: String!,
		"The contact identifier"
		id: String!
	): result @deprecated(reason: "Use 'remove' call to align with proper naming convention")
	"deletes a file."
	deleteFile(
		"The bucket identifier"
		bucketName: String,
		"The file key"
		key: String!
	): result
	"deletes a fileSystemConfig"
	deleteFileSystemConfig(
		"the identifier of the config"
		id: String!
	): result
	"deletes multiple files."
	deleteFiles(
		"The bucket identifier"
		bucketName: String,
		"The file keys"
		keys: [String]!
	): result
	"deletes a folder."
	deleteFolder(
		"The bucket identifier"
		bucketName: String,
		"The folder key"
		key: String!
	): result
	"Deletes a guarantee of payment"
	deleteGOP(
		"the guarantee of payment identifier"
		gopId: ID!
	): result
	"Deletes an identity of the authenticated login"
	deleteIdentity(
		"The entity identifier"
		entityId: String!,
		"The identity identifier"
		id: String!
	): result @deprecated(reason: "Use 'remove' call to align with proper naming convention")
	"Deletes an insurer"
	deleteInsurer(
		"The insurer identifier"
		id: String
	): result!
	"Deletes a jacket"
	deleteJacket(
		"the jacket identifier"
		jacketId: String!
	): result
	deleteJobSchedule(
		"Name of job schedule to remove"
		jobScheduleName: String!
	): result
	"deletes a l10n"
	deleteL10n(
		"The key to delete"
		key: String!,
		"The local to delete from"
		locale: String!
	): result
	"Deletes a login"
	deleteLogin(
		"the loginId of the login to delete"
		loginId: String!
	): result
	"Deletes an address of the authenticated entity"
	deleteMyAddress(
		"The address identifier"
		id: String!
	): result @deprecated(reason: "Use 'remove' call to align with proper naming convention")
	"Deletes a contact of the authenticated login"
	deleteMyContact(
		"The contact identifier"
		id: String!
	): result @deprecated(reason: "Use 'remove' call to align with proper naming convention")
	"Deletes a fact of an authenticated login"
	deleteMyFact(
		"The contact identifier"
		id: String!
	): result @deprecated(reason: "Use 'remove' call to align with proper naming convention")
	"Deletes an identity of the authenticated login"
	deleteMyIdentity(
		"The identity identifier"
		id: String!
	): result @deprecated(reason: "Use 'remove' call to align with proper naming convention")
	deleteNode(nodeId: ID!): ID!
	"Delete the notification"
	deleteNotification(
		"The notification identifier"
		notificationId: String!
	): result
	"deletes a notification config"
	deleteNotificationConfig(
		"the client id identifier for which to delete the config"
		clientId: String!
	): result
	"deletes a notification subscription"
	deleteNotificationSubscription(
		"the id of the subscription"
		id: String,
		"the topic name of the subscription"
		topicName: String
	): result
	"Deletes a notfication trigger"
	deleteNotificationTrigger(
		"The notification trigger identifier"
		notificationTriggerId: String!
	): result!
	"Deletes a panel provider tier"
	deletePanelProviderTier(
		"the panel provider tier identifier"
		panelProviderTierId: String!
	): result
	deletePaymentMethod(
		"the identifier of the payment method to delete"
		id: String!
	): result
	"Deletes a permission group"
	deletePermissionGroup(
		"The id of the permission group to delete"
		id: String!
	): result
	"deletes an targeted permisstion schema for fields."
	deletePermissionSchema(
		"The permission schema identifier"
		permissionSchemaId: String!
	): result
	"deletes a plan"
	deletePlan(
		"the identifier of the plan"
		id: productIdInput!
	): result
	"deletes pricing rules of a plan"
	deletePlanPriceLogic(
		"the product identifier"
		productId: productIdInput!
	): result!
	"deletes a policy"
	deletePolicy(
		"The policy identifier"
		id: String!
	): result
	deletePolicyMember(input: policies_DeletePolicyMemberInput!): policies_DeletePolicyMemberPayload!
	deletePolicyMembers(input: policies_DeletePolicyMembersInput!): policies_DeletePolicyMembersPayload!
	"Delete policy update request"
	deletePolicyUpdateRequest(
		"The policy id"
		policyId: String!,
		"The request id to delete"
		requestId: String!
	): result @deprecated(reason: "Use `removeEndorsement` instead.")
	"deletes pricing rules of a product"
	deletePriceLogic(
		"the product identifier"
		productId: productIdInput!
	): result!
	"Deletes a product"
	deleteProduct(
		"the product identifier"
		productId: productIdInput!
	): result!
	"deletes a productConfig"
	deleteProductConfig(
		"the identifier of the config"
		id: String!
	): result
	deleteProductSchema(productSchemaId: ID!): Result!
	"Deletes a product type"
	deleteProductType(
		"The type identifier"
		typeId: String
	): result!
	"deletes a review"
	deleteReview(
		"the identifier of the review"
		id: String!
	): result
	deleteScript(
		"Delete a script"
		input: removeScriptInput!
	): result
	deleteServiceItem(
		"Delete a ServiceItem"
		input: deleteServiceItemInput!
	): result
	deleteServiceItemAgreedFee(
		"Delete a serviceItemAgreedFee"
		input: deleteServiceItemAgreedFeeInput!
	): result
	deleteSubscription(
		"the identifier of the subscription to delete"
		id: String!
	): result
	"Deletes a PDF Drawing template"
	deleteTemplate(
		"The template id to update"
		templateId: String!
	): result
	"Deletes a transaction"
	deleteTransaction(
		"the identifier of the transaction to update"
		transactionId: String!
	): result
	"Deletes a treatment"
	deleteTreatment(
		"The treatment identifier"
		treatmentId: String!
	): result
	deleteUiSchema(
		"Delete a uiSchema"
		input: deleteUiSchemaInput!
	): result
	deleteUserStorageItem(
		"UserStorageItem key"
		key: String
	): result
	detachNodeFieldResolver(fieldRef: String!, nodeId: ID!): ID!
	detachNodeScript(nodeId: ID!): Result!
	"diagnosis Batch"
	diagnosisBatch(
		"The input"
		input: diagnosisBatchInput!
	): result
	directDebitAuthorize(command: billing_AuthorizeDirectDebitCommandInput!, id: String!): billing_DirectDebitPaymentChannel!
	directDebitCreate(command: billing_CreateDirectDebitPaymentChannelCommandInput!): UUID!
	directDebitDelete(id: String!): billing_DirectDebitPaymentChannel!
	directDebitSetBankResponse(command: billing_SetBankResponseCommandInput!, id: String!): String!
	directDebitUpdate(command: billing_UpdateDirectDebitPaymentChannelCommandInput!, id: String!): billing_DirectDebitPaymentChannel!
	"disability Batch"
	disabilityBatch(
		"The input"
		input: disabilityBatchInput!
	): result
	discountCodesMutationAddEligibleProduct(input: products_DiscountCodeProductsUpsertInput): products_Result
	discountCodesMutationApplyCode(input: products_DiscountCodeApplyInput): products_Result
	discountCodesMutationBatch(batch: products_GenericDiscountCode3BatchInput): products_Result
	discountCodesMutationCreate(create: products_DiscountCodeUpsertInput): products_ResultOfCreatedStatus
	discountCodesMutationDelete(delete: products_DiscountCodeUpsertInput): products_Result
	discountCodesMutationRemoveEligibleProduct(input: products_DiscountCodeProductsUpsertInput): products_Result
	discountCodesMutationUpdate(update: products_DiscountCodeUpsertInput): products_Result
	endorsementCancel(endorsementId: String, policyId: String): policies_Result
	endorsementSubmit(endorsementId: String, policyId: String): policies_Result
	entityFactBatch(
		"the entity identifier"
		entityId: String!,
		"the fact input"
		input: factBatchInput!
	): result
	escalateClaim(claim: EscalateClaimInput!): ID!
	evaluateScript(
		"Evaluate a script"
		input: evaluateScriptInput!
	): evaluateScriptResult
	expireInvestigation(investigationId: ID!): ClaimInvestigationStatus!
	exportProduct(productId: products_ProductIdInput!): products_FilePathResult
	faceRecognition(
		"the bytes of the image"
		image: [Byte]!
	): faceRecognitionResult
	"Use when login forgot password"
	forgotPassword(
		"Input to ask for username or account email."
		forgotPasswordInput: forgotPasswordInput!,
		"the tenant identifier"
		tenantId: String!
	): result
	"generate an auth token for client apps to perform kyc processes (eg. upload images) in eKYC provider"
	generateKycAuthToken(
		"The individual identifier"
		individualId: String!,
		"Input for getting an auth token from a eKYC provider"
		input: generateKycAuthTokenInput!
	): stringResult
	generatePoliciesFromProposal(
		"the case identitifier"
		caseId: String!,
		"boolean flag to whether copy case fields to policy or not"
		copyCaseFieldsToExtraFields: Boolean,
		"the status to set on the generated policies"
		policyStatus: String,
		"the proposal identitifier"
		proposalId: String!,
		"boolean flag to whether store clauses templates inside the policy or not"
		storeClausesByValue: Boolean,
		"boolean flag to whether store jackets with clauses including templates inside policy or not"
		storeJacketsByValue: Boolean
	): createdStatusResult
	"Generate a Sharable Url"
	generateSharableUrl(
		"The bucket identifier"
		bucketName: String,
		"The amount of time until the file expires in hours"
		expiresIn: String,
		"The folder key"
		key: String!
	): createdStatusResult
	guaranteeOfPaymentMutationUpdateGOPBatch(input: claims_UpdateGuaranteeOfPaymentBatchCommandInput): claims_ResultOfCreatedStatus
	importProduct(fromFilePath: String!): products_Result
	"individual's disability batch"
	individualDisabilityBatch(
		"The individual identifier"
		individualId: String!,
		"The input"
		input: individualDisabilityBatchInput!
	): result
	individualMutationAddIntegration(command: users_IntegrationCommandInput): users_Result
	individualMutationCreateKycCheck(command: users_CreateKycCheckCommandInput): users_ResultOfString
	individualMutationUpdateKycStatus(command: users_UpdateKycStatusCommandInput): users_Result
	individualMutationUpdateRemarkProductIdAfterPolicyIssuance(individualId: String): users_ResultOfIntegration
	initializeFileSystem(
		"the fileSystem config input"
		fileSystemInput: initializeTenantFileSystemInput,
		"the tenant identifier"
		tenantId: String!
	): result
	"Initializes a policy"
	initializePolicy(
		"the policy input"
		policy: initializePolicyInput
	): policyResult
	initializeTenant(
		"the admin settings"
		adminSettings: createAdminInput!,
		"apps"
		apps: [createAppInput],
		"the encryption config input"
		encryptionsInput: initializeTenantEncryptionsInput,
		"the fileSystem config input"
		fileSystemInput: initializeTenantFileSystemInput,
		"tenant hosts"
		hosts: [String!],
		"logins"
		logins: [createLoginInput],
		"the notification config input"
		notificationsInput: initializeTenantNotificationsInput,
		"the policy config input"
		policiesInput: initializeTenantPoliciesInput,
		"the product config input"
		productsInput: initializeTenantProductConfigInput,
		"the tenant identifier"
		tenantId: String!,
		"the transaction config input"
		transactionsInput: initializeTenantTransactionsInput
	): result
	initializeTenantAuth(
		"the tenant identifier"
		tenantId: String!
	): result
	"Initialize a transaction"
	initializeTransaction(
		"The initialize transaction input"
		input: initializeTransactionInput!
	): transactionRedirectionResult
	"Invite an entity by creating a login and associate it to the entity from the specified entityId."
	inviteEntityToLogin(
		"The client identifier"
		clientId: String!,
		"The invite entity input"
		input: inviteEntityInput!,
		permissioningToken: String
	): createdStatusResult
	"Invite an individual and creates a login and minimal permissions for him."
	inviteIndividual(
		"The client identifier"
		clientId: String!,
		"The invite individual input"
		inviteIndividualInput: inviteIndividualInput!
	): login
	"Invite an internal and creates a login and minimal permissions for him."
	inviteInternal(
		"The client identifier"
		clientId: String!,
		"The invite internal input"
		inviteInternalInput: inviteInternalInput!
	): login
	issueCertificate(input: policies_IssueCertificateInput!): policies_IssueCertificatePayload!
	"issues a policy"
	issuePolicy(
		"If set to true, validation of collateral from transactions will be ignored"
		ignoreCollateralValidation: Boolean,
		"If set to true, policy validation will be ignored"
		ignoreIssuanceValidation: Boolean,
		"If set to true, this will just change the status to 'ISSUED'"
		isManual: Boolean,
		"Will set this policy number if the issuer allows it."
		issuerNumber: String,
		"Will set this policy original issuer number if policy is renewal, will be ignored in other case"
		originalIssuerNumber: String,
		"the policy identifier"
		policyId: String!,
		"If set to true, no notifications will be sent to the end customer of the policy"
		skipSendNotification: Boolean,
		"Value to override status of issued policy. Default is 'ISSUED'"
		status: String
	): policyResult
	"issues a proposal"
	issueProposal(
		"the identifier of the case"
		caseId: String!,
		"the identifier of the proposal"
		proposalId: String!
	): result
	"adds connection to a chat room"
	joinChatRoom(
		"the id of the SignalR connection"
		connectionId: String!,
		"the id of the chat room"
		id: String,
		"the name of the chat room"
		topicName: String,
		"the name of the user"
		userName: String!
	): result
	"removes connection from a chat room"
	leaveChatRoom(
		"the id of the SignalR connection"
		connectionId: String!,
		"the id of the chat room"
		id: String,
		"the name of the chat room"
		topicName: String
	): result
	"Locks file"
	lockFile(
		"The bucket identifier"
		bucketName: String,
		"File keys to be locked"
		keys: [String]!
	): result
	"Locks node for editing."
	lockNode(expiresInSeconds: Int, nodeId: ID!): LockStatus!
	loginMutationDeactivate(loginId: String): auth_Result
	loginMutationReactivate(loginId: String): auth_Result
	manualPaymentCreate(command: billing_CreateManualPaymentChannelCommandInput!): UUID!
	manualPaymentDelete(paymentChannelId: String!): billing_ManualPaymentChannel!
	manualPaymentRecievePayment(amount: Decimal!, attachmentPath: String, billingInfoId: String!): String!
	manualPaymentUpdate(command: billing_UpdateManualPaymentChannelCommandInput!, paymentChannelId: String!): billing_ManualPaymentChannel!
	markEvidenceAsReceived(input: MarkEvidenceAsReceivedInput!): ClaimInvestigationModel!
	metadataMutationMigrate(input: filesystem_MetadataMigrationCommandInput): filesystem_Result
	migrateInsurers(
		"the insurers input"
		input: migrateInsurersInput,
		"the tenant Identitfier"
		tenantId: String
	): result
	migrateL10ns(
		"the migrate l10n input"
		input: [upsertL10nInput]!,
		"the tenant identifier"
		tenantId: String
	): result
	migratePricings(
		"the productIds input"
		input: migratePricingsInput,
		"the tenant identifier"
		tenantId: String
	): result
	migrateProducts(
		"the productIds input"
		input: migrateProductsInput,
		"the tenant identifier"
		tenantId: String
	): result
	"Moves a file"
	moveFile(
		"The bucket identifier"
		bucketName: String,
		"The old file key"
		key: String!,
		"The new file key"
		newKey: String!
	): result
	"""

	Move a node to a desired position
	If position argument contains no values or is missed at all,
	node will be detached from its parent
	"""
	moveNode(nodeId: ID!, position: NodePositionInput!): ID
	negotiatedItemMutationBatch(batch: users_GenericNegotiatedItem3BatchInput): users_Result
	negotiatedItemMutationCreate(create: users_NegotiatedItemUpsertInput): users_ResultOfCreatedStatus
	negotiatedItemMutationDelete(delete: users_NegotiatedItemUpsertInput): users_Result
	negotiatedItemMutationUpdate(update: users_NegotiatedItemUpsertInput): users_Result
	networksMutationBatch(batch: users_GenericNetwork3BatchInput): users_Result
	networksMutationCreate(create: users_NetworkUpsertInput): users_ResultOfCreatedStatus
	networksMutationDelete(delete: users_NetworkUpsertInput): users_Result
	networksMutationUpdate(update: users_NetworkUpsertInput): users_Result
	notificationMutationResend(resendNotificationCommand: notifications_ResendNotificationCommandInput): notifications_Result
	offerMutationRecordQuote(caseId: String, command: cases_RecordQuoteCommandInput, tenantId: String): cases_Result
	openInvestigation(escalatedClaimId: ID!): ClaimInvestigationModel!
	organizationNegotiatedItemMutationBatch(batch: users_GenericOrganizationNegotiatedItem3BatchInput): users_Result
	organizationNegotiatedItemMutationCreate(create: users_OrganizationNegotiatedItemUpsertInput): users_ResultOfCreatedStatus
	organizationNegotiatedItemMutationDelete(delete: users_OrganizationNegotiatedItemUpsertInput): users_Result
	organizationNegotiatedItemMutationUpdate(update: users_OrganizationNegotiatedItemUpsertInput): users_Result
	organizationProviderTierMutationBatch(batch: users_GenericOrganizationProviderTier3BatchInput): users_Result
	organizationProviderTierMutationCreate(create: users_OrganizationProviderTierUpsertInput): users_ResultOfCreatedStatus
	organizationProviderTierMutationDelete(delete: users_OrganizationProviderTierUpsertInput): users_Result
	organizationProviderTierMutationUpdate(update: users_OrganizationProviderTierUpsertInput): users_Result
	"Removes a serviceItemAgreedFee to a panelProviderTier"
	panelProviderTierServiceItemAgreedFeeBatch(
		"The serviceItemAgreedFeeBatch input"
		input: serviceItemAgreedFeeBatchInput!,
		"The panelProviderTier identifier"
		panelProviderTierId: String!
	): result
	partyMutationRegisterParty(registerPartyCommandInput: requestManager_RegisterPartyCommandInput!): requestManager_WorkflowRunStateOfPartyState!
	paymentProviderMutationCreateCheckoutSession(command: transactions_CreateCheckoutSessionRequestInput, providerId: String): transactions_ResultOfCreateCheckoutSessionResponse
	paymentProviderMutationPaymentProviderSubscription(command: transactions_ProviderSubscriptionCommandInput, providerId: String): transactions_ResultOfCreatedStatus
	policies_AttachedCommandPermissionMutationCreate(command: policies_CreateAttachedRuleCommandOfpoliciesAttachedCommandPermissionInput): policies_ResultOfCreatedStatus
	policies_AttachedCommandPermissionMutationDelete(command: policies_DeleteAttachedRuleCommandOfpoliciesAttachedCommandPermissionInput): policies_Result
	policies_AttachedCommandPermissionMutationUpdate(command: policies_UpdateAttachedRuleCommandOfpoliciesAttachedCommandPermissionInput): policies_Result
	policies_AttachedExternalApiCallMutationCreate(command: policies_CreateAttachedRuleCommandOfpoliciesAttachedExternalApiCallInput): policies_ResultOfCreatedStatus
	policies_AttachedExternalApiCallMutationDelete(command: policies_DeleteAttachedRuleCommandOfpoliciesAttachedExternalApiCallInput): policies_Result
	policies_AttachedExternalApiCallMutationUpdate(command: policies_UpdateAttachedRuleCommandOfpoliciesAttachedExternalApiCallInput): policies_Result
	policies_AttachedFilterMutationCreate(command: policies_CreateAttachedRuleCommandOfpoliciesAttachedFilterInput): policies_ResultOfCreatedStatus
	policies_AttachedFilterMutationDelete(command: policies_DeleteAttachedRuleCommandOfpoliciesAttachedFilterInput): policies_Result
	policies_AttachedFilterMutationUpdate(command: policies_UpdateAttachedRuleCommandOfpoliciesAttachedFilterInput): policies_Result
	policies_AttachedObjectValidationMutationCreate(command: policies_CreateAttachedRuleCommandOfpoliciesAttachedObjectValidationInput): policies_ResultOfCreatedStatus
	policies_AttachedObjectValidationMutationDelete(command: policies_DeleteAttachedRuleCommandOfpoliciesAttachedObjectValidationInput): policies_Result
	policies_AttachedObjectValidationMutationUpdate(command: policies_UpdateAttachedRuleCommandOfpoliciesAttachedObjectValidationInput): policies_Result
	policies_AttachedPostHandleValidationMutationCreate(command: policies_CreateAttachedRuleCommandOfpoliciesAttachedPostHandleValidationInput): policies_ResultOfCreatedStatus
	policies_AttachedPostHandleValidationMutationDelete(command: policies_DeleteAttachedRuleCommandOfpoliciesAttachedPostHandleValidationInput): policies_Result
	policies_AttachedPostHandleValidationMutationUpdate(command: policies_UpdateAttachedRuleCommandOfpoliciesAttachedPostHandleValidationInput): policies_Result
	policyAddClausesFromProposal(
		"the case identifier"
		caseId: String!,
		"endorsement id if needed"
		endorsementId: String,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	policyAddJacketsFromProposal(
		"the case identifier"
		caseId: String!,
		"endorsement id if needed"
		endorsementId: String,
		"the policy identifier"
		policyId: String!
	): result
	policyClauseBatch(
		"endorsement id"
		endorsementId: String,
		"the clause input"
		input: policyClauseBatchInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	policyClausesClone(endorsementId: String, policyIdFrom: String, policyIdTo: String): policies_ResultOfCreatedStatus
	policyFactBatch(
		"the fact input"
		input: factBatchInput!,
		"the policy identifier"
		policyId: String!
	): result
	policyJacketBatch(
		"endorsement id"
		endorsementId: String,
		"the jacket input"
		input: policyJacketInstanceBatchInput!,
		"the policy identifier"
		policyId: String!
	): result
	policyJacketsClone(endorsementId: String, policyIdFrom: String, policyIdTo: String): policies_Result
	policyMemberActivityMutationDeletePolicyMemberActivity(command: policies_DeletePolicyMemberActivityCommandInput): policies_ResultOfInt64
	"Assigns internal codes for active policy members and it's dependents, supposed to be invoked during policy issuance process"
	policyMembersAssignInternalCodes(
		"endorsement id"
		endorsementId: String,
		"Policy id"
		policyId: String!,
		"Use this parameter to regenerate internal codes for some specific policy members, e.g. if we have duplications"
		policyMembersIds: [String]
	): result
	policyMembersBatch(
		"endorsement id"
		endorsementId: String,
		"the batch input"
		input: policyMembersBatchInput!,
		"the policy identifier"
		policyId: String!
	): result
	"Sets memebr movement log item marked as already printed"
	policyMembersMovementLogItemMarkPrinted(
		"itemId to be marked as already printed"
		itemId: String!
	): result
	policyMutationImport(importPoliciesCommand: policies_ImportPoliciesCommandInput): policies_Result
	policyMutationReplayEvents(command: policies_ReplayEventsInput): policies_Result
	policyNextDebitNoteNumber(
		"the policy identifier"
		policyId: String!,
		"Transaction we issue the debit note number for"
		transactionId: String
	): policyDebitNoteNumber
	policyNextMemberMovementNumber(
		"the policy identifier"
		policyId: String!
	): policyMemberMovementNumber
	policyNumbersMutationValidate(input: policies_PolicyNumberValidateInput): policies_Result
	policyReferenceGenerationMutationsCreateConfig(input: policies_ReferenceGeneratorConfigInput): policies_Result
	policyReferenceGenerationMutationsDeleteConfig(type: String): policies_Result
	policyUnderwritingMutationAddRemark(command: policies_AddPolicyUnderwritingRemarkCommandInput): policies_Result
	policyUnderwritingMutationBatch(command: policies_BatchPolicyUnderwritingCommandInput): policies_Result
	policyUnderwritingMutationDeleteRemark(command: policies_DeletePolicyUnderwritingRemarkCommandInput): policies_Result
	policyUnderwritingMutationUpdateRemark(command: policies_UpdatePolicyUnderwritingRemarkCommandInput): policies_Result
	preExistingConditionMutationBatch(batch: claims_GenericPreExistingCondition3BatchInput): claims_Result
	preExistingConditionMutationCreate(create: claims_PreExistingConditionUpsertInput): claims_ResultOfCreatedStatus
	preExistingConditionMutationDelete(delete: claims_PreExistingConditionUpsertInput): claims_Result
	preExistingConditionMutationUpdate(update: claims_PreExistingConditionUpsertInput): claims_Result
	"Processing of a payment. Can be tied to a policy or be a standalone payment"
	processTransaction(
		"the input to process the transaction"
		input: processTransactionInput!,
		"the identifier of the transaction to process"
		transactionId: String!,
		"signifies whether to try to issue the policy attached to the transaction"
		tryIssue: Boolean
	): policyResult
	"Adds and update benefits in batch for a custom product"
	productBenefitBatch(
		"the benefits identifier"
		input: benefitBatchInput!,
		"the product identifier"
		productId: productIdInput!
	): result!
	"add and update multiple facts of a custom product"
	productFactBatch(
		"the facts identifier"
		input: factBatchInput!,
		"the product identifier"
		productId: productIdInput!
	): result
	"""

	Store any ES2015-compliant class. It will be imported to all JS logic executed for this tenant.
	For later usage in nodes and formulas
	Code should contain one JS class
	Any change to a class equals to a full re-define, e.g. no support for versioning, field change tracking, validation, and so on.
	"""
	productbuilder_defineOpenType(type: ExpressionInput!): ID!
	proposalOfferClauseBatch(
		"the case identifier"
		caseId: String!,
		"the clause input"
		input: clauseBatchInput!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	proposalOfferClausesClone(
		"Endorsement id"
		endorsementId: String,
		"Offer caseTo copy clauses caseFrom"
		from: offerIdInput!,
		"Offer caseTo copy clauses caseTo"
		to: offerIdInput!
	): result
	proposalOfferFactBatch(
		"the case identifier"
		caseId: String!,
		"the fact input"
		input: factBatchInput!,
		"the case identifier"
		offerId: String!,
		"the case identifier"
		proposalId: String!
	): result
	proposalOfferJacketBatch(
		"the case identifier"
		caseId: String!,
		"the jacket input"
		input: jacketInstanceBatchInput!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	proposalOfferJacketsClone(
		"Endorsement id"
		endorsementId: String,
		"Offer caseTo copy jackets from"
		from: offerIdInput!,
		"Offer caseTo copy jackets to"
		to: offerIdInput!
	): result
	reasonAdd(input: policies_ReasonAddInput!): policies_ResultOfCreatedStatus!
	reasonArchive(input: policies_ReasonArchiveInput!): policies_Result!
	reasonRemove(input: policies_ReasonDeleteInput!): policies_Result!
	reasonUpdate(input: policies_ReasonUpdateInput!): policies_Result!
	"Rebuild all component modules for a tenant into the fileSystem"
	rebuildComponentModules: result
	recordInvestigationFindings(input: ClaimInvestigationFindingsInput!): ClaimInvestigationModel!
	"""

	Resolve a tree node field and make it reproducible in the future, e.g.
	Copy the whole tree, save the input, save the resolution chain
	"""
	recordResolution(fieldRef: String!, input: ExpressionInput, nodeId: ID!): RecordResolutionResult!
	"Refunds a transaction"
	refundTransaction(
		"The refund transaction input"
		input: refundInput!,
		"The identifier of the transaction to refund"
		transactionId: String!
	): result
	"Register new individual with an associated login."
	registerIndividual(
		"The client identifier"
		clientId: String!,
		"The register individual input"
		registerIndividualInput: registerIndividualInput!,
		"The tenant identifier"
		tenantId: String!
	): createdStatusResult
	registerPolicyMemberUpload(input: policies_RegisterPolicyMemberUploadInput!): policies_RegisterPolicyMemberUploadPayload!
	"rejects a claim"
	rejectClaim(
		"the claim identifier"
		claimId: ID!,
		"the claim rejectionCodes"
		codes: [String],
		"the reasons for claim rejection"
		reasons: [rejectionReasonInput],
		"the remarks for claim rejection"
		remarks: String
	): result
	rejectConsentRequest(input: RejectConsentRequestInput!): ClaimInvestigationModel!
	rejectEndorsement(
		"the endorsement identifier"
		endorsementId: String!,
		"the policy identifier"
		policyId: String!
	): result
	"rejects a guarantee of payment"
	rejectGOP(
		"the guarantee of payment identifier"
		gopId: ID!,
		"The input"
		input: rejectGOPInput
	): result
	"rejects a proposal"
	rejectProposal(
		"the identifier of the case"
		caseId: String!,
		"the rejection codes for the proposal"
		codes: [String],
		"the identifier of the proposal"
		proposalId: String!,
		"the rejection remarks"
		remarks: String
	): result
	"Rejects the quote"
	rejectQuote(
		"the rejection codes"
		codes: [String],
		"the identifier of the policy"
		policyId: String!,
		"the remarks for the rejection"
		remarks: String
	): result
	"Removes an address of a entity"
	removeAddress(
		"The entity identifier"
		entityId: String!,
		"The address identifier"
		id: String!
	): result
	removeAssociatedContractFromPolicy(
		"the associated contract identifier"
		associatedContractId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the policy identifier"
		policyId: String!
	): result
	removeAssociatedContractFromProposalOffer(
		"the associated contract identifier"
		associatedContractId: String!,
		"the case identifier"
		caseId: String!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	"removes a beneficiaryEligibility"
	removeBeneficiaryEligibility(
		"the beneficiary eligibility id"
		beneficiaryEligibilityId: String!,
		"the identifier of the policy"
		policyId: String!
	): result
	"removes a beneficiaryEligibility from a case"
	removeBeneficiaryEligibilityFromCase(
		"the beneficiary eligibility id"
		beneficiaryEligibilityId: String!,
		"the identifier of the case"
		caseId: String!
	): result
	"Removes a benefit from a custom product"
	removeBenefit(
		"the option key identifier"
		optionKey: String,
		"the product identifier"
		productId: productIdInput!,
		"the benefit identifier"
		typeId: String!
	): result!
	"Removes a benefit from a claim"
	removeBenefitFromClaim(
		"The benefit claim id"
		benefitClaimId: String!,
		"the claim identifier"
		claimId: ID!
	): result
	"removes a benefitOption"
	removeBenefitOption(
		"the identifier of the offer"
		offerId: String,
		"the identifier of the policy"
		policyId: String!,
		"the identifier of the benefitOption"
		typeId: String!
	): result
	removeBenefitOptionFromPolicy(
		"the endorsement identifier"
		endorsementId: String,
		"the policy identifier"
		policyId: String!,
		"the benefitOption identifier"
		typeId: String!
	): createdStatusResult
	"removes a benefitOption"
	removeBenefitOptionFromProposalOffer(
		"the case identifier"
		caseId: String!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!,
		"the identifier of the benefitOption"
		typeId: String!
	): result
	"removes an attachment from a claim"
	removeClaimAttachment(
		"The claim identifier"
		claimId: ID!,
		"The attachment path"
		path: String!
	): result
	"removes a note from a claim"
	removeClaimNote(
		"The claim identifier"
		claimId: ID!,
		"The note identifier"
		noteId: ID!
	): result
	"Removes claim report"
	removeClaimReport(
		"CreatedAt greater than or equal"
		createdAt_gte: DateTime!
	): result
	removeClauseFromPolicy(
		"the clause identifier"
		clauseId: String!,
		"the case identifier"
		policyId: String!
	): result
	removeClauseFromProposalOffer(
		"the case identifier"
		caseId: String!,
		"the clause identifier"
		clauseId: String!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	removeCommandFromEndorsement(
		"the command identifier"
		commandId: String!,
		"the endorsement identifier"
		endorsementId: String!,
		"the policy identifier"
		policyId: String!
	): result
	"Removes a commission split from a policy"
	removeCommission(
		"the commission id"
		id: String!,
		"The policy id"
		policyId: String!
	): result
	"Removes a commission split from an offer"
	removeCommissionFromOffer(
		"The case id"
		caseId: String!,
		"the commission id"
		id: String!,
		"The offer id"
		offerId: String!,
		"The proposal id"
		proposalId: String!
	): result
	"Removes a contact of an entity"
	removeContact(
		"The entity identifier"
		entityId: String!,
		"The contact identifier"
		id: String!
	): result
	removeContractHolderAddress(
		"the address identifier"
		addressId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	removeContractHolderContact(
		"the contact identifier"
		contactId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	removeContractHolderFact(
		"the endorsement identifier"
		endorsementId: String,
		"the fact identifier"
		factId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	removeContractHolderIdentity(
		"the endorsement identifier"
		endorsementId: String,
		"the identity identifier"
		identityId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	removeContractInsured(
		"the endorsement identifier"
		endorsementId: String,
		"the entityId identifier"
		entityId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	removeContractInsuredAddress(
		"the address identifier"
		addressId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the entity identifier"
		entityId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	removeContractInsuredContact(
		"the contact identifier"
		contactId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the entity identifier"
		entityId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	removeContractInsuredFact(
		"the endorsement identifier"
		endorsementId: String,
		"the entity identifier"
		entityId: String!,
		"the fact identifier"
		factId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	removeContractInsuredIdentity(
		"the endorsement identifier"
		endorsementId: String,
		"the entity identifier"
		entityId: String!,
		"the identity identifier"
		identityId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	removeDataSchemaFromProductType(
		"Remove dataSchema from productType"
		input: removeDataSchemaFromProductTypeInput!
	): result
	"Remove a diagnosis from a disability"
	removeDiagnosisFromDisability(
		"The diagnosis identifier"
		diagnosisId: String!,
		"The disability identifier"
		disabilityId: String!
	): result
	"Remove a disability from an individual"
	removeDisabilityFromIndividual(
		"The disability identifier"
		disabilityId: String!,
		"The individual identifier"
		individualId: String!
	): result
	removeDiscount(
		"the discount identifier"
		discountId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"removes a discount from an offer"
	removeDiscountFromOffer(
		"the identifier of the discount"
		discountId: String!,
		"the identifier of the policy"
		offerId: String,
		"the identifier of the policy"
		policyId: String!
	): result
	removeDiscountFromProposalOffer(
		"the case identifier"
		caseId: String!,
		"the discount identifier"
		discountId: String!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	"Removes a dynamic value from a pdf template"
	removeDynamicValueFromTemplate(
		"The template id to update"
		templateId: String!,
		"The value to remove"
		valueId: String!
	): result
	"Removes an email attachment template"
	removeEmailAttachmentReference(
		"The attachment reference id to remove"
		attachmentReferenceId: String!,
		"the template to remove an attachment reference from"
		templateId: String!
	): result
	"Removes an email attachment template"
	removeEmailAttachmentTemplate(attachmentTemplateId: String!, templateId: String!): result
	removeEndorsement(
		"the endorsement identifier"
		endorsementId: String!,
		"the policy identifier"
		policyId: String!
	): result
	"removes an attachment."
	removeEntityAttachment(
		"The bucket identifier"
		bucketName: String,
		"The entity identifier"
		entityId: String!,
		"The attachment identifier"
		fileName: String!
	): result
	"removes an entity from a notification subscription"
	removeEntityFromNotificationSubscription(
		"the id of the entity to add"
		entityId: String!,
		"the id of the subscription"
		id: String,
		"the topic name of the subscription"
		topicName: String
	): result
	"removes a note."
	removeEntityNote(
		"The entity identifier"
		entityId: String!,
		"The note identifier"
		id: String!
	): result
	"remove exclusion from policy"
	removeExclusionFromOffer(
		"the identifier of the exclusion"
		exclusionId: String!,
		"the identifier of the policy"
		offerId: String,
		"the identifier of the policy"
		policyId: String!
	): result
	removeExclusionFromPolicy(
		"the loading identifier"
		exclusionId: String!,
		"the policy identifier"
		policyId: String!
	): result
	removeExclusionFromProposalOffer(
		"the case identifier"
		caseId: String!,
		"the loading identifier"
		exclusionId: String!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	"removes a fact of an entity"
	removeFact(
		"The entity identifier"
		entityId: String!,
		"The contact identifier"
		id: String!
	): result
	removeFactFromBinder(
		"the binder identifier"
		binderId: String!,
		"the fact identifier"
		factId: String!
	): result
	removeFactFromCase(
		"the case identifier"
		caseId: String!,
		"the fact identifier"
		factId: String!
	): result
	"Removes a fact from a claim"
	removeFactFromClaim(
		"the claim identifier"
		claimId: ID!,
		"The fact id"
		factId: String!
	): result
	"Removes a fact from a custom product"
	removeFactFromProduct(
		"the fact identifier"
		id: String!,
		"the product identifier"
		productId: productIdInput!
	): result!
	removeFactFromProposalOffer(
		"the case identifier"
		caseId: String!,
		"the fact identifier"
		factId: String!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	"removes a fact from a transaction"
	removeFactFromTransaction(
		"the identifier of the fact"
		factId: String!,
		"the identifier of the transaction"
		transactionId: String!
	): result
	"Removes a login to a permission group"
	removeFromPermissionGroup(
		"The login id of the the login whose permission will be removed."
		loginId: String!,
		"The id of the permission group."
		permissionGroupId: String!
	): result
	"removes an attachment from a guarantee of payment"
	removeGOPAttachment(
		"The gop identifier"
		gopId: ID!,
		"The attachment path"
		path: String!
	): result
	removeGOPFromClaim(
		"the claim identifier"
		claimId: String!,
		"the gop identifier"
		gopId: String!
	): result
	"removes a note from a guarantee of payment"
	removeGOPNote(
		"The gop identifier"
		gopId: ID!,
		"The note identifier"
		noteId: ID!
	): result
	"removes a host from the tenant settings"
	removeHostFromTenantSettings(
		"the host to remove"
		host: String
	): result
	"Removes an identity of the authenticated login"
	removeIdentity(
		"The entity identifier"
		entityId: String!,
		"The identity identifier"
		id: String!
	): result
	"Removes a login to inherit from from a login"
	removeInheritedLoginFromLogin(
		"The login id of the the login whose permission will be removed."
		loginId: String!,
		"The id of the login to stop inherit from."
		loginIdToStopInheritFrom: String!
	): result
	"Removes a login to inherited from from a permission group."
	removeInheritedLoginFromPermissionGroup(
		"The id of the permission group."
		id: String!,
		"The id of the login to stop inherit from."
		loginId: String!
	): result
	"removes an input from a function template"
	removeInputFromFunctionTemplate(
		"The input identifier"
		inputId: String!,
		"the template identifier"
		templateId: String!
	): result
	"removes an insured from a policy"
	removeInsured(
		"the identitifier of the entity to add"
		entityId: String!,
		"the identitifier of the policy to update"
		policyId: String!
	): result
	"Removes an internal review from a custom product"
	removeInternalReviewFromProduct(
		"the internal review identifier"
		id: String!,
		"the product identifier"
		productId: productIdInput!
	): result!
	removeJacketFromPolicy(
		"endorsement Id"
		endorsementId: String,
		"the jacket instance identifier"
		jacketInstanceId: String!,
		"policy Id"
		policyId: String!
	): result
	removeJacketFromProposalOffer(
		"the case identifier"
		caseId: String!,
		"the jacket instance identifier"
		jacketInstanceId: String!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	"Removes a lesson completion from a course progression"
	removeLessonCompletionFromCourseProgression(
		"The course progression identifier"
		courseProgressionId: String!,
		"The lesson completion id"
		lessonCompletionId: String!
	): result
	"Removes a lesson from a course"
	removeLessonFromSection(
		"the course identifier"
		courseId: String!,
		"The lesson id"
		lessonId: String!,
		"the section identifier"
		sectionId: String!
	): result
	"Removes an item from a lesson"
	removeLessonItem(
		"the course identifier"
		courseId: String!,
		"the item identifier"
		itemId: String!,
		"the lesson id"
		lessonId: String!
	): result
	"removes a link"
	removeLink(
		"the link identifier"
		id: String,
		"The link input"
		linkInput: removeLinkInput
	): result
	removeLoading(
		"the endorsement identifier"
		endorsementId: String,
		"the loading identifier"
		loadingId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"removes a loading from an offer"
	removeLoadingFromOffer(
		"the identifier of the loading"
		loadingId: String!,
		"the identifier of the policy"
		offerId: String,
		"the identifier of the policy"
		policyId: String!
	): result
	removeLoadingFromProposalOffer(
		"the case identifier"
		caseId: String!,
		"the loading identifier"
		loadingId: String!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	"Removes metadata to file"
	removeMetadata(
		"The bucket identifier"
		bucketName: String,
		"The file key"
		key: String!,
		"Metadata Keys"
		metadataKeys: [String]!
	): result
	"Removes an address of the authenticated entity"
	removeMyAddress(
		"The address identifier"
		id: String!
	): result
	"removes an attachment."
	removeMyAttachment(
		"The bucket identifier"
		bucketName: String,
		"The attachment identifier"
		fileName: String!
	): result
	"Removes a contact of the authenticated login"
	removeMyContact(
		"The contact identifier"
		id: String!
	): result
	"Remove a fact of an authenticated login"
	removeMyFact(
		"The contact identifier"
		id: String!
	): result
	"Removes an identity of the authenticated login"
	removeMyIdentity(
		"The identity identifier"
		id: String!
	): result
	removeNodeField(fieldRef: String!, nodeId: ID!): ID!
	removeNoteFromCase(
		"the case identifier"
		caseId: String!,
		"the note identifier"
		noteId: String!
	): result
	"removes an offer from a quote"
	removeOffer(
		"the identifier of the offer"
		offerId: String!,
		"the identifier of the policy"
		policyId: String
	): result
	"removes an offer of a proposal"
	removeOfferFromProposal(
		"the identifier of the case"
		caseId: String!,
		"the identifier of the offer"
		offerId: String!,
		"the identifier of the proposal"
		proposalId: String!
	): result
	removeOfferFromSubscription(
		"the payment config to use"
		offerId: String!,
		"the payment config to use"
		subscriptionId: String!
	): result
	"Removes an option from a lesson item"
	removeOptionFromLessonItem(
		"the course identifier"
		courseId: String!,
		"the item identifier"
		itemId: String!,
		"the lesson id"
		lessonId: String!,
		"the option identifier"
		optionId: String!
	): result
	removeOtherContractHolder(
		"the endorsement identifier"
		endorsementId: String,
		"the entityId identifier"
		entityId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	removeOtherContractHolderAddress(
		"the address identifier"
		addressId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the entity identifier"
		entityId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	removeOtherContractHolderContact(
		"the contact identifier"
		contactId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the entity identifier"
		entityId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	removeOtherContractHolderFact(
		"the endorsement identifier"
		endorsementId: String,
		"the entity identifier"
		entityId: String!,
		"the fact identifier"
		factId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	removeOtherContractHolderIdentity(
		"the endorsement identifier"
		endorsementId: String,
		"the entity identifier"
		entityId: String!,
		"the identity identifier"
		identityId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"removes a holder from other holders"
	removeOtherHolder(
		"the identitifier of the entity to add"
		entityId: String!,
		"the identitifier of the policy to update"
		policyId: String!
	): result
	"removes an output from a function template"
	removeOutputFromFunctionTemplate(
		"The input identifier"
		outputId: String!,
		"the template identifier"
		templateId: String!
	): result
	"Removes a page object with settings from a wkhtmltopdf template"
	removePageObjectFromWkhtmltopdfTemplate(
		"The page object id to remove"
		pageObjectId: String!,
		"The template id"
		templateId: String!
	): result
	"removes an attachment from a panel provider tier"
	removePanelProviderTierAttachment(
		"The panelProviderTier identifier"
		panelProviderTierId: String!,
		"The attachment path"
		path: String!
	): result
	"Removes a serviceItemAgreedFee to a panelProviderTier"
	removePanelProviderTierServiceItemAgreedFee(
		"The panelProviderTier identifier"
		panelProviderTierId: String!,
		"The serviceItemAgreedFee identifier"
		serviceItemAgreedFeeId: String!
	): result
	"removes a payment info of a policy"
	removePaymentInfo(
		"The policy identifier"
		id: String!,
		"The payment identifier"
		paymentId: String!
	): result
	"removes a payment info of a policy"
	removePaymentInfoFromCase(
		"The case identifier"
		caseId: String!,
		"The payment identifier"
		paymentInfoId: String!
	): result
	"Removes a drawing from a pdf template"
	removePdfDrawing(
		"The drawing to remove"
		drawingId: String!,
		"The template id to update"
		templateId: String!
	): result
	"Removes a permission to a permission group."
	removePermissionFromPermissionGroup(
		"The id of the permission group."
		id: String!,
		"The id of the permission to be removed."
		permissionId: String!,
		"The id of the target to be added. Put 'all' to add all targets."
		targetId: String!
	): result
	"Removes a permission group to a permission group."
	removePermissionGroupFromPermissionGroup(
		"The id of the permission group."
		id: String!,
		"The id of the permission group to be removed."
		permissionGroupId: String!
	): result
	"removes an attachment."
	removePolicyAttachment(
		"The bucket identifier"
		bucketName: String,
		"The attachment identifier"
		fileName: String!,
		"The policy identifier"
		policyId: String!
	): result
	removePolicyFact(
		"the endorsement identifier"
		endorsementId: String,
		"the fact identifier"
		factId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"removes a note."
	removePolicyNote(
		"The note identifier"
		id: String!,
		"The policy identifier"
		policyId: String!
	): result
	"removes a pricing option from a product"
	removePricingOption(
		"the pricing option"
		pricingOptionId: String!,
		"the product identifier"
		productId: productIdInput!
	): result!
	"removes a proposal"
	removeProposal(
		"the identifier of the case"
		caseId: String!,
		"the identifier of the proposal"
		proposalId: String!
	): result
	"Removes a score"
	removeScore(
		"the identifier of the review"
		reviewId: String!,
		"The identifier of the score"
		scoreId: String!
	): result
	removeScriptFromProduct(
		"Remove script from product"
		input: removeScriptFromProductInput!
	): result
	"Removes a section from a course"
	removeSectionFromCourse(
		"the course identifier"
		courseId: String!,
		"The lesson id"
		sectionId: String!
	): result
	removeStakeholderFromCase(
		"the case identifier"
		caseId: String!,
		"the stakeholder identifier"
		stakeholderId: String!
	): result
	removeStakeholderFromClaim(
		"the claim identifier"
		claimId: String!,
		"the stakeholder identifier"
		stakeholderId: String!
	): result
	removeStakeholderFromPolicy(
		"the policy identifier"
		policyId: String!,
		"the stakeholder identifier"
		stakeholderId: String!
	): result
	removeStakeholderFromProposal(
		"the case identifier"
		caseId: String!,
		"the proposal identifier"
		proposalId: String!,
		"the stakeholder identifier"
		stakeholderId: String!
	): result
	removeStakeholderFromProposalOffer(
		"the case identifier"
		caseId: String!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!,
		"the stakeholder identifier"
		stakeholderId: String!
	): result
	removeStakeholderFromTransaction(
		"the stakeholder identifier"
		stakeholderId: String!,
		"the transaction identifier"
		transactionId: String!
	): result
	"Removes a tag from a notification subscription"
	removeTagFromNotificationSubscription(
		"the notification subscription identifier"
		id: String!,
		"the tag identifier"
		tagId: String!
	): result!
	removeTagFromPolicy(
		"the policy identifier"
		policyId: String!,
		"the tag identifier"
		tagId: String!
	): result
	"Removes a tag from a custom product"
	removeTagFromProduct(
		"the tag identifier"
		id: String!,
		"the product identifier"
		productId: productIdInput!
	): result!
	removeTargetedPermissionSchemaFromLogin(
		"Remove permissionSchema from login"
		input: removeTargetedPermissionSchemaFromLoginInput!
	): result
	"Removes a targetted permission from a login"
	removeTargettedPermission(
		"the login id of the the login whose permission will be deleted."
		loginId: String!,
		"the type of the permission"
		type: String!,
		"the value of the target"
		value: String!
	): result
	"Removes a targetted permission from a login"
	removeTargettedPermissions(
		"the targetted permissions to be removed"
		inputs: [removeTargettedPermissionInput]!,
		"The login id of the the login whose permissions will be removed."
		loginId: String!
	): result
	removeTemplateRelationshipFromProduct(
		"Remove template relationship from product"
		input: removeTemplateRelationshipFromProductInput!
	): result
	"removes an attachment from a transaction"
	removeTransactionAttachment(
		"The attachment path"
		path: String!,
		"The transaction identifier"
		transactionId: String!
	): result
	"removes a note from a transaction"
	removeTransactionNote(
		"The note identifier"
		noteId: ID!,
		"The transaction identifier"
		transactionId: ID!
	): result
	removeUiSchemaFromProductSchema(productSchemaId: ID!, uiSchemaName: String!): Result!
	removeUiSchemaToDataSchema(
		"Remove uiSchema from dataSchema"
		input: removeUiSchemaFromDataSchemaInput!
	): result
	"Removes an underwriting variable"
	removeUnderwritingVariable(
		"the product identifier"
		productId: productIdInput!,
		"the variable identifier"
		variableId: String!
	): result!
	"Renames an entity attachment"
	renameEntityAttachment(
		"The entity identifier"
		entityId: String!,
		"The attachment identifier"
		fileName: String!,
		"The new filename to rename to"
		newFileName: String!
	): result @deprecated(reason: "use moveFile")
	"Renames an policy attachment"
	renamePolicyAttachment(
		"The attachment identifier"
		fileName: String!,
		"The new filename to rename to"
		newFileName: String!,
		"The policy identifier"
		policyId: String!
	): result @deprecated(reason: "use moveFile")
	"renews a proposal"
	renewProposal(
		"the case identifier"
		caseId: String!,
		"the input"
		input: renewProposalInput!
	): createdStatusResult
	"Resend confirmation email to a login"
	resendConfirmationEmail(
		"The url to be used to process the confirmation code"
		callbackUrl: String,
		"The client identifier"
		clientId: String!,
		"The login which email needs to be confirmed."
		loginId: String!,
		"Send a notification part of confirming email"
		sendNotificationInput: sendNotificationInput
	): result
	resendNotificationPolicyIssuedMutationResendNotificationPolicyIssued(resendNotificationPolicyIssuedCommand: policies_ResendNotificationPolicyIssuedCommandInput): policies_Result
	resendPolicyToIssuerMutationResendPolicyToIssuer(resendToIssuerCommand: policies_ResendToIssuerCommandInput): policies_Result
	"Can be used after inviting a login or after a login used forgotPassword. Use the code to reset the password"
	resetPassword(
		"the code verifying the login"
		code: String!,
		"the login id of the the login whose permission will be deleted."
		loginId: String!,
		"the new password"
		password: String!,
		"Send a notification part of confirming email"
		sendNotificationInput: sendNotificationInput,
		"the tenant identifier"
		tenantId: String!
	): result
	reverseClaim(
		"claim to reverse"
		claimId: String!,
		"reversal input"
		input: reverseClaimInput!
	): result
	"Review a policy request"
	reviewPolicyUpdateRequest(
		"The input to review the request"
		input: requestPolicyReviewInput!,
		"The policy id update request to review"
		policyId: String!,
		"The request id to review"
		requestId: String!
	): result @deprecated(reason: "Use `acceptEndorsement` / `rejectEndorsement` instead.")
	sSOConfigsMutationAddSSOConfig(input: auth_SSOConfigInput): auth_Result
	sSOConfigsMutationRemoveSSOConfig(id: String): auth_Result
	sbusMutationBatch(batch: products_GenericSbu3BatchInput): products_Result
	sbusMutationCreate(create: products_SbuUpsertInput): products_ResultOfCreatedStatus
	sbusMutationDelete(delete: products_SbuUpsertInput): products_Result
	sbusMutationUpdate(update: products_SbuUpsertInput): products_Result
	"Sends a OTP code by phone"
	sendCode(
		"The targetted client id"
		clientId: String,
		"The targetted login id"
		loginId: String,
		"The purpose"
		purpose: String,
		"Optional template id to use"
		templateId: String,
		"The targetted tenant id"
		tenantId: String
	): result
	sendConsentRequest(input: SendConsentRequestInput!): ConsentRequestModel
	sendConsentRequestReminder(input: SendConsentRequestReminderInput!): ClaimInvestigationModel!
	sendEvidenceRequest(input: SendEvidenceRequestInput!): ClaimInvestigationModel!
	sendEvidenceRequestReminder(input: SendEvidenceRequestReminderInput!): ClaimInvestigationModel!
	"Sends a notification on multiple channels"
	sendNotification(
		"The user response token provided by the reCAPTCHA client-side integration on your site"
		captchaResponseToken: String,
		"The notification input"
		input: sendNotificationInput!,
		"The user's IP address."
		remoteIp: String
	): result
	serviceRatesMutationBatch(batch: users_GenericServiceRate3BatchInput): users_Result
	serviceRatesMutationCreate(create: users_ServiceRateCreateInput): users_ResultOfCreatedStatus
	serviceRatesMutationDelete(delete: users_ServiceRateDeleteInput): users_Result
	serviceRatesMutationUpdate(update: users_ServiceRateUpdateInput): users_Result
	servicingAgentChangeLogMutationBatch(batch: users_GenericServicingAgentChangeLog3BatchInput): users_Result
	servicingAgentChangeLogMutationCreate(create: users_ServicingAgentChangeLogUpsertInput): users_ResultOfCreatedStatus
	servicingAgentChangeLogMutationDelete(delete: users_ServicingAgentChangeLogUpsertInput): users_Result
	servicingAgentChangeLogMutationUpdate(update: users_ServicingAgentChangeLogUpsertInput): users_Result
	"Set the ACL of a file"
	setFileAcl(
		"The bucket identifier"
		bucketName: String,
		"Is the file going to be public"
		isPublic: Boolean!,
		"The folder key"
		key: String!
	): result
	subscriptionDiscountMutationRemove(command: transactions_RemoveSubscriptionDiscountCommandInput): transactions_Result
	subscriptionDiscountMutationUpsert(command: transactions_UpsertSubscriptionDiscountCommandInput): transactions_Result
	transactionsMutationBatch(command: transactions_BatchTransactionsCommandInput): transactions_ResultOfCreatedStatus
	"transfers permissions from one login to another"
	transferPermissions(
		"The identifier of the login to transfer from"
		sourceId: String!,
		"The identifier of the login to transfer to"
		targetId: String!,
		"permissions to delegate"
		targettedPermissionsToTransfer: [addTargettedPermissionInput]!
	): result
	"treatment Batch"
	treatmentBatch(
		"The input"
		input: treatmentBatchInput!
	): result
	"trigger a function for the issuer of this policy"
	triggerIssuerFunction(
		"The input for the function in json format"
		inputJsonString: String,
		"The policy identifier"
		policyId: String!,
		"The policy identifier"
		purpose: String!
	): result
	triggerJobSchedule(
		"Name of job schedule to trigger"
		jobScheduleName: String!
	): result
	"Try to issue Policy if the conditions to issue the policy are reached"
	tryIssuePolicy(
		"The id of the policy to be issued"
		policyId: String!
	): policyResult
	"Unassigns a login from a permission group"
	unassignPermissionGroup(
		"the identifier of the login to unassign the permission group from"
		loginId: String!,
		"the identitifer of the permission group to unassign"
		permissionGroupId: String!
	): result
	"Unlocks file"
	unlockFile(
		"The bucket identifier"
		bucketName: String,
		"File keys to be unlocked"
		keys: [String]!
	): result
	"Unlocks node."
	unlockNode(nodeId: ID!): LockStatus!
	"updates an achievement"
	updateAchievement(
		"the achievement identifier"
		id: String!,
		"The input"
		input: updateAchievementInput!
	): result
	"updates an achievement type"
	updateAchievementType(
		"the achievement type identifier"
		id: String!,
		"The input"
		input: updateAchievementTypeInput!
	): result
	"Adds an address to a entity"
	updateAddress(
		"The entity identifier"
		entityId: String!,
		"The update address input"
		updateAddressInput: updateAddressInput!
	): result
	"Updates an existing app."
	updateApp(
		"The app identifier"
		appId: String!,
		"The app to be created."
		input: updateAppInput!
	): result
	"Updates a beneficiary eligibility"
	updateBeneficiaryEligibility(
		"the identifier of the beneficiaryEligibility"
		beneficiaryEligibilityId: String!,
		"the information of the  beneficiary eligibility to update"
		beneficiaryEligibilityInput: beneficiaryEligibilityInput!,
		"the identifier of the policy"
		policyId: String!
	): result
	"Updates a beneficiary eligibility of a case"
	updateBeneficiaryEligibilityOfCase(
		"the identifier of the beneficiaryEligibility"
		beneficiaryEligibilityId: String!,
		"the identifier of the case"
		caseId: String!,
		"the information of the  beneficiary eligibility to update"
		input: beneficiaryEligibilityInput!
	): result
	updateBenefit(
		"the benefit input"
		input: updateBenefitInput!,
		"the benefit optionKey identifier"
		optionKey: String,
		"the product identifier"
		productId: productIdInput!,
		"the benefit identifier"
		typeId: String!
	): result!
	"Updates a benefit of a claim"
	updateBenefitClaim(
		"The benefit claim id"
		benefitClaimId: String!,
		"the claim identifier"
		claimId: ID!,
		"The input"
		input: updateBenefitClaimInput!
	): result
	"Modifies a benefitdefinition"
	updateBenefitDefinition(
		"the modified benefitDefinition"
		input: updateBenefitDefinitionInput!
	): result
	"Modifies a benefitdefinitionType"
	updateBenefitDefinitionType(
		"the modified benefitDefinitionType"
		input: updateBenefitDefinitionTypeInput!
	): result
	"Updates a binder"
	updateBinder(
		"The binder identifier"
		binderId: ID!,
		"The input"
		input: binderInput!
	): result
	"updates a case"
	updateCase(
		"the case identifier"
		id: String!,
		"the updated case"
		input: updateCaseInput!
	): result
	"Updates a claim"
	updateClaim(
		"the claim identifier"
		claimId: ID!,
		"The input"
		input: updateClaimInput!
	): result
	"update a claim fact"
	updateClaimFact(
		"the claim identifier"
		claimId: ID!,
		"The fact id"
		factId: String!,
		"The input"
		input: updateFactInput!
	): result
	"Updates a note of a claim"
	updateClaimNote(
		"The claim identifier"
		claimId: ID!,
		"The update note input"
		input: updateNoteInput!
	): result
	"Updates a clauseHtml template"
	updateClauseHtmlTemplate(
		"The input"
		input: updateClauseHtmlTemplateInput!,
		"The template id to update"
		templateId: String!
	): result
	updateClauseOfPolicy(
		"the clause identifier"
		clauseId: String!,
		"the clause input"
		input: updateClauseInput!,
		"the case identifier"
		policyId: String!
	): result
	updateClauseOfProposalOffer(
		"the case identifier"
		caseId: String!,
		"the clause identifier"
		clauseId: String!,
		"the clause input"
		input: updateClauseInput!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	"Updates a policy commission split"
	updateCommission(
		"the commission id"
		id: String!,
		"The commission input"
		input: commissionInput!,
		"The policy id"
		policyId: String!
	): result
	"Updates an offer commission split"
	updateCommissionOfOffer(
		"The case id"
		caseId: String!,
		"the commission id"
		id: String!,
		"The commission input"
		input: commissionInput!,
		"The offer id"
		offerId: String!,
		"The proposal id"
		proposalId: String!
	): result
	"Updates a company"
	updateCompany(
		"The company identifier"
		id: String!,
		"The update company input"
		updateCompanyInput: updateCompanyInput!
	): result
	"Updates a component"
	updateComponent(
		"The component's id"
		id: String!,
		"The input"
		input: updateComponentInput!
	): result
	"Updates a contact detail to a entity"
	updateContact(
		"The entity identifier"
		entityId: String!,
		"The update contact input"
		updateContactInput: updateContactInput!
	): result
	updateContractHolderAddress(
		"the address identifier"
		addressId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the clause input"
		input: updateAddressInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"updates a contract holder that is a company"
	updateContractHolderCompany(
		"the company input"
		input: updateCompanyInput!,
		"the identifier of the policy to update"
		policyId: String!
	): result
	updateContractHolderContact(
		"the contact identifier"
		contactId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the clause input"
		input: updateContactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	updateContractHolderFact(
		"the endorsement identifier"
		endorsementId: String,
		"the fact identifier"
		factId: String!,
		"the fact input"
		input: updateFactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	updateContractHolderIdentity(
		"the endorsement identifier"
		endorsementId: String,
		"the identity identifier"
		identityId: String!,
		"the clause input"
		input: updateIdentityInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"updates a contract holder that is an individual"
	updateContractHolderIndividual(
		"the individual input"
		input: updateIndividualInput!,
		"the identifier of the policy to update"
		policyId: String!
	): result
	updateContractInsured(
		"the company input"
		companyInput: updateContractCompanyInput,
		"the endorsement identifier"
		endorsementId: String,
		"the entity identifier"
		entityId: String!,
		"the individual input"
		individualInput: updateContractIndividualInput,
		"the object input"
		objectInput: updateContractObjectInput,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	updateContractInsuredAddress(
		"the address identifier"
		addressId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the clause input"
		input: updateAddressInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"updates a contractInsured of an issued policy who is a company"
	updateContractInsuredCompany(
		"the identitifer of the contractInsured"
		entityId: String!,
		"the update contract insured input"
		input: updateCompanyInput!,
		"the identitifier of the policy to update"
		policyId: String!
	): result
	updateContractInsuredContact(
		"the contact identifier"
		contactId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the clause input"
		input: updateContactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	updateContractInsuredFact(
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the fact identifier"
		factId: String!,
		"the fact input"
		input: updateFactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	updateContractInsuredIdentity(
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the identity identifier"
		identityId: String!,
		"the clause input"
		input: updateIdentityInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"updates a contractInsured of an issued policy who is an individual"
	updateContractInsuredIndividual(
		"the identitifer of the contractInsured"
		entityId: String!,
		"the update contract insured input"
		input: updateIndividualInput!,
		"the identitifier of the policy to update"
		policyId: String!
	): result
	"updates a contractInsured of an issued policy that is an object"
	updateContractInsuredObject(
		"the identitifer of the contractInsured"
		entityId: String!,
		"the update contract insured object input"
		input: updateObjectInput!,
		"the identitifier of the policy to update"
		policyId: String!
	): result
	"updates a course"
	updateCourse(
		"the course identifier"
		id: String!,
		"the updated course"
		input: updateCourseInput!
	): result
	"updates a progression"
	updateCourseProgression(
		"the course progression identifier"
		id: String!,
		"the updated progression"
		input: updateCourseProgressionInput!
	): result
	"Modifies a dataSchema"
	updateDataSchema(
		"the modified dataSchema"
		input: updateDataSchemaInput!
	): result
	"Updates a diagnosis"
	updateDiagnosis(
		"The diagnosis identifier"
		diagnosisId: String!,
		"The input"
		input: diagnosisInput!
	): result
	"Updates a disability"
	updateDisability(
		"The disability identifier"
		disabilityId: String!,
		"The input"
		input: disabilityInput!
	): result
	updateDiscount(
		"the discount identifier"
		discountId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the discount input"
		input: updateDiscountOfOfferInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"updates a discount of an offer"
	updateDiscountOfOffer(
		"the identifier of the discount"
		discountId: String!,
		"the discount to be added"
		input: updateDiscountOfOfferInput!,
		"the identifier of the policy"
		offerId: String,
		"the identifier of the policy"
		policyId: String!
	): result
	updateDiscountOfProposalOffer(
		"the csae identifier"
		caseId: String!,
		"the discount identifier"
		discountId: String!,
		"the discount"
		input: updateDiscountOfOfferInput!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	"Updates a dynamic template"
	updateDynamicTemplate(
		"The input"
		input: updateDynamicTemplateInput!,
		"The template id to update"
		templateId: String!
	): result
	"Updates a dynamic value of a dynamic template"
	updateDynamicValueOfTemplate(
		"The input"
		input: updateDynamicValueOfTemplateInput!,
		"The template id to update"
		templateId: String!,
		"The value to update"
		valueId: String!
	): result
	"Updates an email attachment template"
	updateEmailAttachmentReference(
		"The attachment reference id on which to update"
		attachmentReferenceId: String!,
		"The input"
		input: updateEmailAttachmentReferenceInput!,
		"The email template id on which to update the attachment reference"
		templateId: String!
	): result
	"Updates an email attachment template"
	updateEmailAttachmentTemplate(
		"The input"
		input: updateEmailAttachmentTemplateInput!,
		"The email template id on which to update the attachment template"
		templateId: String!
	): result
	"Updates a email MJML template"
	updateEmailMjmlTemplate(
		"The input"
		input: updateEmailMjmlTemplateInput!,
		"The template id to update"
		templateId: String!
	): result
	updateEndorsement(
		"the endorsement identifier"
		endorsementId: String!,
		"Update endorsement input"
		input: updateEndorsementInput!,
		"the policy identifier"
		policyId: String!
	): result
	"Updates a note of a entity"
	updateEntityNote(
		"The entity identifier"
		entityId: String!,
		"The update note input"
		updateNoteInput: updateNoteInput!
	): result
	"Expired password update flow"
	updateExpiredPassword(
		"Input to change the password"
		changePasswordInput: changeExpiredPasswordInput!,
		"target tenant id"
		tenantId: String!
	): result
	"Updates a fact of a entity"
	updateFact(
		"The entity identifier"
		entityId: String!,
		"The update fact input"
		updateFactInput: updateFactInput!
	): result
	updateFactOfBinder(
		"the binder identifier"
		binderId: String!,
		"the fact identifier"
		factId: String!,
		"the updated fact"
		input: updateFactInput!
	): result
	updateFactOfCase(
		"the case identifier"
		caseId: String!,
		"the fact identifier"
		factId: String!,
		"the updated fact"
		input: updateFactInput!
	): result
	"update a fact of a custom product"
	updateFactOfProduct(
		"the fact identifier"
		input: updateFactInput!,
		"the product identifier"
		productId: productIdInput!
	): result
	updateFactOfProposalOffer(
		"the case identifier"
		caseId: String!,
		"the fact identifier"
		factId: String!,
		"the clause input"
		input: updateFactInput!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	"updates a fileSystemConfig"
	updateFileSystemConfig(
		"the identifier of the config"
		id: String!,
		"the config input"
		input: updateFileSystemConfigInput!
	): result
	"updates a function template"
	updateFunctionTemplate(
		"the template identifier"
		id: String!,
		"The input"
		input: updateFunctionTemplateInput!
	): result
	"Updates a guarantee of payment"
	updateGOP(
		"the guarantee of payment identifier"
		gopId: ID!,
		"The input"
		input: updateGOPInput!
	): result
	"Updates a note of a guarantee of payment"
	updateGOPNote(
		"The gop identifier"
		gopId: ID!,
		"The update note input"
		input: updateNoteInput!
	): result
	"Updates an identity from the entity"
	updateIdentity(
		"The entity identifier"
		entityId: String!,
		"The update identity input"
		updateIdentityInput: updateIdentityInput!
	): result
	"Updates a individual"
	updateIndividual(
		"The individual identifier"
		id: String!,
		"The update individual input"
		updateIndividualInput: updateIndividualInput!
	): result
	"updates an input of a function template"
	updateInputOfFunctionTemplate(
		"The input"
		input: functionInputInput!,
		"the input identifier"
		inputId: String!,
		"the template identifier"
		templateId: String!
	): result
	"Updates an internal"
	updateInternal(
		"The internal identifier"
		id: String!,
		"The update internal input"
		updateInternalInput: updateInternalInput!
	): result
	"update the content of an internal review of a custom product"
	updateInternalReviewOfProduct(
		"the review identifier"
		input: updateInternalReviewInput!,
		"the product identifier"
		productId: productIdInput!
	): result
	"Updates a jacket"
	updateJacket(
		"The input"
		input: updateJacketInput!,
		"the jacket identifier"
		jacketId: String!
	): result
	"updates a lesson completion of a course progression"
	updateLessonCompletionOfCourseProgression(
		"The course progression identifier"
		courseProgressionId: String!,
		"The input"
		input: updateLessonCompletionInput!,
		"The lesson completion identifier"
		lessonCompletionId: String!
	): result
	"updates an item of a lesson"
	updateLessonItem(
		"the course identifier"
		courseId: String!,
		"The input"
		input: updateLessonItemInput!,
		"the item identifier"
		itemId: String!,
		"the lesson identifier"
		lessonId: String!
	): result
	"updates a lesson"
	updateLessonOfSection(
		"the course identifier"
		courseId: String!,
		"the updated lesson"
		input: updateLessonOfSectionInput!,
		"the lesson identifier"
		lessonId: String!,
		"the section identifier"
		sectionId: String!
	): result
	updateLoading(
		"the endorsement identifier"
		endorsementId: String,
		"the loading input"
		input: loadingInput!,
		"the loading identifier"
		loadingId: String!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"updates a loading of an offer"
	updateLoadingOfOffer(
		"the loading to be added"
		input: loadingInput!,
		"the identifier of the loading"
		loadingId: String!,
		"the identifier of the policy"
		offerId: String,
		"the identifier of the policy"
		policyId: String!
	): result
	updateLoadingOfProposalOffer(
		"the csae identifier"
		caseId: String!,
		"the loading"
		input: loadingInput!,
		"the loading identifier"
		loadingId: String!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	"Updates the email for specified login"
	updateLoginCredentials(
		"The new email"
		email: String,
		"The loginId which credentials should be updated"
		loginId: String!,
		"The new username"
		username: String
	): result
	"updates a users lockout end date"
	updateLoginLockoutEndDate(
		"the login identifier"
		dateTime: DateTimeOffset,
		"the login identifier"
		loginId: String!
	): result!
	"Updates the authenticated individual"
	updateMeAsIndividual(
		"The update individual input"
		updateIndividualInput: updateIndividualInput!
	): result
	"Updates the authenticated internal"
	updateMeAsInternal(
		"The update individual input"
		updateInternalInput: updateInternalInput!
	): result
	"Adds an address to an authenticated login"
	updateMyAddress(
		"The update address input"
		updateAddressInput: updateAddressInput!
	): result
	"Updates a contact detail to an authenticated contact"
	updateMyContact(
		"The update contact input"
		updateContactInput: updateContactInput!
	): result
	"Updates the email"
	updateMyEmail(
		"The emailr"
		email: String!
	): result
	"Updates a fact of an authenticated login"
	updateMyFact(
		"The update fact input"
		updateFactInput: updateFactInput!
	): result
	"Updates an identity from the authenticated login"
	updateMyIdentity(
		"The update identity input"
		updateIdentityInput: updateIdentityInput!
	): result
	"Updates the login phone number"
	updateMyTelephoneNumber(
		"The telephone number"
		telephoneNumber: String!
	): result
	updateNoteOfCase(
		"the case identifier"
		caseId: String!,
		"the note to be updated"
		input: updateNoteInput!,
		"the note identifier"
		noteId: String!
	): result
	"Update the status of a notification"
	updateNotificationStatus(
		"The notification identifier"
		notificationId: String!,
		"The new status of the notification"
		status: String!
	): result
	"Updates a notification template"
	updateNotificationTemplate(
		"The input"
		input: updateNotificationTemplateInput!,
		"The template id to update"
		templateId: String!
	): result
	"Updates an object"
	updateObject(
		"The object identifier"
		id: String!,
		"The update object input"
		updateObjectInput: updateObjectInput!
	): result
	"updates an offer of a quote"
	updateOffer(
		"the identifier of the offer"
		offerId: String!,
		"the identifier of the policy"
		policyId: String,
		"the information of the offer to update"
		updateOfferInput: updateOfferInput!
	): result
	"updates an offer to a proposal"
	updateOfferOfProposal(
		"the identifier of the case"
		caseId: String!,
		"the identifier of the offer"
		offerId: String!,
		"the identifier of the proposal"
		proposalId: String!,
		"the information of the offer to update"
		updateOfferInput: updateOfferInput!
	): result
	updateOfferOfSubscription(
		"the update offer input"
		input: updateOfferInput!,
		"the payment config to use"
		offerId: String!,
		"the payment config to use"
		subscriptionId: String!
	): result
	"updates an optino of a lesson item"
	updateOptionOfLessonItem(
		"the course identifier"
		courseId: String!,
		"The input"
		input: updateOptionOfLessonItemInput!,
		"the item identifier"
		itemId: String!,
		"the lesson identifier"
		lessonId: String!,
		"the option identifier"
		optionId: String!
	): result
	"Updates an organization"
	updateOrganization(
		"The organization identifier"
		id: String!,
		"The update organization input"
		updateOrganizationInput: updateOrganizationInput!
	): result
	updateOtherContractHolder(
		"the company input"
		companyInput: updateContractCompanyInput,
		"the endorsement identifier"
		endorsementId: String,
		"the entity identifier"
		entityId: String!,
		"the individual input"
		individualInput: updateContractIndividualInput,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	updateOtherContractHolderAddress(
		"the address identifier"
		addressId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the clause input"
		input: updateAddressInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	updateOtherContractHolderContact(
		"the contact identifier"
		contactId: String!,
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the clause input"
		input: updateContactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	updateOtherContractHolderFact(
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the fact identifier"
		factId: String!,
		"the fact input"
		input: updateFactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	updateOtherContractHolderIdentity(
		"the endorsement identifier"
		endorsementId: String,
		"the insured identifier"
		entityId: String!,
		"the identity identifier"
		identityId: String!,
		"the clause input"
		input: updateIdentityInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"updates an output of a function template"
	updateOutputOfFunctionTemplate(
		"The input"
		input: functionInputInput!,
		"the output identifier"
		outputId: String!,
		"the template identifier"
		templateId: String!
	): result
	"Updates a page object with settings of a wkhtmltopdf template"
	updatePageObjectOfWkhtmltopdfTemplate(
		"The input"
		input: updatePageObjectOfWkhtmltopdfTemplateInput!,
		"The template id"
		templateId: String!
	): result
	"Modifies a PanelProviderTier"
	updatePanelProviderTier(
		"the modified PanelProviderTier"
		input: updatePanelProviderTierInput!,
		"the panel provider tier identifier"
		panelProviderTierId: String!
	): result
	updatePasswordValidatorsMutationCreatePasswordValidators(updatePasswordValidatorsCommand: auth_UpdatePasswordValidatorsCommandInput): auth_ResultOfCreatedStatus
	updatePasswordValidatorsMutationUpdatePasswordValidators(updatePasswordValidatorsCommand: auth_UpdatePasswordValidatorsCommandInput): auth_Result
	"updates a payment info of a policy"
	updatePaymentInfo(
		"The policy identifier"
		id: String!,
		"The payment identifier"
		paymentId: String!,
		"The payment info input"
		updateIssuedPaymentInput: paymentInfosToUpdate!
	): result
	"updates a payment info of a policy"
	updatePaymentInfoOfCase(
		"The case identifier"
		caseId: String!,
		"The payment info input"
		input: paymentInfosToUpdate!,
		"The payment identifier"
		paymentInfoId: String!
	): result
	"Updates a drawing of a pdf template"
	updatePdfDrawing(
		"The drawing to update"
		drawingId: String!,
		"The input"
		input: updatePdfDrawingInput!,
		"The template id to update"
		templateId: String!
	): result
	"Updates a PDF Drawing template"
	updatePdfDrawingTemplate(
		"The input"
		input: createPdfDrawingTemplateInput!,
		"The template id to update"
		templateId: String!
	): result
	"Updates an existing targeted permisstion schema for fields."
	updatePermissionSchema(
		"The permission schema to be updated."
		input: updatePermissionSchemaInput!
	): result
	"creates pricing rules to a plan"
	updatePlanPriceLogic(
		"the price logic input"
		input: priceLogicInput!,
		"the plan identifier"
		productId: productIdInput!
	): result!
	"updates a policy"
	updatePolicy(
		"the identitifier of the policy to update"
		policyId: String!,
		"the update policy input"
		updatedPolicy: updatePolicyInput!
	): result @deprecated(reason: "use `updatePolicy2` instead")
	updatePolicy2(
		"the endorsement identifier"
		endorsementId: String,
		"the policy input"
		input: updatePolicyInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	updatePolicyFact(
		"the endorsement identifier"
		endorsementId: String,
		"the fact identifier"
		factId: String!,
		"the fact input"
		input: updateFactInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	updatePolicyMember(input: policies_UpdatePolicyMemberInput!): policies_UpdatePolicyMemberPayload!
	"Updates a note of a policy"
	updatePolicyNote(
		"The user identifier"
		policyId: String!,
		"The update note input"
		updateNoteInput: updateNoteInput!
	): result
	updatePolicyProduct(
		"the endorsement identifier"
		endorsementId: String,
		"a productId input"
		input: productIdInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"creates pricing rules to a product"
	updatePriceLogic(
		"the price logic input"
		input: priceLogicInput!,
		"the product identifier"
		productId: productIdInput!
	): result!
	"updates a pricing option of a product"
	updatePricingOption(
		"the pricing option"
		input: updatePricingOptionInput!,
		"the pricing option identifier"
		pricingOptionId: String!,
		"the product identifier"
		productId: productIdInput!
	): result!
	"Modifies a product"
	updateProduct(
		"the modified product"
		input: updateProductInput,
		"the product identifier"
		productId: productIdInput!
	): product
	"updates a productConfig"
	updateProductConfig(
		"the identifier of the config"
		id: String!,
		"the config input"
		input: updateProductConfigInput!
	): result
	updateProductSchema(id: ID!, input: UpdateProductSchemaInput!): Result!
	"updates a proposal"
	updateProposal(
		"the identifier of the case"
		caseId: String!,
		"the updated proposal"
		input: updateProposalInput!,
		"the identifier of the proposal"
		proposalId: String!
	): result
	"updates an review"
	updateReview(
		"the identifier of the review"
		id: String!,
		"The input"
		input: updateReviewInput!
	): result
	"Updates a score"
	updateScore(
		"The input"
		input: updateScoreInput!,
		"The identifier of the review"
		reviewId: String!,
		"The identifier of the score"
		scoreId: String!
	): result
	"Modifies a script"
	updateScript(
		"the modified script"
		input: updateScriptInput!
	): result
	"Modifies a ServiceItem"
	updateServiceItem(
		"the modified ServiceItem"
		input: updateServiceItemInput!
	): result
	"Modifies a serviceItemAgreedFee"
	updateServiceItemAgreedFee(
		"the modified serviceItemAgreedFee"
		input: updateServiceItemAgreedFeeInput!
	): result
	"Updates a Sms template"
	updateSmsTemplate(
		"The input"
		input: updateSmsTemplateInput!,
		"The template id to update"
		templateId: String!
	): result
	updateStakeholderOfCase(
		"the case identifier"
		caseId: String!,
		"the stakeholder input"
		input: updateStakeholderInput!,
		"the stakeholder identifier"
		stakeholderId: String!
	): result
	updateStakeholderOfClaim(
		"the claim identifier"
		claimId: String!,
		"the stakeholder input"
		input: updateStakeholderInput!,
		"the stakeholder identifier"
		stakeholderId: String!
	): result
	updateStakeholderOfPolicy(
		"the stakeholder input"
		input: updateStakeholderInput!,
		"the policy identifier"
		policyId: String!,
		"the stakeholder identifier"
		stakeholderId: String!
	): result
	updateStakeholderOfProposal(
		"the case identifier"
		caseId: String!,
		"the stakeholder input"
		input: updateStakeholderInput!,
		"the proposal identifier"
		proposalId: String!,
		"the stakeholder identifier"
		stakeholderId: String!
	): result
	updateStakeholderOfProposalOffer(
		"the case identifier"
		caseId: String!,
		"the stakeholder input"
		input: updateStakeholderInput!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!,
		"the stakeholder identifier"
		stakeholderId: String!
	): result
	updateStakeholderOfTransaction(
		"the stakeholder input"
		input: updateStakeholderInput!,
		"the stakeholder identifier"
		stakeholderId: String!,
		"the transaction identifier"
		transactionId: String!
	): result
	updateSubscription(
		"the subscription input"
		input: updateSubscriptionInput!,
		"the payment config to use"
		subscriptionId: String!
	): result
	"Updates a transaction"
	updateTransaction(
		"the update transaction input"
		input: updateTransactionInput!,
		"the identifier of the transaction to update"
		transactionId: String!
	): result
	"Updates a fact of a transaction"
	updateTransactionFact(
		"the identifier of the fact"
		factId: String!,
		"the fact to add"
		input: updateFactInput!,
		"the identifier of the transaction"
		transactionId: String!
	): result
	"Updates a note of a transaction"
	updateTransactionNote(
		"The update note input"
		input: updateNoteInput!,
		"The transaction identifier"
		transactionId: ID!
	): result
	"Updates a treatment"
	updateTreatment(
		"The input"
		input: treatmentInput!,
		"The treatment identifier"
		treatmentId: String!
	): result
	"Modifies a uiSchema"
	updateUiSchema(
		"the modified uiSchema"
		input: updateUiSchemaInput!
	): result
	updateUiSchemaOfProductSchema(input: UpdateUiSchemaInput!, name: String!, productSchemaId: ID!): Result!
	"Adds an underwriting variable"
	updateUnderwritingVariable(
		"The underwriting variable"
		input: addUnderwritingVariableInput!,
		"the product identifier"
		productId: productIdInput!,
		"the variable identifier"
		variableId: String!
	): result!
	updateUserStorageItem(
		"UserStorageItem update input"
		input: userStorageItemUpdateInput
	): result
	"Updates a wkhtmltopdf template"
	updateWkhtmltopdfTemplate(
		"The input"
		input: updateWkhtmltopdfTemplateInput!,
		"The template id to update"
		templateId: String!
	): result
	uploadConsentRequestAttachment(input: UploadConsentRequestAttachmentInput!): ClaimInvestigationModel!
	"updates a benefitOption or inserts it if it does not exist"
	upsertBenefitOption(
		"the information of the  benefit option to update"
		input: benefitOptionInput!,
		"the identifier of the offer"
		offerId: String,
		"the identifier of the policy"
		policyId: String!
	): result
	"batch update benefitOptions or insert them if it does not exist"
	upsertBenefitOptionBatch(
		"the information of the benefit options to upsert"
		input: [benefitOptionInput]!,
		"the identifier of the offer"
		offerId: String,
		"the identifier of the policy"
		policyId: String!
	): result
	upsertBenefitOptionOfPolicy(
		"the endorsement identifier"
		endorsementId: String,
		"the information of the  benefit option to update"
		input: benefitOptionInput!,
		"the policy identifier"
		policyId: String!
	): createdStatusResult
	"updates a benefitOption or inserts it if it does not exist"
	upsertBenefitOptionOfProposalOffer(
		"the case identifier"
		caseId: String!,
		"the information of the  benefit option to update"
		input: benefitOptionInput!,
		"the offer identifier"
		offerId: String!,
		"the proposal identifier"
		proposalId: String!
	): result
	"Creates a cms configuration"
	upsertCmsConfig(
		"The application identifier"
		appId: String!,
		"The cms configuration to create"
		config: cmsConfigInput!
	): result
	"Upserts a l10n"
	upsertL10n(
		"The l10n to upsert"
		l10n: upsertL10nInput
	): result
	users_AttachedCommandPermissionMutationCreate(command: users_CreateAttachedRuleCommandOfusersAttachedCommandPermissionInput): users_ResultOfCreatedStatus
	users_AttachedCommandPermissionMutationDelete(command: users_DeleteAttachedRuleCommandOfusersAttachedCommandPermissionInput): users_Result
	users_AttachedCommandPermissionMutationUpdate(command: users_UpdateAttachedRuleCommandOfusersAttachedCommandPermissionInput): users_Result
	users_AttachedExternalApiCallMutationCreate(command: users_CreateAttachedRuleCommandOfusersAttachedExternalApiCallInput): users_ResultOfCreatedStatus
	users_AttachedExternalApiCallMutationDelete(command: users_DeleteAttachedRuleCommandOfusersAttachedExternalApiCallInput): users_Result
	users_AttachedExternalApiCallMutationUpdate(command: users_UpdateAttachedRuleCommandOfusersAttachedExternalApiCallInput): users_Result
	users_AttachedFilterMutationCreate(command: users_CreateAttachedRuleCommandOfusersAttachedFilterInput): users_ResultOfCreatedStatus
	users_AttachedFilterMutationDelete(command: users_DeleteAttachedRuleCommandOfusersAttachedFilterInput): users_Result
	users_AttachedFilterMutationUpdate(command: users_UpdateAttachedRuleCommandOfusersAttachedFilterInput): users_Result
	users_AttachedObjectValidationMutationCreate(command: users_CreateAttachedRuleCommandOfusersAttachedObjectValidationInput): users_ResultOfCreatedStatus
	users_AttachedObjectValidationMutationDelete(command: users_DeleteAttachedRuleCommandOfusersAttachedObjectValidationInput): users_Result
	users_AttachedObjectValidationMutationUpdate(command: users_UpdateAttachedRuleCommandOfusersAttachedObjectValidationInput): users_Result
	users_AttachedPostHandleValidationMutationCreate(command: users_CreateAttachedRuleCommandOfusersAttachedPostHandleValidationInput): users_ResultOfCreatedStatus
	users_AttachedPostHandleValidationMutationDelete(command: users_DeleteAttachedRuleCommandOfusersAttachedPostHandleValidationInput): users_Result
	users_AttachedPostHandleValidationMutationUpdate(command: users_UpdateAttachedRuleCommandOfusersAttachedPostHandleValidationInput): users_Result
	"Verifies a captcha"
	verifyCaptcha(remoteIp: String, response: String!): result
	"Verifies the OTP code and confirm phone and enables multi factor authentication"
	verifyCode(
		"The OTP code."
		code: String!,
		"The targetted login id"
		loginId: String,
		"The purpose"
		purpose: String,
		"The targetted tenant id"
		tenantId: String
	): result
	"Verifies the OTP code for reset password"
	verifyResetPasswordCode(
		"The OTP code."
		code: String!,
		"The targetted login id"
		loginId: String,
		"The purpose"
		purpose: String,
		"The targetted tenant id"
		tenantId: String
	): result
}

type Node {
	alias: String
	children: [Node!]
	fields: [FieldDescription!]
	fieldsChecksum: String
	id: ID
	lockStatus: LockStatus
	parent: Node
	ref: String
	subtreeChecksum: String
	type: String
}

type NodeReference {
	alias: String
	id: ID
	ref: String
}

type NodeScriptDescription {
	text: String
}

type OpenAddress {
	id: ID
	type: OpenType
}

type OpenAddressDto {
	id: ID!
	type: OpenTypeDto
	version: Int
}

type OpenAddressReadModel {
	id: ID!
	typeName: String!
	typeVersion: Int
	version: Int
}

type OpenType {
	name: String
	version: Int
}

type OpenTypeDto {
	name: String!
	version: Int
}

type OpenTypeReadModel {
	aggregateId: ID
	engine: String
	group: String
	id: String!
	name: String!
	payload: String
	version: Int
}

"A connection to a list of items."
type OpenTypesConnection {
	"A list of edges."
	edges: [OpenTypesEdge!]
	"A flattened list of the nodes."
	nodes: [OpenTypeReadModel!]
	"Information to aid in pagination."
	pageInfo: PageInfo!
}

"An edge in a connection."
type OpenTypesEdge {
	"A cursor for use in pagination."
	cursor: String!
	"The item at the end of the edge."
	node: OpenTypeReadModel!
}

"Information about pagination in a connection."
type PageInfo {
	"When paginating forwards, the cursor to continue."
	endCursor: String
	"Indicates whether more edges exist following the set defined by the clients arguments."
	hasNextPage: Boolean!
	"Indicates whether more edges exist prior the set defined by the clients arguments."
	hasPreviousPage: Boolean!
	"When paginating backwards, the cursor to continue."
	startCursor: String
}

type PolicyMemberUploadPayload {
	policyId: String
	uploadId: String
}

type PricingBillingCycleGraphType {
	billingAmount: Float
	formulaId: String
	name: String
	params: PricingParamsGraphType
	value: String
}

type PricingBillingGraphType {
	billingCycle: PricingBillingCycleGraphType
	premiumBaseFrequency: String
}

type PricingDirectPriceDetailGraphType {
	activeDays: Int
	amount: Float
	nodeId: String
	unit: String
}

type PricingDirectPricesDefinitionGraphType {
	amount: Int
	condition: String
	currency: String
	proRate: Int
	unit: String
}

type PricingInsuredGroupGraphType {
	key: Int
	numberOfInsureds: Int
	planSelected: String
}

type PricingLevyFlatGraphType {
	amount: Float
	currency: String
	unit: String
}

type PricingParamsGraphType {
	rate: Int
}

type PricingPlanGraphType {
	directBandedPremiumNodes: [PricingDirectPriceDetailGraphType]
	directBandedPriceDetails: [PricingDirectPriceDetailGraphType]
	directPriceDetails: [PricingDirectPriceDetailGraphType]
	id: String
	insuredCount: Int
	label: String
	name: String
	nodeName: String
	parentId: String
	totalDirectPrice: Float
	totalPrice: Float
}

type PricingPolicyGraphType {
	agent_Name: String
	benefitCalculationMode: String
	claimSettlementMode: String
	endDate: String
	expectedStartDate: String
	insuredGroups: [PricingInsuredGroupGraphType]
	membersValidation: Boolean
	p400_Agent_Code: String
	p400_Client_Code: String
	policy: PricingPolicyGraphType
	startDate: String
	totalMemberNotApproved: Int
}

type PricingPriceAffectGraphType {
	activeDays: Int
	affected: Boolean
	amount: Float
	id: String
	parentId: String
	stdAmount: Int
	unit: String
}

type PricingPriceDetailGraphType {
	directBandedPremiumNodes: [PricingDirectPriceDetailGraphType]
	directBandedPriceDetails: [PricingDirectPriceDetailGraphType]
	directPriceDetails: [PricingDirectPriceDetailGraphType]
	directPricesDefinition: [PricingDirectPricesDefinitionGraphType]
	id: String
	insuredCount: Int
	label: String
	name: String
	nodeName: String
	parentId: String
	totalDirectPrice: Float
	totalPrice: Float
}

type PricingPricePerInsuredGraphType {
	accurateAmount: Float
	amount: Float
	claimsSettlementMode: String
	createdAt: Date
	createdById: String
	dateOfBirth: String
	effectiveDate: Date
	endDate: String
	endorsementId: String
	fullName: String
	gender: String
	hkid: String
	inherited: Boolean
	internalCode: String
	isNeedManualApproval: Boolean
	isUpdated: Boolean
	memberId: String
	memberType: String
	movementType: String
	passportNo: String
	plan: PricingPlanGraphType
	planId: String
	policy: PricingPolicyGraphType
	policyId: String
	priceAffects: [PricingPriceAffectGraphType]
	relationshipToEmployee: String
	sequenceNo: String
	staffNo: String
	startDate: String
	stdPremium: Int
	underwritingResult: PolicyMemberUnderwritingResult
	validationResult: String
}

type PricingRootGraphType {
	billing: PricingBillingGraphType
	currency: String
	formatedLevyFlat: String
	formatedTotalPremium: String
	formatedTotalPriceAllPlans: String
	id: String
	levy: Float
	levyFlat: PricingLevyFlatGraphType
	levyPercentage: String
	plans: [PricingPlanGraphType]
	priceDetails: [PricingPriceDetailGraphType]
	pricePerInsureds: [PricingPricePerInsuredGraphType]
	summary: PricingSummaryGraphType
	totalInsureds: Int
	totalPremium: PricingTotalPremiumGraphType
	totalPriceAllPlans: PricingTotalPriceAllPlansGraphType
}

type PricingSummaryGraphType {
	billing: PricingBillingGraphType
	levyFlat: PricingLevyFlatGraphType
	totalPremium: PricingTotalPremiumGraphType
	totalPriceAllPlans: PricingTotalPriceAllPlansGraphType
}

type PricingTotalPremiumGraphType {
	amount: Float
	currency: String
	unit: String
}

type PricingTotalPriceAllPlansGraphType {
	amount: Float
	currency: String
	unit: String
}

type ProductSchemaDescription {
	dataSchema: String
	id: ID!
	nodeId: ID!
	uiSchemas: [UiSchema!]
}

type PublicHolidayGraphType {
	countryCode: countryCodeEnumGraphTypeEnum
	date: DateTime
	fixedHoliday: Boolean
	name: String
	type: publicHolidayTypeEnumGraphTypeEnum
}

type Query {
	"Achievement configurations"
	achievementTypes(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"an achievementType search filter"
		where: achievementTypeWhereInput
	): achievementTypes
	"Gets a list of advices"
	advices(
		"The advisor id"
		advisorId: String!,
		"Limit of items to query"
		limit: Int,
		productIds: [productIdInput]!,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A list of dynamic values as input of the advisor"
		values: [keyValueInput]
	): advices
	agentRemindersQuery(where: users_GenericAgentReminderQueryInput): users_GenericAgentReminder8QueryInterface
	aggregateAddresses(
		"Returns the elements in the list that come after the specified cursor."
		after: String,
		"Returns the elements in the list that come before the specified cursor."
		before: String,
		"Returns the first _n_ elements from the list."
		first: Int,
		"Returns the last _n_ elements from the list."
		last: Int,
		order: [HotChocolate_OpenAddressReadModelSortInput!],
		where: HotChocolate_OpenAddressReadModelFilterInput
	): AggregateAddressesConnection
	aggregateCommands(
		"Returns the elements in the list that come after the specified cursor."
		after: String,
		"Returns the elements in the list that come before the specified cursor."
		before: String,
		"Returns the first _n_ elements from the list."
		first: Int,
		"Returns the last _n_ elements from the list."
		last: Int,
		order: [HotChocolate_AggregateDefinedCommandReadModelSortInput!],
		where: HotChocolate_AggregateDefinedCommandReadModelFilterInput
	): AggregateCommandsConnection
	aggregateStateSchemas(
		"Returns the elements in the list that come after the specified cursor."
		after: String,
		"Returns the elements in the list that come before the specified cursor."
		before: String,
		"Returns the first _n_ elements from the list."
		first: Int,
		"Returns the last _n_ elements from the list."
		last: Int,
		order: [HotChocolate_StateDescriptionReadModelSortInput!],
		where: HotChocolate_StateDescriptionReadModelFilterInput
	): AggregateStateSchemasConnection
	agreedFeeGroupsQuery(where: users_GenericAgreedFeeGroupQueryInput): users_GenericAgreedFeeGroup8QueryInterface
	agreedFeesQuery(where: users_GenericAgreedFeeQueryInput): users_GenericAgreedFee8QueryInterface
	appConfigurationQueryAppConfigurationFromUrl(appUrl: String): auth_AppConfiguration
	"Gets a list of apps"
	apps(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A company search filter"
		where: appWhereInput
	): apps!
	authorityLimitsQuery(where: claims_GenericAuthorityLimitQueryInput): claims_GenericAuthorityLimit8QueryInterface
	benefitBalanceQuery(input: claims_BenefitBalanceCalculationInput): claims_ScriptResult
	"Gets the benefits categories of the tenants"
	benefitCategories(
		"The product types"
		productTypes: [String]
	): [benefitCategoriesPerType]
	"Get benefitDefinitionTypes"
	benefitDefinitionTypes(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A benefitDefinitionType search filter"
		where: benefitDefinitionTypeWhereInput
	): benefitDefinitionTypes
	"Get benefitDefinitions"
	benefitDefinitions(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A benefitDefinition search filter"
		where: benefitDefinitionWhereInput
	): benefitDefinitions
	"Gets the benefits infos of the tenants"
	benefitInfos(
		"The client identifier"
		clientId: String,
		"The product types"
		productTypes: [String],
		"The tenant identifier"
		tenantId: String!
	): [benefitInfo]
	"Gets a list of binders"
	binders(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A binder search filter"
		where: binderWhereInput
	): binders
	brokersQuery(where: cases_GenericBrokerQueryInput): cases_GenericBroker8QueryInterface
	"cases"
	cases(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a case search filter"
		where: caseWhere
	): cases
	"casesReport"
	casesReport(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a case search filter"
		where: caseWhere
	): casesReport
	claimDataInsightsQuery(filterInput: claims_ClaimDataInsightFilterInput): claims_ResultOfListOfClaimDataInsight
	"Gets a list of templates for claim facts"
	claimFactTemplates(
		"A list of template ids"
		ids: [String]
	): [factTemplate]
	claimInvestigations(order: [ClaimInvestigationModelSortInput!], skip: Int, take: Int, where: ClaimInvestigationModelFilterInput): ClaimInvestigationModelCollectionSegment
	claimRejectionCodesQuery(where: claims_GenericClaimRejectionCodeQueryInput): claims_GenericClaimRejectionCode8QueryInterface
	claimRejectionReasonsQuery(where: claims_GenericClaimRejectionReasonQueryInput): claims_GenericClaimRejectionReason8QueryInterface
	"Gets claim remarks"
	claimRemarks(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A Remark search filter"
		where: remarkWhere
	): remarks
	"Get claim reports"
	claimReports(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A claim report search filter"
		where: claimReportFilterInput
	): claimReports
	claimRequestApprovalWarningsQuery(input: claims_ClaimIdsInput): claims_ResultOfIEnumerableOfApprovalWarning
	claimRequestReasonsQuery(where: claims_GenericClaimRequestReasonQueryInput): claims_GenericClaimRequestReason8QueryInterface
	"Gets a list of claims"
	claims(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A claim search filter"
		where: claimWhereInput
	): claims
	claims_AttachedCommandPermissionsQuery(queryArguments: claims_GenericClaims_AttachedRuleQueryInput): claims_AttachedRulesQueryInterfaceOfclaimsAttachedCommandPermissionAndclaims_AttachedRuleFilter
	claims_AttachedExternalApiCallsQuery(queryArguments: claims_GenericClaims_AttachedRuleQueryInput): claims_AttachedRulesQueryInterfaceOfclaimsAttachedExternalApiCallAndclaims_AttachedRuleFilter
	claims_AttachedFiltersQuery(queryArguments: claims_GenericClaims_AttachedRuleQueryInput): claims_AttachedRulesQueryInterfaceOfclaimsAttachedFilterAndclaims_AttachedRuleFilter
	claims_AttachedObjectValidationsQuery(queryArguments: claims_GenericClaims_AttachedRuleQueryInput): claims_AttachedRulesQueryInterfaceOfclaimsAttachedObjectValidationAndclaims_AttachedRuleFilter
	claims_AttachedPostHandleValidationsQuery(queryArguments: claims_GenericClaims_AttachedRuleQueryInput): claims_AttachedRulesQueryInterfaceOfclaimsAttachedPostHandleValidationAndclaims_AttachedRuleFilter
	"Get the cms for a particular url"
	cmsConfig(
		"The app url"
		url: String!
	): cmsConfigResult
	"Get all the cms configs"
	cmsConfigs(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A component search filter"
		where: CmsConfigWhereInputGraphType
	): [cmsConfig]
	"Gets a list of companies"
	companies(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a doctor specialty filter"
		specialty: String,
		"A company search filter"
		where: companyWhereInput
	): companies!
	"Get components"
	components(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A component search filter"
		where: componentWhereInput
	): components
	countersQuery(where: cases_GenericCounterQueryInput): cases_GenericCounter8QueryInterface
	"courses"
	courses(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a course search filter"
		where: courseWhereInput
	): courses
	"Get dataSchemas"
	dataSchemas(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A dataSchema search filter"
		where: dataSchemaWhereInput
	): dataSchemas
	"Get diagnoses"
	diagnoses(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A diagnosis search filter"
		where: diagnosisFilterInput
	): diagnoses
	"Get disabilities"
	disabilities(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A disability search filter"
		where: disabilityFilterInput
	): disabilities
	discountCodesQuery(where: products_GenericDiscountCodeQueryInput): products_GenericDiscountCode8QueryInterface
	escalatedClaims(order: [EscalatedClaimModelSortInput!], skip: Int, take: Int, where: EscalatedClaimModelFilterInput): EscalatedClaimModelCollectionSegment
	"Run an expression using any of supported languages"
	evaluate(expression: ExpressionInput!): String!
	"Converts rates"
	exchangeRateConvert(
		"Conversion options"
		options: exchangeRateConversionOptionsInput!,
		"The prices to convert"
		prices: [priceInput]!
	): [price]
	"Export node and all its children"
	exportTree(nodeId: ID!): ExportedTree!
	"Get a list of file bucket"
	fileBuckets(
		"The bucket filter"
		where: bucketWhereInput
	): [buckets]
	"Get a list of files"
	fileListing(
		"The targetted bucket name"
		bucketName: String,
		"used for continuation to get next the batch of records"
		continuationToken: String,
		"filter by file name"
		filename_contains: String,
		"limit the number of files"
		limit: Int,
		"The path prefix"
		prefix: String,
		"skips the N number of files"
		skip: Int,
		"sort by created_date or filename"
		sort: String,
		"if present, will be used to get public files of the specified tenant"
		tenantId: String
	): fileListing
	"Get a list of file system configs"
	fileSystemConfigs(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A file system config search filter"
		where: fileSystemConfigWhere
	): [fileSystemConfig]
	findAggregateDefinedCommands(aggregateType: OpenTypeDtoInput!, commandType: OpenTypeDtoInput): [AggregateDefinedCommandDto!]!
	findAggregateDefinedEvents(aggregateTypeDto: OpenTypeDtoInput!): [AggregateDefinedEventDto!]!
	findAggregateState(aggregateId: ID, aggregateTypeIdFilter: String, aggregateTypeNameFilter: String, version: Int): [AggregateStateDto!]!
	findAggregateTypeStateSchema(typeIdFilter: String): [StateDescriptionDto!]!
	findOpenAddresses(instanceId: ID, typeName: String): [OpenAddressDto!]!
	findOpenTypes(typeIdFilter: String!): [OpenTypeReadModel!]!
	findReadModelHistory(builderTypeIdFilter: String): [ReadModelEventProcessed!]!
	"connected chat room users"
	getUsersInRoom(
		"the name of the chat room"
		id: String,
		"the name of the chat room"
		topicName: String
	): connectedChatUsers
	"Gets a list of GOPs"
	gops(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A GOP search filter"
		where: gopWhereInput
	): guaranteeOfPayments
	"Gets a list of agent code, name, and source for each individual"
	individualAgentCode(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"An individual search filter"
		where: individualWhereInput
	): individualsAgentCode!
	"Gets a list of external individuals"
	individuals(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Check individuals activity based on policies membership"
		checkActivity: Boolean,
		"Limit of items to query"
		limit: Int,
		"filter by policyId"
		policyId: String,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"An individual search filter"
		where: individualWhereInput
	): individuals!
	insuredPersonDetailReports(input: policies_InsuredPersonDetailReportFilterInput): policies_InsuredPersonDetailReportResult
	"Gets the list of insurers for a specific client"
	insurers(
		"The insurerIds"
		ids: [String],
		"product types"
		productTypes: [String],
		"The tenant identifier"
		tenantId: String
	): [insurer]
	"Used for custom integrations with third parties."
	integrate(
		"the command type to execute"
		commandType: String!,
		"the input for the integration"
		inputJson: String
	): stringResult!
	"Gets a list of internal users"
	internals(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"An internal search filter"
		where: internalWhereInput
	): internals!
	issuerProductIdGenerateNext: products_ResultOfString
	"Gets a list of jackets"
	jackets(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A jacket search filter"
		where: jacketWhereInput
	): jackets
	"Get job schedules"
	jobSchedules(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A job schedule search filter"
		where: jobScheduleWhereInput
	): jobSchedules
	"Return node and all its children as a list"
	listNodes(parentNodeId: ID!): [Node!]
	"Get a single login from username"
	login(
		"The username"
		username: String!
	): login
	loginInternalQueryDoesActiveLoginExistByEmail(email: String, tenantId: String): Boolean!
	"Get a list of logins"
	logins(
		"excludes permissions in logins"
		excludePermissions: Boolean,
		"The ids of the logins"
		ids: [String],
		"checks whether the condition matches the given input"
		isEmailConfirmed: Boolean,
		"checks whether the condition matches the given input"
		isTelephoneNumberConfirmed: Boolean,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter by user type. All if null."
		userTypes: [userEnumeration],
		"The usernames of the logins"
		usernames: [String],
		"A login search filter"
		where: loginWhere
	): logins!
	"Gets a list of motor manufacturers"
	makes(
		"The id of makes"
		id: String
	): [motorMake]
	"Gets the user related to the passed token."
	me: login
	migrationTool_remoteSchemaError: String
	negotiatedItemsQuery(where: users_GenericNegotiatedItemQueryInput): users_GenericNegotiatedItem8QueryInterface
	networksQuery(where: users_GenericNetworkQueryInput): users_GenericNetwork8QueryInterface
	"Get next working date of a particular date"
	nextWorkingDate(
		"ISO 3166-1 alpha-2"
		countryCode: countryCodeEnumGraphTypeEnum!,
		"The date that you want to get next working date"
		date: Date!
	): dateResult
	nodeScript(nodeId: ID!): NodeScriptDescription
	nodeTypes: [Node!]!
	"Get the notification configs"
	notificationConfigs(
		"Notification filter"
		where: notificationConfigWhere
	): [notificationConfig]
	"notification subscriptions"
	notificationSubscriptions(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification subscription search filter"
		where: notificationSubscriptionWhereInput
	): notificationSubscriptions
	"Get the list of notification triggers"
	notificationTriggers(
		"Notification trigger filter"
		where: notificationTriggerWhereInput
	): [notificationTrigger]
	"Get the list of notifications"
	notifications(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Notification filter"
		where: notificationWhere
	): notifications!
	"Get a list of objects"
	objects(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"An object search filter"
		where: objectWhereInput
	): objects!
	openTypes(
		"Returns the elements in the list that come after the specified cursor."
		after: String,
		"Returns the elements in the list that come before the specified cursor."
		before: String,
		"Returns the first _n_ elements from the list."
		first: Int,
		"Returns the last _n_ elements from the list."
		last: Int,
		order: [HotChocolate_OpenTypeReadModelSortInput!],
		where: HotChocolate_OpenTypeReadModelFilterInput
	): OpenTypesConnection
	organizationNegotiatedItemsQuery(where: users_GenericOrganizationNegotiatedItemQueryInput): users_GenericOrganizationNegotiatedItem8QueryInterface
	organizationProviderTiersQuery(where: users_GenericOrganizationProviderTierQueryInput): users_GenericOrganizationProviderTier8QueryInterface
	"Get a list of organizations"
	organizations(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"An organization search filter"
		where: organizationWhereInput
	): organizations!
	"Get panelProviderTiers"
	panelProviderTiers(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A panelProviderTier search filter"
		where: panelProviderTierWhereInput
	): panelProviderTiers
	partyQueryRegisterPartyState(workflowInstanceId: String!): requestManager_WorkflowRunStateOfPartyState!
	partyQuerySearchOrganizations(filter: requestManager_OrganizationSearchFilterInput, order: [requestManager_OrganizationPartySortInput!], skip: Int, take: Int): requestManager_WorkflowRunStateOfOrganizationStateCollectionSegment!
	partyQuerySearchOrganizationsState(workflowInstanceId: String!): requestManager_WorkflowRunStateOfOrganizationStateCollectionSegment!
	partyQuerySearchPersons(filter: requestManager_PersonSearchFilterInput, order: [requestManager_PersonPartySortInput!], skip: Int, take: Int): requestManager_WorkflowRunStateOfPersonStateCollectionSegment!
	partyQuerySearchPersonsState(workflowInstanceId: String!): requestManager_WorkflowRunStateOfPersonStateCollectionSegment!
	"Get the password validators"
	passwordValidators(
		"The client identifier"
		clientId: String,
		"The tenant identifier"
		tenantId: String!
	): passwordValidators
	paymentProviderConfigIdByProviderId(providerId: String): String
	paymentProviderCustomerSubscriptionByTenant(customerId: String, providerId: String): transactions_SubsCription
	paymentProviderPaymentProviderPricesByTenant(limit: Int!, providerId: String): transactions_PaymentProviderPrice
	paymentProviderPaymentProviderProductsByTenant(limit: Int!, providerId: String): transactions_PaymentProviderProduct
	"get all permission groups"
	permissionGroups(
		"A permission group search filter"
		where: permissionGroupWhereInput
	): [permissionGroup!]!
	"Gets a list of permissionSchemas"
	permissionSchemas(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A permission schema search filter"
		where: permissionSchemaWhereInput
	): permissionSchemas!
	permissioningToken(targettedPermissionsToDelegate: [addTargettedPermissionInput!], targettedPermissionsToRequest: [addTargettedPermissionInput!]): String!
	"gets all permissions"
	permissions: [permission]
	"Get plans"
	plans(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A product search filter"
		where: planWhereInput
	): [plan]
	"Gets a list of policies"
	policies(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A policy search filter"
		where: policyWhereInput
	): policies
	policiesPricing(asOf: DateTime, outputSchema: String, policyId_in: [String!]!, useCache: Boolean): policies_PoliciesPricingResult!
	policies_AttachedCommandPermissionsQuery(queryArguments: policies_GenericPolicies_AttachedRuleQueryInput): policies_AttachedRulesQueryInterfaceOfpoliciesAttachedCommandPermissionAndpolicies_AttachedRuleFilter
	policies_AttachedExternalApiCallsQuery(queryArguments: policies_GenericPolicies_AttachedRuleQueryInput): policies_AttachedRulesQueryInterfaceOfpoliciesAttachedExternalApiCallAndpolicies_AttachedRuleFilter
	policies_AttachedFiltersQuery(queryArguments: policies_GenericPolicies_AttachedRuleQueryInput): policies_AttachedRulesQueryInterfaceOfpoliciesAttachedFilterAndpolicies_AttachedRuleFilter
	policies_AttachedObjectValidationsQuery(queryArguments: policies_GenericPolicies_AttachedRuleQueryInput): policies_AttachedRulesQueryInterfaceOfpoliciesAttachedObjectValidationAndpolicies_AttachedRuleFilter
	policies_AttachedPostHandleValidationsQuery(queryArguments: policies_GenericPolicies_AttachedRuleQueryInput): policies_AttachedRulesQueryInterfaceOfpoliciesAttachedPostHandleValidationAndpolicies_AttachedRuleFilter
	"Gets single policy by id"
	policy(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Policy Id"
		policyId: String
	): policy
	policyMemberMovementsQuery(where: policies_PolicyMembersWhereInput): policies_PolicyMemberMovementResult
	policyMemberStatistic(filter: policies_PolicyMemberStatisticFilterInput, limit: Int, skip: Int): policies_PolicyMemberStatisticGraph
	"Calculates policy members movements report"
	policyMembersMovementsReport(
		"query arguments"
		where: policyMembersWhereInput
	): policyMembersMovementsReport
	policyMembersUploads(order: [policies_PolicyMemberUploadSortInput!], skip: Int, take: Int, where: policies_PolicyMemberUploadFilterInput): policies_PolicyMemberUploadCollectionSegment
	policyPricing(asOf: DateTime, endorsementId: String, outputSchema: String, policyId: String!, useCache: Boolean): policies_PolicyPricingResult
	policyReferenceGenerationQueryConfig(type: String): policies_ReferenceGeneratorConfig
	policyUnderwritingQuery(input: policies_PolicyUnderwritingCalculationInput): policies_ScriptResult
	preExistingConditionsQuery(where: claims_GenericPreExistingConditionQueryInput): claims_GenericPreExistingCondition8QueryInterface
	"Get plans"
	productConfigs(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A product search filter"
		where: productConfigWhere
	): [productConfig]
	productImportHistoryQuery(where: products_GenericProductImportHistoryRecordQueryInput): products_GenericProductImportHistoryRecord8QueryInterface
	productImportInfo(filePath: String!): products_ProductImportInfo
	productPricing(dataInput: String!, productId: products_ProductIdInput!): products_ProductPricingResult
	productSchema(nodeId: ID, productSchemaId: ID): ProductSchemaDescription
	"Gets a list of productTypes"
	productTypes(
		"A product type search filter"
		where: productTypeWhereInput
	): [productType]
	"Get products"
	products_2(
		"a list of benefitOptions selected"
		benefitOptions: [benefitOptionInput],
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A list of dynamic values to check underwriting rules"
		values: [keyValueInput],
		"A list of dynamic values to check underwriting rules"
		valuesJsonString: String,
		"A product search filter"
		where: productWhereInput
	): products
	"Get public holidays of a particular year"
	publicHolidays(
		"ISO 3166-1 alpha-2"
		countryCode: countryCodeEnumGraphTypeEnum!,
		"The year that we want to get public holidays"
		year: Int!
	): [PublicHolidayGraphType]
	queryBillingInfos(
		"Returns the elements in the list that come after the specified cursor."
		after: String,
		"Returns the elements in the list that come before the specified cursor."
		before: String,
		"Returns the first _n_ elements from the list."
		first: Int,
		"Returns the last _n_ elements from the list."
		last: Int,
		order: [billing_AggregateStateMongoReadModelOfBillingInfoSortInput!],
		where: billing_AggregateStateMongoReadModelOfBillingInfoFilterInput
	): QueryBillingInfosConnection
	queryBills(
		"Returns the elements in the list that come after the specified cursor."
		after: String,
		"Returns the elements in the list that come before the specified cursor."
		before: String,
		"Returns the first _n_ elements from the list."
		first: Int,
		"Returns the last _n_ elements from the list."
		last: Int,
		order: [billing_BillingBillReadModelSortInput!],
		where: billing_BillingBillReadModelFilterInput
	): QueryBillsConnection
	queryDirectDebitPaymentChannels(
		"Returns the elements in the list that come after the specified cursor."
		after: String,
		"Returns the elements in the list that come before the specified cursor."
		before: String,
		"Returns the first _n_ elements from the list."
		first: Int,
		"Returns the last _n_ elements from the list."
		last: Int,
		order: [billing_AggregateStateMongoReadModelOfDirectDebitPaymentChannelSortInput!],
		where: billing_AggregateStateMongoReadModelOfDirectDebitPaymentChannelFilterInput
	): QueryDirectDebitPaymentChannelsConnection
	queryManualPaymentChannels(
		"Returns the elements in the list that come after the specified cursor."
		after: String,
		"Returns the elements in the list that come before the specified cursor."
		before: String,
		"Returns the first _n_ elements from the list."
		first: Int,
		"Returns the last _n_ elements from the list."
		last: Int,
		order: [billing_AggregateStateMongoReadModelOfManualPaymentChannelSortInput!],
		where: billing_AggregateStateMongoReadModelOfManualPaymentChannelFilterInput
	): QueryManualPaymentChannelsConnection
	queryPolicyMemberEndorsementFields(policyId: String!): policies_PolicyMemberEndorsementFields!
	queryReasons(order: [policies_ReasonSortInput!], skip: Int, take: Int, where: policies_ReasonFilterInput): policies_ReasonCollectionSegment
	readModelHistory(
		"Returns the elements in the list that come after the specified cursor."
		after: String,
		"Returns the elements in the list that come before the specified cursor."
		before: String,
		"Returns the first _n_ elements from the list."
		first: Int,
		"Returns the last _n_ elements from the list."
		last: Int,
		order: [HotChocolate_ReadModelEventProcessedSortInput!],
		where: HotChocolate_ReadModelEventProcessedFilterInput
	): ReadModelHistoryConnection
	"Refresh the token"
	refreshToken(
		"The client identifier"
		clientId: String!,
		refreshToken: String!,
		"The tenant identifier"
		tenantId: String!
	): token
	"Renders the email Mjml"
	renderEmailMjml(
		"The emailMjml to render"
		emailMjml: String!,
		"Parameters in order to render the template"
		input: templateRenderParametersInput
	): stringResult
	"Renders the email mjml template"
	renderEmailMjmlTemplate(
		"If true, will add attachments"
		includeAttachments: Boolean,
		"Parameters in order to render the template"
		input: templateRenderParametersInput,
		"The template identifier"
		templateId: String!
	): emailRenderedResult
	"Renders the function template"
	renderFunctionTemplate(
		"Parameters in order to render the template"
		input: templateRenderParametersInput,
		"The template identifier"
		templateId: String!
	): functionRenderOutput
	"Renders the html"
	renderHtml(
		"The html to render"
		html: String!,
		"Parameters in order to render the template"
		input: templateRenderParametersInput
	): stringResult
	"Renders the html template"
	renderHtmlTemplate(
		"Parameters in order to render the template"
		input: templateRenderParametersInput,
		"The template identifier"
		templateId: String!
	): stringResult
	"Renders the pdf drawing template"
	renderPdfDrawingTemplate(
		"Parameters in order to render the template"
		input: templateRenderParametersInput,
		"The template identifier"
		templateId: String!
	): pdfRenderedResult
	"Renders the pdf drawing template"
	renderPdfDrawingTemplateV2(
		"Parameters in order to render the template"
		input: templateRenderParametersInput,
		"The template identifier"
		templateId: String!
	): stringResult
	"Renders the sms"
	renderSms(
		"The bodyLiquid to render"
		bodyLiquid: String!,
		"Parameters in order to render the template"
		input: templateRenderParametersInput
	): smsRenderedResult
	"Renders the sms template"
	renderSmsTemplate(
		"Parameters in order to render the template"
		input: templateRenderParametersInput,
		"The template identifier"
		templateId: String!
	): smsRenderedResult
	"Renders the wkhtmltopdf"
	renderWkhtmltopdf(
		"The footer settings"
		footerSettings: headerFooterInput,
		"The header settings"
		headerSettings: headerFooterInput,
		"The html to render"
		html: String!,
		"Parameters in order to render the pdf"
		input: templateRenderParametersInput,
		"The margin settings"
		marginSettings: marginSettingsInput,
		"The orientation"
		orientation: orientationEnumeration
	): pdfRenderedResult
	"Renders the wkhtmltopdf with multiple page objects"
	renderWkhtmltopdf2(
		"Parameters in order to render the pdf"
		input: templateRenderParametersInput,
		"The margin settings"
		marginSettings: marginSettingsInput,
		"The orientation"
		orientation: orientationEnumeration,
		"The list of page object settings"
		pageObjects: [pageObjectInput]!
	): pdfRenderedResult
	"Renders the wkhtmltopdf with multiple page objects"
	renderWkhtmltopdf2V2(
		"Parameters in order to render the pdf"
		input: templateRenderParametersInput,
		"The margin settings"
		marginSettings: marginSettingsInput,
		"The orientation"
		orientation: orientationEnumeration,
		"The list of page object settings"
		pageObjects: [pageObjectInput]!
	): stringResult
	"Renders the wkhtmltopdf template"
	renderWkhtmltopdfTemplate(
		"Parameters in order to render the template"
		input: templateRenderParametersInput,
		"The template identifier"
		templateId: String!
	): pdfRenderedResult
	"Renders the wkhtmltopdf template and returns the filepath"
	renderWkhtmltopdfTemplateV2(
		"Parameters in order to render the template"
		input: templateRenderParametersInput,
		"The template identifier"
		templateId: String!
	): stringResult
	"Renders the wkhtmltopdf"
	renderWkhtmltopdfV2(
		"The footer settings"
		footerSettings: headerFooterInput,
		"The header settings"
		headerSettings: headerFooterInput,
		"The html to render"
		html: String!,
		"Parameters in order to render the pdf"
		input: templateRenderParametersInput,
		"The margin settings"
		marginSettings: marginSettingsInput,
		"The orientation"
		orientation: orientationEnumeration
	): stringResult
	"Replay recorded node field resolution. Initial input and tree state are reused"
	replay(recordId: ID!): RecordResolutionView!
	"""

	Resolve any field value on a given node. Can be used for data values,
	node-defined formulas, and root operations. In latter node id should be
	the root of the tree.
	"""
	resolve(cached: Boolean, fieldName: String!, input: ExpressionInput, nodeId: ID, nodeLocation: NodeLocationInput): ResolutionResult!
	sSOAccessTokenQuerySSOAccessToken(ssoAuthCodeinput: auth_SSOAuthCodeInput): auth_SSOTokenReponse
	sSOAccessTokenQuerySSORefreshToken(ssoRefreshTokeninput: auth_SSORefreshTokenInput): auth_SSOTokenReponse
	sSOConfigsQuerySSOConfigById(id: String): auth_SSOConfig
	sbusQuery(where: products_GenericSbuQueryInput): products_GenericSbu8QueryInterface
	"Get scripts"
	scripts(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A script search filter"
		where: scriptWhereInput
	): scripts
	"Get a list of files"
	searchFiles(
		"The targetted bucket name"
		bucketName: String,
		"The filter"
		where: fileWhere
	): [fileSummary!]!
	"Search a user by code"
	searchUserByCode(
		"The code of the internal"
		code: String!,
		"The tenant identifier"
		tenantId: String!
	): entityInterface
	"Get serviceItemAgreedFee"
	serviceItemAgreedFee(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A serviceItemAgreedFee search filter"
		where: serviceItemAgreedFeeWhereInput
	): serviceItemAgreedFees
	"Get serviceItem"
	serviceItems(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A serviceItem search filter"
		where: serviceItemWhereInput
	): serviceItems
	serviceRatesQuery(where: users_GenericServiceRateQueryInput): users_GenericServiceRate8QueryInterface
	servicingAgentChangeLogsQuery(where: users_GenericServicingAgentChangeLogQueryInput): users_GenericServicingAgentChangeLog8QueryInterface
	settlementReportsQuery(input: claims_SettlementReportFilterInput): claims_ResultOfString
	"Return node and all its children"
	subtree(nodeId: ID!): Node
	templateStatisticsQuery(where: templates_GenericTemplateStatisticsQueryInput): templates_GenericTemplateStatistics8QueryInterface
	"Gets a list of templates"
	templates(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A policy search filter"
		where: templateWhereInput
	): templates
	tenantSettings: tenantSettings!
	tenants(
		"Returns the elements in the list that come after the specified cursor."
		after: String,
		"Returns the elements in the list that come before the specified cursor."
		before: String,
		"Returns the first _n_ elements from the list."
		first: Int,
		"Returns the last _n_ elements from the list."
		last: Int,
		order: [HotChocolate_TenantReadModelSortInput!],
		where: HotChocolate_TenantReadModelFilterInput
	): TenantsConnection
	"Get the terms and conditions for a specific tenant and client"
	termsAndConditions(
		"The client identifier"
		clientId: String!,
		"The tenant identifier"
		tenantId: String!
	): String
	"Api to test errors"
	testerrors: result
	"Api to exception errors"
	testexception: result
	"Api to exception errors"
	testlogerror: result
	"Refresh the token"
	token_2(
		"The client identifier"
		clientId: String!,
		password: String!,
		"The tenant identifier"
		tenantId: String!,
		twoFactorTemplateId: String,
		twoFactorToken: String,
		username: String!
	): token
	"Gets a list of transactions"
	transactions(
		"a time travel filter"
		asOf: DateTimeOffset,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A transaction search filter"
		where: transactionWhereInput
	): transactions
	"Get treatments"
	treatments(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A treatment search filter"
		where: treatmentFilterInput
	): treatments
	"Get uiSchemas"
	uiSchemas(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A uiSchema search filter"
		where: uiSchemaWhereInput
	): uiSchemas
	"Current user items storage"
	userStorage: userStorageItems!
	users_AttachedCommandPermissionsQuery(queryArguments: users_GenericUsers_AttachedRuleQueryInput): users_AttachedRulesQueryInterfaceOfusersAttachedCommandPermissionAndusers_AttachedRuleFilter
	users_AttachedExternalApiCallsQuery(queryArguments: users_GenericUsers_AttachedRuleQueryInput): users_AttachedRulesQueryInterfaceOfusersAttachedExternalApiCallAndusers_AttachedRuleFilter
	users_AttachedFiltersQuery(queryArguments: users_GenericUsers_AttachedRuleQueryInput): users_AttachedRulesQueryInterfaceOfusersAttachedFilterAndusers_AttachedRuleFilter
	users_AttachedObjectValidationsQuery(queryArguments: users_GenericUsers_AttachedRuleQueryInput): users_AttachedRulesQueryInterfaceOfusersAttachedObjectValidationAndusers_AttachedRuleFilter
	users_AttachedPostHandleValidationsQuery(queryArguments: users_GenericUsers_AttachedRuleQueryInput): users_AttachedRulesQueryInterfaceOfusersAttachedPostHandleValidationAndusers_AttachedRuleFilter
	validateMembers(input: policies_MemberValidationInput!, where: policies_MemberValidationWhereInput!): policies_ResultOfMemberValidationResult!
	"Gets a result of a password validation"
	validatePassword(
		"The password to validate"
		password: String!
	): result
	"Validates the policy"
	validatePolicy(
		"The policy id"
		policyId: String!
	): validatePolicyResult!
	"Validates the policy"
	validatePolicy_2(
		"The policy id"
		policyId: String!
	): result! @deprecated(reason: "use the new validatePolicy query")
	"Get validation of products"
	validateProducts(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"A list of dynamic values to check underwriting rules"
		values: [keyValueInput]!,
		"A product search filter"
		where: productWhereInput
	): [validateProductResult]
	"verifies good token and does not make access token if fails"
	verifyGOODTokenAndGetCoverGoToken(
		"The client identifier"
		clientId: String,
		"The password for this login"
		password: String,
		"The tenant identifier"
		tenantId: String,
		"GOOD Token generated from GOOD SDK"
		token: String,
		"The username to login as"
		username: String
	): [token]
	"Versions of the services"
	versions: ApplicationVersionInfoListGraphType
}

"A connection to a list of items."
type QueryBillingInfosConnection {
	"A list of edges."
	edges: [QueryBillingInfosEdge!]
	"A flattened list of the nodes."
	nodes: [billing_AggregateStateMongoReadModelOfBillingInfo!]
	"Information to aid in pagination."
	pageInfo: PageInfo!
	totalCount: Int!
}

"An edge in a connection."
type QueryBillingInfosEdge {
	"A cursor for use in pagination."
	cursor: String!
	"The item at the end of the edge."
	node: billing_AggregateStateMongoReadModelOfBillingInfo!
}

"A connection to a list of items."
type QueryBillsConnection {
	"A list of edges."
	edges: [QueryBillsEdge!]
	"A flattened list of the nodes."
	nodes: [billing_BillingBillReadModel!]
	"Information to aid in pagination."
	pageInfo: PageInfo!
	totalCount: Int!
}

"An edge in a connection."
type QueryBillsEdge {
	"A cursor for use in pagination."
	cursor: String!
	"The item at the end of the edge."
	node: billing_BillingBillReadModel!
}

"A connection to a list of items."
type QueryDirectDebitPaymentChannelsConnection {
	"A list of edges."
	edges: [QueryDirectDebitPaymentChannelsEdge!]
	"A flattened list of the nodes."
	nodes: [billing_AggregateStateMongoReadModelOfDirectDebitPaymentChannel!]
	"Information to aid in pagination."
	pageInfo: PageInfo!
	totalCount: Int!
}

"An edge in a connection."
type QueryDirectDebitPaymentChannelsEdge {
	"A cursor for use in pagination."
	cursor: String!
	"The item at the end of the edge."
	node: billing_AggregateStateMongoReadModelOfDirectDebitPaymentChannel!
}

"A connection to a list of items."
type QueryManualPaymentChannelsConnection {
	"A list of edges."
	edges: [QueryManualPaymentChannelsEdge!]
	"A flattened list of the nodes."
	nodes: [billing_AggregateStateMongoReadModelOfManualPaymentChannel!]
	"Information to aid in pagination."
	pageInfo: PageInfo!
	totalCount: Int!
}

"An edge in a connection."
type QueryManualPaymentChannelsEdge {
	"A cursor for use in pagination."
	cursor: String!
	"The item at the end of the edge."
	node: billing_AggregateStateMongoReadModelOfManualPaymentChannel!
}

type ReadModelEvent {
	address: OpenAddressDto!
	error: String
	processedEvent: String!
	readModelBuilder: String!
	result: EventConsumeStatus!
}

type ReadModelEventProcessed {
	builderType: String!
	checkpoint: Long!
	eventId: ID!
	eventSource: String!
	eventType: String!
	id: String!
	message: String
	result: EventConsumeStatus!
	time: DateTime!
}

"A connection to a list of items."
type ReadModelHistoryConnection {
	"A list of edges."
	edges: [ReadModelHistoryEdge!]
	"A flattened list of the nodes."
	nodes: [ReadModelEventProcessed!]
	"Information to aid in pagination."
	pageInfo: PageInfo!
}

"An edge in a connection."
type ReadModelHistoryEdge {
	"A cursor for use in pagination."
	cursor: String!
	"The item at the end of the edge."
	node: ReadModelEventProcessed!
}

type RecordResolutionResult {
	events: [Event!]
	record: RecordResolutionView
}

type RecordResolutionView {
	id: ID
	input: Expression
	nodeVersion: Int
	resolution: ResolutionResult
	tree: Node
}

type ReminderModel {
	sentAt: DateTime!
	sentBy: UserModel!
}

type RequestedDocumentsModel {
	files: [FileModel!]
	name: String
	received: Boolean!
}

type ResolutionResult {
	metrics: [KeyValuePairOfStringAndDouble!]
	script: String
	trace: [TraceStep!]!
	value: String
}

type Result {
	errors: [String]
	errors_2: [Error]
	isSuccess: Boolean!
	status: String
}

type ResultOfGuid {
	errors: [String]
	errors_2: [Error]
	isSuccess: Boolean!
	status: String
	value: ID!
}

type StateDescriptionDto {
	aggregateType: OpenTypeDto!
	stateClrType: String!
}

type StateDescriptionReadModel {
	aggregateType: OpenTypeReadModel!
	id: String!
	stateType: String!
}

type Subscription {
	policies_policyMemberUploadCanceled(policyId: String, tenantId: String): PolicyMemberUploadPayload
	policies_policyMemberUploadErrorRemoved(policyId: String, tenantId: String): PolicyMemberUploadPayload
	policies_policyMemberUploadFailed(policyId: String, tenantId: String): PolicyMemberUploadPayload
	policies_policyMemberUploadImported(policyId: String, tenantId: String): PolicyMemberUploadPayload
	policies_policyMemberUploadRegistered(policyId: String, tenantId: String): PolicyMemberUploadPayload
	policies_policyMemberUploadReversed(policyId: String, tenantId: String): PolicyMemberUploadPayload
	policies_policyMemberUploadStartedCanceling(policyId: String, tenantId: String): PolicyMemberUploadPayload
	policies_policyMemberUploadStartedErrorRemoving(policyId: String, tenantId: String): PolicyMemberUploadPayload
	policies_policyMemberUploadStartedImporting(policyId: String, tenantId: String): PolicyMemberUploadPayload
	policies_policyMemberUploadStartedReversing(policyId: String, tenantId: String): PolicyMemberUploadPayload
	policies_policyMemberUploadStartedValidating(policyId: String, tenantId: String): PolicyMemberUploadPayload
	policies_policyMemberUploadValidated(policyId: String, tenantId: String): PolicyMemberUploadPayload
	readModel(topic: ReadModelTopicInput!): ReadModelEvent!
	registerPartyCompleted(accessToken: ID!): requestManager_WorkflowCompletedOfPartyState!
	searchOrganizationsCompleted(accessToken: ID!): requestManager_WorkflowCompletedOfOrganizationStateCollectionSegment!
	searchPersonsCompleted(accessToken: ID!): requestManager_WorkflowCompletedOfPersonStateCollectionSegment!
	test: String
}

type TenantReadModel {
	created: DateTime!
	createdBy: String!
	id: String!
	name: String!
	status: TenantStatus!
	tenantsCentreAggregateId: ID!
}

"A connection to a list of items."
type TenantsConnection {
	"A list of edges."
	edges: [TenantsEdge!]
	"A flattened list of the nodes."
	nodes: [TenantReadModel!]
	"Information to aid in pagination."
	pageInfo: PageInfo!
}

"An edge in a connection."
type TenantsEdge {
	"A cursor for use in pagination."
	cursor: String!
	"The item at the end of the edge."
	node: TenantReadModel!
}

type TraceStep {
	caller: FieldReference
	step: TraceStepType!
	target: FieldReference
	time: DateTime!
	value: String
}

type UiSchema {
	name: String!
	schema: String!
}

type UserModel {
	email: String!
	id: String!
	name: String!
}

"Achievement"
type achievement {
	achievementType: achievementType
	createdAt: DateTime
	createdBy: login
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
}

"The condition to unlock an achievement type. graphQlQuery needs the variables $entityId, and liquidCondition is a liquid expression returning 'True' when supposed to unlock the achievement."
type achievementLogic {
	and: [achievementLogic]
	graphQlQuery: String
	liquidCondition: String
	or: [achievementLogic]
}

"Achievement type"
type achievementType {
	createdAt: DateTime
	createdBy: login
	description: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	logic: achievementLogic
	name: String
	type: String
}

"Gets all achievement types"
type achievementTypes {
	list: [achievementType]
	totalCount: Int!
}

type addAddressCommand {
	addedBy: login
	commandId: String
	entityId: String
	fields: [field]
	timestamp: DateTime
	type: String
}

type addAssociatedContractCommandGraph {
	addedBy: login
	commandId: String
	contract: binder
	timestamp: DateTime
}

type addClauseCommand {
	addedBy: login
	clauseId: String
	commandId: String
	htmlOverride: String
	order: Int
	renderParameters: templateRenderParameters
	renderedHtmlResult: stringResult
	templateId: String
	timestamp: DateTime
}

type addContactCommand {
	addedBy: login
	commandId: String
	entityId: String
	timestamp: DateTime
	type: String
	value: String
}

type addDiscountCommand {
	addedBy: login
	calculationJsonLogic: String
	commandId: String
	name: String
	order: Int
	timestamp: DateTime
}

type addEntityCommand {
	addedBy: login
	commandId: String
	endorsementId: String
	entityId: String
	timestamp: DateTime
}

type addIdentityCommand {
	addedBy: login
	commandId: String
	entityId: String
	timestamp: DateTime
	type: String
	value: String
}

type addLoadingCommand {
	addedBy: login
	calculationJsonLogic: String
	code: String
	commandId: String
	flat: Decimal
	id: String!
	order: Int
	ratio: Decimal
	timestamp: DateTime
}

"A user's address (customer or internal user)"
type address {
	fields: String
	fields2: [field]
	id: String!
	type: String!
}

type advice {
	offer: offer
	scores: [score]
}

type advices {
	list: [advice]
	totalCount: Int!
}

type app {
	absoluteRefreshTokenLifetime: Int
	accessTokenLifetime: Int
	activationTokenExpiryDisabled: Boolean
	appConfig: String
	appId: String!
	appName: String
	createdAt: DateTime
	createdBy: login
	defaultTimeZone: String
	email: String
	emailConfirmationTokenLifespan: Seconds
	emailSenderName: String
	events: [eventLog]
	lastModifiedAt: DateTime
	lastModifiedBy: login
	redirectUris: [String]
	requires2FA: Boolean!
	requiresEmail2FA: Boolean
	slidingRefreshTokenLifetime: Int
	urlRouting: urlRouting
	useNotificationConfig: Boolean
}

"Application version details( version, revision, build date ..etc)"
type applicationVersionInfo {
	application: String!
	buildDateTime: DateTimeOffset
	revision: String!
	version: String!
}

type apps {
	list: [app]
	totalCount: Int!
}

type associatedContract {
	contract: binder
	id: String
}

"Attachment file name and objectUrl"
type attachment {
	createdAt: DateTime
	createdBy: login
	fileName: String
	id: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	path: String
}

type attachmentReference {
	fileName: String!
	filePath: String!
	id: String!
}

type attachmentTemplate {
	attachmentTemplateId: String!
	fileName: String!
	templateId: String!
}

type auth_AppConfiguration {
	appConfig: String
	appId: String
	tenantId: String
}

type auth_CreatedStatus {
	id: String
	ids: [String]
}

type auth_Error {
	code: String
	message: String
}

type auth_KeyValuePairOfStringAndListOfString {
	key: String!
	value: [String!]!
}

type auth_KeyValuePairOfStringAndString {
	key: String!
	value: String!
}

type auth_Result {
	errors: [String]
	errors_2: [auth_Error]
	isSuccess: Boolean!
	status: String
}

type auth_ResultOfCreatedStatus {
	errors: [String]
	errors_2: [auth_Error]
	isSuccess: Boolean!
	status: String
	value: auth_CreatedStatus
}

type auth_SSOConfig {
	additionalClaims: [auth_KeyValuePairOfStringAndListOfString!]
	claimsMap: [auth_KeyValuePairOfStringAndString!]
	clientId: String
	clientSecret: String
	id: String
	idClaim: String
	keyUrl: String
	keyUrlClaim: String
	tenantId: String
	validateExistingLoginByEmail: Boolean
}

type auth_SSOTokenReponse {
	accessToken: String
	expiresIn: Int!
	refreshToken: String
}

type bankPaymentMethod implements paymentMethodInterface {
	accountHolderName: String
	bankName: String
	bankNumber: String
	branchCode: String
	createdAt: DateTime
	createdBy: login
	entityId: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
}

type batchId {
	id: String!
	name: String
}

"Specifies the proceeds eligibility of a beneficiary"
type beneficiaryEligibility {
	"The benefit"
	benefit: benefit
	createdAt: DateTime
	createdBy: login
	"The entity"
	entity: entityInterface
	id: String!
	isRevocable: Boolean
	lastModifiedAt: DateTime
	lastModifiedBy: login
	notes: String
	"The ratio of the policy benefit for this user"
	ratio: Decimal!
}

type benefit {
	categories: [benefitCategory]!
	condition: condition
	currencyCode: currencyCodeEnumeration
	description: String
	detailedValue: String
	isOptional: Boolean! @deprecated(reason: "not used anymore")
	isValueInput: Boolean!
	name: String
	optionKey: String
	options: [benefitOption] @deprecated(reason: "not used anymore")
	parentOptionKey: String @deprecated(reason: "not used anymore")
	parentOptionKeys: [String]
	parentTypeId: String
	rawData: String
	typeId: String!
	value: String
	value2: scalarValue
}

type benefitCategoriesPerType {
	categories: [benefitCategory]
	productType: String
}

type benefitCategory {
	benefitTypeIds: [String]
	description: String
	id: String!
	name: String
}

type benefitClaim {
	benefit: benefit
	benefitDescription: String
	benefitName: String
	currencyCode: currencyCodeEnumeration
	id: ID!
	remark: String
	totalValues: claimValue
	value: scalarValue
	values: [claimValue]
}

type benefitDefinition {
	benefitDefinitionTypes: [benefitDefinitionType]
	businessId: String
	description: String
	fields: String
	id: String
	name: String
	status: String
}

type benefitDefinitionType {
	businessId: String
	description: String
	fields: String
	id: String
	name: String
	status: String
}

type benefitDefinitionTypes {
	list: [benefitDefinitionType!]
	totalCount: Int!
}

type benefitDefinitions {
	list: [benefitDefinition]
	totalCount: Int
}

"A benefit graph of a product"
type benefitGraph {
	categories: [benefitCategory]!
	children: [benefitGraph]
	condition: condition
	currencyCode: currencyCodeEnumeration
	description: String
	detailedValue: String
	isOptional: Boolean! @deprecated(reason: "not used anymore")
	isValueInput: Boolean!
	name: String
	optionKey: String
	options: [benefitGraph]
	parentOptionKeys: [String]
	rawData: String
	typeId: String!
	value: String
	value2: scalarValue
}

type benefitInfo {
	categories: [String]
	description: String
	name: String
	type: String @deprecated(reason: "not used anymore")
	typeId: String!
}

"The different options of a benefit"
type benefitOption {
	benefitTypeId: String!
	createdAt: DateTime
	detailedValue: String
	key: String
	lastModifiedAt: DateTime
	rawData: String
	value: scalarValue
}

type benefitOptionChoice {
	benefitTypeId: String!
	createdAt: DateTime
	createdBy: login
	formattedValue: String
	key: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	value: scalarValue
}

"A benefitSummary"
type benefitSummary {
	benefitGraphs: [benefitGraph]
	benefits: [benefit]
}

type billing_AddAddressCommand {
	addedById: String
	commandId: String
	endorsementId: String
	entityId: String
	fields: [billing_KeyValuePairOfStringAndString!]
	id: String
	timestamp: DateTime!
	type: String
}

type billing_AddAssociatedContractCommand {
	addedById: String
	commandId: String
	contractId: String
	endorsementId: String
	id: String
	offerId: String
	proposalId: String
	timestamp: DateTime!
}

type billing_AddClauseCommand {
	addedById: String
	clauseId: String
	commandId: String
	endorsementId: String
	htmlOverride: String
	order: Int!
	renderParameters: billing_RenderParameters
	templateId: String
	timestamp: DateTime!
	type: String
}

type billing_AddContactCommand {
	addedById: String
	commandId: String
	endorsementId: String
	entityId: String
	id: String
	timestamp: DateTime!
	type: String
	value: String
}

type billing_AddDiscountCommand {
	addedById: String
	commandId: String
	currencyCode: billing_CurrencyCode!
	discountId: String
	endorsementId: String
	isManual: Boolean!
	name: String
	offerId: String
	order: Int!
	proposalId: String
	timestamp: DateTime!
}

type billing_AddEntityCommand {
	addedById: String
	commandId: String
	endorsementId: String
	entityId: String
	timestamp: DateTime!
}

type billing_AddFactCommand {
	addedById: String
	commandId: String
	endorsementId: String
	entityId: String
	id: String
	timestamp: DateTime!
	type: String
}

type billing_AddIdentityCommand {
	addedById: String
	commandId: String
	endorsementId: String
	entityId: String
	id: String
	timestamp: DateTime!
	type: String
	value: String
}

type billing_AddLoadingCommand {
	addedById: String
	code: String
	commandId: String
	endorsementId: String
	flat: Decimal
	id: String
	offerId: String
	order: Int!
	proposalId: String
	ratio: Decimal
	timestamp: DateTime!
}

type billing_Address {
	fields: [billing_KeyValuePairOfStringAndString!]
	id: String
	type: String
}

type billing_AggregateStateMongoReadModelOfBillingInfo {
	aggregate: billing_OpenAddressReadModel!
	created: DateTime!
	id: String!
	state: billing_BillingInfo!
}

type billing_AggregateStateMongoReadModelOfDirectDebitPaymentChannel {
	aggregate: billing_OpenAddressReadModel!
	created: DateTime!
	id: String!
	state: billing_DirectDebitPaymentChannel!
}

type billing_AggregateStateMongoReadModelOfManualPaymentChannel {
	aggregate: billing_OpenAddressReadModel!
	created: DateTime!
	id: String!
	state: billing_ManualPaymentChannel!
}

type billing_AssociatedContract {
	contractId: String
	id: String
}

type billing_Attachment {
	createdAt: DateTime!
	createdById: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	path: String
}

type billing_BeneficiaryEligibility {
	benefitTypeId: String
	contractEntity: billing_Entity
	createdAt: DateTime!
	createdById: String
	id: String
	isRevocable: Boolean!
	lastModifiedAt: DateTime!
	lastModifiedById: String
	notes: String
	ratio: Decimal!
}

type billing_BenefitOption {
	createdAt: DateTime!
	createdById: String
	currencyCode: billing_CurrencyCode!
	insuredId: String
	key: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	typeId: String
}

type billing_BillingBill {
	amount: Decimal!
	id: String!
	paidAt: DateTime
	paymentChannel: billing_IPaymentChannel
	paymentChannelRef: String
	paymentChannelType: billing_PaymentChannelType
	status: billing_BillingBillStatus!
	toBeIssuedAt: DateTime!
}

type billing_BillingBillReadModel {
	aggregate: billing_OpenAddressReadModel
	bill: billing_BillingBill
	billingInfo: billing_BillingInfo
	id: String
	premiumInstallment: billing_BillingPremiumInstallment
}

type billing_BillingInfo {
	billedToDate: DateTime
	currencyCode: billing_CurrencyCode!
	currentPremium: billing_BillingPremiumInstallment
	endDate: DateTime
	isDeleted: Boolean!
	leadTime: TimeSpan!
	nextBillingAmount: Decimal
	nextBillingDate: DateTime
	outstandingAmount: Decimal!
	paidToDate: DateTime
	period: billing_BillingPeriod!
	policy: billing_Policy
	policyRef: String!
	premiumInstallments: [billing_BillingPremiumInstallment!]!
	startDate: DateTime
}

type billing_BillingPremiumInstallment {
	attachments: [String!]
	bills: [billing_BillingBill!]!
	dueDate: DateTime!
	id: String!
	pricingBreakdown: [billing_BillingPricingBreakdown!]!
	status: billing_BillingPremiumInstallmentStatus!
}

type billing_BillingPricingBreakdown {
	accountType: String!
	amount: Decimal!
	description: String!
}

type billing_Clause {
	htmlOverride: String
	id: String
	order: Int!
	renderParameters: billing_RenderParameters
	templateId: String
	type: String
}

type billing_ClauseCommandBatch {
	addClauseCommands: [billing_AddClauseCommand!]
	byId: String
	commandId: String
	endorsementId: String
	removeClauseCommands: [billing_RemoveClauseCommand!]
	timestamp: DateTime!
	updateClauseCommands: [billing_UpdateClauseCommand!]
}

type billing_Commission {
	amount: Decimal
	createdAt: DateTime!
	createdById: String
	currencyCode: billing_CurrencyCode
	entityId: String
	id: String
	jsonRule: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	remark: String
}

type billing_Contact {
	id: String
	type: String
	value: String
}

type billing_DirectDebitPaymentChannel implements billing_IPaymentChannel {
	authorization: String
	bank: String!
	bankResponse: String
	directDebit: String
	fields: String
	holderId: String
	status: billing_DirectDebitPaymentChannelStatus
	type: billing_PaymentChannelType!
}

type billing_Discount {
	alwaysApplies: Boolean!
	code: String
	createdAt: DateTime!
	createdById: String
	currencyCode: billing_CurrencyCode
	flat: Decimal
	id: String
	isManual: Boolean!
	lastModifiedAt: DateTime!
	lastModifiedById: String
	name: String
	newPrice: Decimal!
	order: Int!
	originalPrice: Decimal!
	ratio: Decimal
}

type billing_Endorsement {
	addAssociatedContractCommands: [billing_AddAssociatedContractCommand!]
	addClauseCommands: [billing_AddClauseCommand!]
	addContractHolderAddressCommands: [billing_AddAddressCommand!]
	addContractHolderContactCommands: [billing_AddContactCommand!]
	addContractHolderFactCommands: [billing_AddFactCommand!]
	addContractHolderIdentityCommands: [billing_AddIdentityCommand!]
	addContractInsuredAddressCommands: [billing_AddAddressCommand!]
	addContractInsuredCommands: [billing_AddEntityCommand!]
	addContractInsuredContactCommands: [billing_AddContactCommand!]
	addContractInsuredFactCommands: [billing_AddFactCommand!]
	addContractInsuredIdentityCommands: [billing_AddIdentityCommand!]
	addDiscountCommands: [billing_AddDiscountCommand!]
	addLoadingCommands: [billing_AddLoadingCommand!]
	addOtherContractHolderAddressCommands: [billing_AddAddressCommand!]
	addOtherContractHolderCommands: [billing_AddEntityCommand!]
	addOtherContractHolderContactCommands: [billing_AddContactCommand!]
	addOtherContractHolderFactCommands: [billing_AddFactCommand!]
	addOtherContractHolderIdentityCommands: [billing_AddIdentityCommand!]
	addPolicyFactCommands: [billing_AddFactCommand!]
	cancellationMotive: String
	clauseCommandBatches: [billing_ClauseCommandBatch!]
	createdAt: DateTime!
	createdById: String
	effectiveDate: DateTime
	endorsementDate: DateTime
	id: String
	isApproved: Boolean!
	isRejected: Boolean!
	jacketEndorsementCommands: [billing_JacketEndorsementCommand!]
	lastModifiedAt: DateTime!
	lastModifiedById: String
	reasonOfChange: String
	removeAssociatedContractCommands: [billing_RemoveAssociatedContractCommand!]
	removeBenefitOptionCommands: [billing_RemoveBenefitOptionCommand!]
	removeContractHolderAddressCommands: [billing_RemoveCommand!]
	removeContractHolderContactCommands: [billing_RemoveCommand!]
	removeContractHolderFactCommands: [billing_RemoveCommand!]
	removeContractHolderIdentityCommands: [billing_RemoveCommand!]
	removeContractInsuredAddressCommands: [billing_RemoveEntityPrimitiveCommand!]
	removeContractInsuredCommands: [billing_RemoveCommand!]
	removeContractInsuredContactCommands: [billing_RemoveEntityPrimitiveCommand!]
	removeContractInsuredFactCommands: [billing_RemoveEntityPrimitiveCommand!]
	removeContractInsuredIdentityCommands: [billing_RemoveEntityPrimitiveCommand!]
	removeDiscountCommands: [billing_RemoveCommand!]
	removeLoadingCommands: [billing_RemoveCommand!]
	removeOtherContractHolderAddressCommands: [billing_RemoveEntityPrimitiveCommand!]
	removeOtherContractHolderCommands: [billing_RemoveCommand!]
	removeOtherContractHolderContactCommands: [billing_RemoveEntityPrimitiveCommand!]
	removeOtherContractHolderFactCommands: [billing_RemoveEntityPrimitiveCommand!]
	removeOtherContractHolderIdentityCommands: [billing_RemoveEntityPrimitiveCommand!]
	removePolicyFactCommands: [billing_RemoveCommand!]
	source: billing_EndorsementSource
	status: String
	submissionDate: DateTime
	type: String
	updateContractHolderAddressCommands: [billing_UpdateAddressCommand!]
	updateContractHolderContactCommands: [billing_UpdateContactCommand!]
	updateContractHolderFactCommands: [billing_UpdateFactCommand!]
	updateContractHolderIdentityCommands: [billing_UpdateIdentityCommand!]
	updateContractInsuredAddressCommands: [billing_UpdateAddressCommand!]
	updateContractInsuredCompanyCommands: [billing_UpdateCompanyCommand!]
	updateContractInsuredContactCommands: [billing_UpdateContactCommand!]
	updateContractInsuredFactCommands: [billing_UpdateFactCommand!]
	updateContractInsuredIdentityCommands: [billing_UpdateIdentityCommand!]
	updateContractInsuredIndividualCommands: [billing_UpdateIndividualCommand!]
	updateContractInsuredObjectCommands: [billing_UpdateObjectCommand!]
	updateDiscountCommands: [billing_UpdateDiscountCommand!]
	updateLoadingCommands: [billing_UpdateLoadingCommand!]
	updateOtherContractHolderAddressCommands: [billing_UpdateAddressCommand!]
	updateOtherContractHolderCompanyCommands: [billing_UpdateCompanyCommand!]
	updateOtherContractHolderContactCommands: [billing_UpdateContactCommand!]
	updateOtherContractHolderFactCommands: [billing_UpdateFactCommand!]
	updateOtherContractHolderIdentityCommands: [billing_UpdateIdentityCommand!]
	updateOtherContractHolderIndividualCommands: [billing_UpdateIndividualCommand!]
	updatePolicyCommands: [billing_UpdatePolicyCommand!]
	updatePolicyFactCommands: [billing_UpdateFactCommand!]
	upsertBenefitOptionCommands: [billing_UpsertBenefitOptionCommand!]
}

type billing_Entity {
	addresses: [billing_Address!]
	attachments: [billing_Attachment!]
	contacts: [billing_Contact!]
	createdAt: DateTime!
	createdById: String
	facts: [billing_Fact!]
	id: String
	identities: [billing_Identity!]
	internalCode: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	links: [billing_Link!]
	name: String
	notes: [billing_Note!]
	photoPath: String
	source: String
}

type billing_Exclusion {
	benefitOptionKey: String
	benefitParentTypeId: String
	benefitTypeId: String
	code: String
	createdAt: DateTime!
	createdById: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	remark: String
}

type billing_Fact {
	id: String
	type: String
}

type billing_FieldsDiff {
	changes: [billing_FieldsDiffItem!]
	diffType: billing_FieldsDiffType!
	objectId: String
	timeStamp: DateTime!
}

type billing_FieldsDiffItem {
	after: String
	before: String
	path: String
}

type billing_GeneratedFrom {
	caseId: String
	offerId: String
	proposalId: String
}

type billing_Identity {
	id: String
	type: String
	value: String
}

type billing_JacketEndorsementCommand {
	byId: String
	commandId: String
	endorsementId: String
	eventType: billing_PolicyEventType!
	timestamp: DateTime!
}

type billing_JacketInstance {
	id: String
	jacketId: String
	order: Int!
}

type billing_KeyValuePairOfStringAndObject {
	key: String!
}

type billing_KeyValuePairOfStringAndString {
	key: String!
	value: String!
}

type billing_Link {
	targetId: String
	type: String
	values: [billing_KeyValuePairOfStringAndObject!]
}

type billing_Loading {
	code: String
	createdAt: DateTime!
	createdById: String
	currencyCode: billing_CurrencyCode
	flat: Decimal
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	newPrice: Decimal
	order: Int!
	originalPrice: Decimal
	ratio: Decimal
}

type billing_ManualPaymentChannel implements billing_IPaymentChannel {
	fields: String
	holderId: String
	status: billing_ManualPaymentChannelStatus
	type: billing_PaymentChannelType!
}

type billing_Note {
	content: String
	createdAt: DateTime!
	createdById: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	title: String
}

type billing_Offer {
	benefitOptions: [billing_BenefitOption!]
	createdAt: DateTime!
	createdById: String
	exclusions: [billing_Exclusion!]
	id: String
	isPremiumOverridden: Boolean!
	lastModifiedAt: DateTime!
	lastModifiedById: String
	premium: billing_Premium
	productId: billing_ProductId
}

type billing_OpenAddressReadModel {
	id: UUID!
	typeName: String!
	typeVersion: Int
	version: Int
}

type billing_PaymentInfo {
	amount: Decimal!
	comment: String
	createdAt: DateTime!
	createdById: String
	currencyCode: billing_CurrencyCode!
	endDate: DateTime!
	frequency: billing_PaymentFrequency!
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	method: billing_PaymentMethodType!
	name: String
	payorId: String
	startDate: DateTime!
}

type billing_Policy {
	acceptedOfferId: String
	associatedContracts: [billing_AssociatedContract!]
	attachments: [billing_Attachment!]
	benefitOptions: [billing_BenefitOption!]
	cancellationReason: String
	cancelledById: String
	clauses: [billing_Clause!]
	clientId: String
	commissions: [billing_Commission!]
	contractBeneficiaryEligibilities: [billing_BeneficiaryEligibility!]
	contractHolder: billing_Entity
	contractInsured: [billing_Entity!]
	contractTerminated: [billing_Entity!]
	coolingOffExpiryDate: DateTime
	createdAt: DateTime!
	createdById: String
	description: String
	endDate: DateTime
	endorsements: [billing_Endorsement!]
	exclusions: [billing_Exclusion!]
	facts: [billing_Fact!]
	fieldsDiffs: [billing_FieldsDiff!]
	fieldsSchemaId: String
	generatedFrom: billing_GeneratedFrom
	id: String
	isCoolingOffSubmitted: Boolean
	isIssued: Boolean!
	isPremiumOverridden: Boolean!
	isPricingCacheAvailable: Boolean!
	isRenewal: Boolean!
	issueDate: DateTime
	issuedById: String
	issuerNumber: String
	jackets: [billing_JacketInstance!]
	lapseReason: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	notes: [billing_Note!]
	offers: [billing_Offer!]
	originalIssuerNumber: String
	otherContractHolders: [billing_Entity!]
	paymentInfos: [billing_PaymentInfo!]
	premium: billing_Premium
	previousPolicyIds: [String!]
	productId: billing_ProductId
	productTreeId: String
	productTreeRecords: [billing_ProductTreeRecord!]
	referralCode: String
	rejectedById: String
	rejectionCodes: [String!]
	rejectionRemarks: String
	renewalNumber: String
	renewalVersion: Int
	source: String
	stakeholders: [billing_Stakeholder!]
	startDate: DateTime
	status: String
	tags: [billing_Tag!]
	transformedById: String
}

type billing_Premium {
	amount: Decimal
	appliedDiscounts: [billing_Discount!]
	appliedTaxes: [billing_Tax!]
	currencyCode: billing_CurrencyCode
	discountCodes: [String!]
	discounts: [billing_Discount!]
	isPricedAtStartDate: Boolean!
	loadings: [billing_Loading!]
	metadata: String
	originalPrice: Decimal
	paymentFrequency: billing_PaymentFrequency!
}

type billing_PremiumToUpdate {
	amount: Decimal
	currencyCode: billing_CurrencyCode
	discountCodes: [String!]
	grossAmount: Decimal
	isAmountChanged: Boolean!
	isCurrencyCodeChanged: Boolean!
	isDiscountCodesChanged: Boolean!
	isGrossAmountChanged: Boolean!
	isIsPricedAtStartDateChanged: Boolean!
	isPricedAtStartDate: Boolean!
}

type billing_ProductId {
	plan: String
	type: String
	version: String
}

type billing_ProductIdToUpdate {
	isPlanChanged: Boolean!
	isTypeChanged: Boolean!
	isVersionChanged: Boolean!
	plan: String
	type: String
	version: String
}

type billing_ProductTreeRecord {
	recordId: String
	type: String
}

type billing_Range {
	exclusiveMaximum: Boolean!
	exclusiveMinimum: Boolean!
	maximum: Float!
	minimum: Float!
}

type billing_RemoveAssociatedContractCommand {
	commandId: String
	endorsementId: String
	id: String
	offerId: String
	proposalId: String
	removedById: String
	timestamp: DateTime!
}

type billing_RemoveBenefitOptionCommand {
	commandId: String
	endorsementId: String
	offerId: String
	removedById: String
	timestamp: DateTime!
	typeId: String
}

type billing_RemoveClauseCommand {
	clauseId: String
	endorsementId: String
	removedById: String
	timestamp: DateTime!
}

type billing_RemoveCommand {
	commandId: String
	endorsementId: String
	id: String
	removedById: String
	timestamp: DateTime
}

type billing_RemoveEntityPrimitiveCommand {
	commandId: String
	endorsementId: String
	entityId: String
	primitiveId: String
	removedById: String
	timestamp: DateTime!
}

type billing_RenderParameters {
	accessToken: String
	name: String
}

type billing_Stakeholder {
	entityId: String
	id: String
	type: String
}

type billing_Tag {
	id: String
	type: String
}

type billing_Tax {
	code: String
	createdAt: DateTime!
	createdById: String
	currencyCode: billing_CurrencyCode!
	flat: Decimal!
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	newPrice: Decimal!
	order: Int!
	originalPrice: Decimal!
	ratio: Decimal!
}

type billing_UpdateAddressCommand {
	commandId: String
	endorsementId: String
	entityId: String
	fields: [billing_KeyValuePairOfStringAndString!]
	id: String
	modifiedById: String
	timestamp: DateTime!
	type: String
}

type billing_UpdateClauseCommand {
	clauseId: String
	endorsementId: String
	htmlOverride: String
	isHtmlOverrideChanged: Boolean!
	isOrderChanged: Boolean!
	isRenderParametersChanged: Boolean!
	isTemplateChanged: Boolean!
	isTemplateIdChanged: Boolean!
	modifiedById: String
	order: Int!
	renderParameters: billing_RenderParameters
	templateId: String
	timestamp: DateTime!
}

type billing_UpdateCompanyCommand {
	acceptsMarketing: Boolean
	commandId: String
	endorsementId: String
	entityId: String
	id: String
	internalCode: String
	isAcceptsMarketingChanged: Boolean!
	isIdChanged: Boolean!
	isInternalCodeChanged: Boolean!
	isNameFormatChanged: Boolean!
	isNatureOfBusinessChanged: Boolean!
	isPhotoPathChanged: Boolean!
	isRegistrationNumberChanged: Boolean!
	isSourceChanged: Boolean!
	modifiedById: String
	nameFormat: String
	natureOfBusiness: String
	photoPath: String
	registrationNumber: String
	source: String
	timestamp: DateTime!
}

type billing_UpdateContactCommand {
	commandId: String
	endorsementId: String
	entityId: String
	id: String
	modifiedById: String
	timestamp: DateTime!
	type: String
	value: String
}

type billing_UpdateDiscountCommand {
	commandId: String
	discountId: String
	endorsementId: String
	isCalculationJsonLogicChanged: Boolean!
	isNameChanged: Boolean!
	isOrderChanged: Boolean!
	modifiedById: String
	name: String
	offerId: String
	order: Int!
	timestamp: DateTime!
}

type billing_UpdateFactCommand {
	commandId: String
	endorsementId: String
	entityId: String
	id: String
	modifiedById: String
	timestamp: DateTime!
	type: String
}

type billing_UpdateIdentityCommand {
	commandId: String
	endorsementId: String
	entityId: String
	id: String
	modifiedById: String
	timestamp: DateTime!
	type: String
	value: String
}

type billing_UpdateIndividualCommand {
	acceptsMarketing: Boolean
	chineseFirstName: String
	chineseLastName: String
	commandId: String
	countryOfResidency: String
	dateOfBirth: DateTime
	employmentStatus: String
	endorsementId: String
	englishFirstName: String
	englishLastName: String
	entityId: String
	gender: String
	id: String
	incomeRange: billing_Range
	internalCode: String
	isAcceptsMarketingChanged: Boolean!
	isChineseFirstNameChanged: Boolean!
	isChineseLastNameChanged: Boolean!
	isCountryOfResidencyChanged: Boolean!
	isDateOfBirthChanged: Boolean!
	isEmploymentStatusChanged: Boolean!
	isEnglishFirstNameChanged: Boolean!
	isEnglishLastNameChanged: Boolean!
	isGenderChanged: Boolean!
	isIdChanged: Boolean!
	isIncomeRangeChanged: Boolean!
	isInternalCodeChanged: Boolean!
	isMaritalStatusChanged: Boolean!
	isNameFormatChanged: Boolean!
	isOccupationChanged: Boolean!
	isPhotoPathChanged: Boolean!
	isPreferredCommunicationChannelChanged: Boolean!
	isPreferredLanguageChanged: Boolean!
	isSalutationChanged: Boolean!
	isSourceChanged: Boolean!
	maritalStatus: String
	modifiedById: String
	nameFormat: String
	occupation: String
	photoPath: String
	preferredCommunicationChannel: String
	preferredLanguage: String
	salutation: String
	source: String
	timestamp: DateTime!
}

type billing_UpdateLoadingCommand {
	code: String
	commandId: String
	endorsementId: String
	flat: Decimal
	id: String
	isCalculationJsonLogicChanged: Boolean!
	isCodeChanged: Boolean!
	isFlatChanged: Boolean!
	isOrderChanged: Boolean!
	isRatioChanged: Boolean!
	modifiedById: String
	offerId: String
	order: Int!
	ratio: Decimal
	timestamp: DateTime!
}

type billing_UpdateObjectCommand {
	commandId: String
	endorsementId: String
	entityId: String
	id: String
	internalCode: String
	isIdChanged: Boolean!
	isInternalCodeChanged: Boolean!
	isNameFormatChanged: Boolean!
	isPhotoPathChanged: Boolean!
	isSourceChanged: Boolean!
	isTypeIdChanged: Boolean!
	modifiedById: String
	nameFormat: String
	photoPath: String
	source: String
	timestamp: DateTime!
	typeId: String
}

type billing_UpdatePolicyCommand {
	commandId: String
	contractHolderCompany: billing_UpdateCompanyCommand
	contractHolderIndividual: billing_UpdateIndividualCommand
	description: String
	endDate: DateTime
	endorsementId: String
	extraFields: String
	fields: String
	fieldsPatch: String
	fieldsSchemaId: String
	holderId: String
	id: String
	insuredIds: [String!]
	isContractHolderCompanyChanged: Boolean!
	isContractHolderIndividualChanged: Boolean!
	isCoolingOffSubmitted: Boolean
	isDescriptionChanged: Boolean!
	isEndDateChanged: Boolean!
	isExtraFieldsChanged: Boolean!
	isFieldsChanged: Boolean!
	isFieldsSchemaIdChanged: Boolean!
	isHolderIdChanged: Boolean!
	isInsuredIdsChanged: Boolean!
	isIsCoolingOffSubmittedChanged: Boolean!
	isIssueDateChanged: Boolean!
	isIssuerNumberChanged: Boolean!
	isLapseReasonChanged: Boolean!
	isPremiumChanged: Boolean!
	isPremiumOverridden: Boolean
	isProductIdChanged: Boolean!
	isReferralCodeChanged: Boolean!
	isSourceChanged: Boolean!
	isStartDateChanged: Boolean!
	isStatusChanged: Boolean!
	isValuesChanged: Boolean!
	issueDate: DateTime
	issuerNumber: String
	lapseReason: String
	modifiedById: String
	premium: billing_PremiumToUpdate
	productId: billing_ProductIdToUpdate
	referralCode: String
	source: String
	startDate: DateTime
	status: String
	timestamp: DateTime!
}

type billing_UpsertBenefitOptionCommand {
	commandId: String
	currencyCode: billing_CurrencyCode!
	endorsementId: String
	insuredId: String
	key: String
	offerId: String
	timestamp: DateTime!
	typeId: String
	upsertedById: String
}

type binder {
	bindingDate: Date
	commissionRule: commissionRule
	createdAt: DateTime
	createdBy: login
	endDate: Date
	facts: [fact!]!
	firstParty: organization
	id: ID!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	otherIds: [otherId]!
	secondParty: organization
	startDate: Date
	status: String
}

"Gets all binders"
type binders {
	list: [binder]
	totalCount: Int!
}

type buckets {
	bucketName: String!
	providerId: String
}

type cardPaymentMethod implements paymentMethodInterface {
	brand: String
	cardholderName: String
	createdAt: DateTime
	createdBy: login
	entityId: String
	expMonth: Int
	expYear: Int
	id: String!
	last4: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
}

"a case"
type case {
	beneficiaryEligibilities: [beneficiaryEligibility]
	caseNumber: String
	component: component
	createdAt: DateTime
	createdBy: login
	description: String
	events: [detailedEventLog]
	facts: [fact]
	fields: String
	fieldsSchema: dataSchema
	holder: entityInterface
	id: String!
	insureds: [entityInterface]
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	notes: [note]
	otherHolders: [entityInterface]
	paymentInfos: [paymentInfo]
	proposals(
		"the proposal where input"
		where: proposalWhere
	): [proposal]
	source: String
	stakeholders: [stakeholder]
	status: String
	workflowSchema: dataSchema
}

"a report for cases"
type caseReport {
	reportFields: String
}

"Gets all cases"
type cases {
	list: [case]
	totalCount: Int!
}

"Gets all cases"
type casesReport {
	list: [caseReport]
	totalCount: Int!
}

type cases_Broker {
	channel: String
	code: String
	contactPerson: String
	contactPersonEmail: String
	contactPersonFaxNo: String
	contactPersonTelNo: String
	createdAt: DateTime!
	createdById: String
	fields: String
	group: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
}

type cases_Counter {
	counters: [cases_KeyValuePairOfStringAndInt64!]
	createdAt: DateTime!
	createdById: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	scope: String
}

type cases_CreatedStatus {
	id: String
	ids: [String]
}

type cases_Error {
	code: String
	message: String
}

type cases_GenericBroker8QueryInterface {
	list: [cases_Broker]
	totalCount: Long!
}

type cases_GenericCounter8QueryInterface {
	list: [cases_Counter]
	totalCount: Long!
}

type cases_KeyValuePairOfStringAndInt64 {
	key: String!
	value: Long!
}

type cases_Result {
	errors: [String]
	errors_2: [cases_Error]
	isSuccess: Boolean!
	status: String
}

type cases_ResultOfCreatedStatus {
	errors: [String]
	errors_2: [cases_Error]
	isSuccess: Boolean!
	status: String
	value: cases_CreatedStatus
}

type cases_ResultOfInt64 {
	errors: [String]
	errors_2: [cases_Error]
	isSuccess: Boolean!
	status: String
	value: Long!
}

"A chat message"
type chatMessage {
	attachements: [String]
	content: String
	fromName: String
}

"claim"
type claim {
	attachments: [attachment]
	benefitClaims: [benefitClaim]
	claimApprover: login
	claimBalance: [benefit]
	claimHandler: login
	claimant: customerInterface
	createdAt: DateTime
	createdBy: login
	diagnosisCodes: [diagnosisCodeName]
	events: [claimEventLog]
	exportBatchIds: [batchId]
	facts: [fact]
	fields: String
	guaranteeOfPayments: [guaranteeOfPayment]
	id: ID
	importBatchId: batchId
	issuerNumber: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	notes: [note]
	operationCodes: [operationCodeName]
	panel: organization
	policy: policy
	policyMember: policyMember
	provider: entityInterface
	rejectedBy: login
	rejectionCodes: [rejectionCodeName]
	rejectionReasons: [rejectionReason]
	rejectionRemarks: String
	remark: String
	reversals: [claimReversal]
	stakeholders: [stakeholder]
	status: String
	totalValues: claimValue
	transactions: [transaction]
}

"A log of claim event"
type claimEventLog {
	by: login
	id: String!
	timestamp: DateTime!
	type: String!
	updateType: String
}

"claimReport"
type claimReport {
	claimSnapshots(
		"A claim snapshot search filter"
		where: claimSnapshotFilterInput
	): [claimSnapshot]
	createdAt: DateTime
	createdBy: login
	id: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	reportDate: DateTime
}

type claimReports {
	list: [claimReport]
	totalCount: Int!
}

type claimReversal {
	reason: String!
	reversedAt: DateTime!
	reversedBy: login!
}

type claimSettings {
	diagnosisSettings: diagnosisSettings
	operationSettings: operationSettings
	providerSettings: providerSettings
	rejectionSettings: rejectionSettings
}

"A claim snapshot at the time when we generate the claim report"
type claimSnapshot {
	approvedDate: DateTime
	claimApprover: String
	claimHandler: String
	claimId: String
	claimNo: String
	claimSettlementMode: String
	claimType: String
	claimantInternalCode: String
	claimantName: String
	companyBankAccount: String
	companyBankCode: String
	companyName: String
	createdAt: DateTime
	employeeBankAccount: String
	employeeBankCode: String
	employeeInternalCode: String
	employeeName: String
	exportBatchNumber: String
	formReceivedDate: DateTime
	hasReversal: Boolean
	id: String
	incurredDate: DateTime
	invoiceNo: String
	isPanel: Boolean
	panelAccountHolder: String
	panelBankAccount: String
	panelBankCode: String
	panelBankName: String
	panelBranchCode: String
	panelName: String
	panelP400ClientNumber: String
	policyHolder: String
	policyNo: String
	settlementDate: DateTime
	settlementFollowingWorkingDate: DateTime
	status: String
	totalAmountToPay: Decimal
	totalBilledAmount: Decimal
	totalIncurredAmount: Decimal
}

"The value of the claim"
type claimValue {
	approvedAmount: Decimal
	approvedCurrency: currencyCodeEnumeration
	billedAmount: Decimal
	billedCurrency: currencyCodeEnumeration
	formattedApprovedAmount: String
	formattedBilledAmount: String
	unit: String
}

"Gets all claims"
type claims {
	list: [claim]
	totalCount: Int!
}

type claims_ApprovalWarning {
	claimIds: [String]
	message: String
}

type claims_AttachedRulesQueryInterfaceOfclaimsAttachedCommandPermissionAndclaims_AttachedRuleFilter {
	count: Long!
	list: [claims_claimsAttachedCommandPermission]
}

type claims_AttachedRulesQueryInterfaceOfclaimsAttachedExternalApiCallAndclaims_AttachedRuleFilter {
	count: Long!
	list: [claims_claimsAttachedExternalApiCall]
}

type claims_AttachedRulesQueryInterfaceOfclaimsAttachedFilterAndclaims_AttachedRuleFilter {
	count: Long!
	list: [claims_claimsAttachedFilter]
}

type claims_AttachedRulesQueryInterfaceOfclaimsAttachedObjectValidationAndclaims_AttachedRuleFilter {
	count: Long!
	list: [claims_claimsAttachedObjectValidation]
}

type claims_AttachedRulesQueryInterfaceOfclaimsAttachedPostHandleValidationAndclaims_AttachedRuleFilter {
	count: Long!
	list: [claims_claimsAttachedPostHandleValidation]
}

type claims_AuthorityLimit {
	approvalExpenseLimit: Decimal!
	approvalPaymentLimit: Decimal!
	createdAt: DateTime!
	createdById: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	permissionGroupId: String
	reserveExpenseLimit: Decimal!
	reservePaymentLimit: Decimal!
}

type claims_ClaimDataInsight {
	averageSubmittedClaimsPerTotalActiveMembers: Float!
	clientTimezone: String
	companyId: String
	from: DateTime!
	id: String
	lastUpdatedAt: DateTime!
	policyId: String
	to: DateTime!
	totalActiveMembers: Long!
	totalIncurredAmount: Decimal!
	totalPaidAmount: Decimal!
	totalSettledInpatientClaims: Int!
	totalSettledOutpatientClaims: Int!
	totalSubmittedClaims: Int!
	totalSubmittedClaimsExcludePanelAndClosed: Int!
	totalSubmittedMembersSubmittedMoreThanOneClaims: Int!
	totalSubmittedPanelClaims: Int!
	type: claims_ClaimDataInsightGroupByType!
}

type claims_ClaimRejectionCode {
	code: String
	description: String
	fields: String
	id: String
}

type claims_ClaimRejectionReason {
	code: String
	fields: String
	id: String
	type: String
}

type claims_ClaimRequestReason {
	code: String
	fields: String
	id: String
	type: String
}

type claims_CreatedStatus {
	id: String
	ids: [String]
}

type claims_Error {
	code: String
	message: String
}

type claims_ExternalApiCall {
	afterCall: [String!]
	beforeCall: [String!]
	contentType: String
	contextSlug: String
	expectedContentExpression: String
	expectedResponseExpression: String
	headers: [claims_KeyValuePairOfStringAndString!]
	itemValidationExpression: String
	method: String!
	stringContent: String
	timeout: String
	url: String!
}

type claims_GenericAuthorityLimit8QueryInterface {
	list: [claims_AuthorityLimit]
	totalCount: Long!
}

type claims_GenericClaimRejectionCode8QueryInterface {
	list: [claims_ClaimRejectionCode]
	totalCount: Long!
}

type claims_GenericClaimRejectionReason8QueryInterface {
	list: [claims_ClaimRejectionReason]
	totalCount: Long!
}

type claims_GenericClaimRequestReason8QueryInterface {
	list: [claims_ClaimRequestReason]
	totalCount: Long!
}

type claims_GenericPreExistingCondition8QueryInterface {
	list: [claims_PreExistingCondition]
	totalCount: Long!
}

type claims_KeyValuePairOfStringAndString {
	key: String!
	value: String!
}

type claims_PreExistingCondition {
	category: String
	classification: String
	code: String
	description: String
	disease: String
	diseaseLevel: String
	id: String
	profile: String
	risk: String
	specialty: String
	subClassification: String
	summary: String
	typeOfDisease: String
}

type claims_Result {
	errors: [String]
	errors_2: [claims_Error]
	isSuccess: Boolean!
	status: String
}

type claims_ResultOfCreatedStatus {
	errors: [String]
	errors_2: [claims_Error]
	isSuccess: Boolean!
	status: String
	value: claims_CreatedStatus
}

type claims_ResultOfIEnumerableOfApprovalWarning {
	errors: [String]
	errors_2: [claims_Error]
	isSuccess: Boolean!
	status: String
	value: [claims_ApprovalWarning]
}

type claims_ResultOfListOfClaimDataInsight {
	errors: [String]
	errors_2: [claims_Error]
	isSuccess: Boolean!
	status: String
	value: [claims_ClaimDataInsight]
}

type claims_ResultOfString {
	errors: [String]
	errors_2: [claims_Error]
	isSuccess: Boolean!
	status: String
	value: String
}

type claims_ScriptError {
	code: String
	message: String
}

type claims_ScriptResult {
	errors: [String]
	errors_2: [claims_ScriptError]
	status: String
	value: String
}

type claims_claimsAttachedCommandPermission {
	action: claims_AttachedRuleAllowAction!
	command: String!
	commandExpression: String
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

type claims_claimsAttachedExternalApiCall {
	apiCalls: [claims_ExternalApiCall!]!
	description: String
	eventExpression: String
	forEach: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

type claims_claimsAttachedFilter {
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

type claims_claimsAttachedObjectValidation {
	action: claims_AttachedRuleAllowAction!
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

type claims_claimsAttachedPostHandleValidation {
	action: claims_AttachedRuleAllowAction!
	description: String
	eventExpression: String
	group: Int!
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

type clause {
	htmlOverride: String
	id: String
	order: Int
	renderParameters: templateRenderParameters
	renderedHtmlResult: stringResult
	storeTemplateByValue: Boolean!
	template: templateInterface
	type: String
}

type clauseHtml implements templateInterface {
	createdAt: DateTime
	createdBy: login
	description: String
	events: [eventLog]
	graphQlQuery: String
	html: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	logicalId: String
	name: String
	order: Int
	status: String
	tags: [String]!
	type: String
}

type client {
	description: String
	id: ID
	name: String
}

type cmsComponentRoute {
	children: cmsComponentRoute
	component: String
	metaJsonString: String
	name: String
	path: String
	propsJsonString: String
	redirect: String
}

type cmsConfig {
	allowedLocales: [String!]
	analyticsProvidersJsonString: String
	app: app
	appId: String
	baseComponentsVariantsJsonString: String
	componentRoutes: [cmsComponentRoute!]
	defaultLocale: String
	endpointsJsonString: String
	guestLoginCredentials: cmsGuestLoginCredentials
	head: cmsHeadConfig
	httpHeadersJsonString: String
	paymentProvidersJsonString: String
	tenantId: String!
	themeJsonString: String
}

type cmsConfigResult {
	errors: [String]
	errors_2: [errors!]
	status: String
	value: cmsConfig
}

type cmsGuestLoginCredentials {
	password: String!
	username: String!
}

type cmsHeadConfig {
	linkJsonString: String
	metaJsonString: String
	noScript: [cmsScriptConfig!]
	script: [cmsScriptConfig!]
	title: String
}

type cmsScriptConfig {
	afterLoad: Boolean
	async: Boolean
	body: Boolean
	defer: Boolean
	innerHTML: String
	src: String
	type: String
}

type commission {
	amount: Decimal
	baseCommissionRatio: commissionRatio
	createdAt: DateTime
	createdBy: login
	currencyCode: currencyCodeEnumeration
	entity: entityInterface
	id: String!
	jsonRule: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	ratio: Decimal
	remark: String
	type: String
}

type commissionRatio {
	commission: commission
	ratio: Decimal!
}

type commissionRule {
	createdAt: DateTime
	createdBy: login
	description: String
	entities: [entityInterface]
	id: String!
	jsonRule: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	product: product
}

type companies {
	list: [company]
	totalCount: Int!
}

"A company"
type company implements customerInterface & entityInterface {
	acceptsMarketing: Boolean
	achievements: [achievement]
	addresses: [address]
	associatedLogin: login
	attachments: [attachment]
	beneficiaryOf: [policy]
	caseHolderOf: [case]
	contacts: [contact]
	courseProgressions(
		"a course progression filter"
		where: courseProgressionWhereInput
	): [courseProgression]
	createdAt: DateTime
	createdBy: login
	entityType: String
	events: [eventLog]
	facts: [fact]
	fields: String
	holderOf: [policy]
	id: String!
	identities: [identity]
	insuredBy: [policy]
	internalCode: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	migrationBatchId: String
	name: String
	natureOfBusiness: String
	notes: [note]
	notificationList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): notifications
	notifications(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): [notification]
	paymentMethods: [paymentMethodInterface]
	photoPath: String
	registrationNumber: String
	relationshipList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): relationships
	relationships(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): [relationship]
	reviews(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: reviewWhereInput
	): reviews
	source: String
	stakeholders: [stakeholder]
	status: String
	subscriptions: [subscription]
	tags: [String]
	uninsuredBy: [policy]
}

type component {
	componentJson: String!
	createdAt: DateTime
	createdBy: login
	id: ID
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String!
	status: componentStatusEnumeration!
	version: componentVersion
	vueTemplate: String!
}

type componentVersion {
	framework: String!
	version: String!
}

type components {
	list: [component]
	totalCount: Int!
}

type condition {
	jsonLogicRuleString: String
	type: String
}

type connectedChatUsers {
	loginIdToUserName: [String]
	topicName: String
}

"A user's contact detail (customer or internal user)"
type contact {
	id: String!
	type: String!
	value: String
}

"course"
type course {
	categories: [String]
	createdAt: DateTime
	createdBy: login
	description: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	sections: [section]
	version: String
}

"Course Progression"
type courseProgression {
	course: course
	createdAt: DateTime
	createdBy: login
	entity: entityInterface
	id: String!
	isPassed: Boolean
	lastModifiedAt: DateTime
	lastModifiedBy: login
	lessonsCompletions: [LessonCompletion]
	score: Float
}

"Gets all courses"
type courses {
	list: [course]
	totalCount: Int!
}

"A created status"
type createdStatus {
	"The id of the created object"
	id: String
	"The ids of the created objects"
	ids: [String]
}

"A result object with a created status object and potential errors"
type createdStatusResult {
	createdStatus: createdStatus
	errors: [String!]
	status: String
}

type dataSchema {
	createdAt: DateTime
	createdBy: login
	description: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	schema: String
	standard: dataSchemaStandard
	tags: [String]
	type: String
	uiSchemas(where: uiSchemaWhereInput): [uiSchema!]
}

type dataSchemaStandard {
	type: dataSchemaStandardTypeEnum
	version: String
}

type dataSchemas {
	list: [dataSchema]
	totalCount: Int
}

"A result object with a datetime and potential errors"
type dateResult {
	date: Date
	errors: [String!]
	status: String
}

"A log of event with detailed values"
type detailedEventLog {
	by: login
	id: String!
	timestamp: DateTime!
	type: String!
	value: scalarValue
	valueAsString: String
}

type diagnoses {
	list: [diagnosis]
	totalCount: Int!
}

type diagnosis {
	chapter: String
	classKind: String
	code: String
	depthInKind: Int
	fields: String
	id: String
	title: String
}

type diagnosisCodeName {
	code: String!
	description: String
	name: String
}

"The product diagnosis settings"
type diagnosisSettings {
	codeNames: [diagnosisCodeName]
}

type disabilities {
	list: [disability]
	totalCount: Int!
}

"Disability"
type disability {
	diagnoses(
		"A disability search filter"
		filter: diagnosisFilterInput,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput
	): [diagnosis]
	id: String
	name: String
}

type discount {
	calculationLogic: String
	code: String
	createdAt: DateTime
	createdBy: login
	flat: Decimal
	formattedFlat: String
	formattedNewPrice: String
	formattedOriginalPrice: String
	id: String
	isManual: Boolean!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	newPrice: Decimal
	order: Int
	originalPrice: Decimal
	ratio: Decimal
}

type displayedBenefitCategory {
	id: String!
	typeIds: [String!]!
}

type displayedBenefits {
	benefitCategories: [displayedBenefitCategory]
	productType: String!
}

type displayedInsurers {
	insurerIds: [String!]!
	productType: String!
}

type displayedProducts {
	productIds: [productId]!
	type: String!
}

type dynamicTemplate implements templateInterface {
	createdAt: DateTime
	createdBy: login
	description: String
	dynamicValues: [dynamicValue]
	events: [eventLog]
	graphQlQuery: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	logicalId: String
	name: String
	tags: [String]!
	type: String
}

type dynamicValue {
	value: scalarValue
	valueId: String!
	valueJsonString: String
}

type emailAttachment {
	bytes: [Byte]
	fileName: String!
}

type emailConfig {
	bccs: [String]
	ccs: [String]
	emailName: String!
	emailSender: String!
}

"An email message"
type emailMessage {
	bccs: [String]
	ccs: [String]
	from: String
	fromName: String
	htmlContent: String
	pdfAttachments: [pdfAttachment]
	replyTo: String
	replyToName: String
	subject: String!
	templateRendering: templateRendering
	to: String
}

type emailMjmlTemplate implements templateInterface {
	attachmentReferences: [attachmentReference]
	attachmentTemplates: [attachmentTemplate]
	createdAt: DateTime
	createdBy: login
	description: String
	events: [eventLog]
	graphQlQuery: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	logicalId: String
	mjml: String!
	name: String
	subject: String
	tags: [String]!
	type: String
}

type emailRendered {
	attachments: [emailAttachment]
	html: String
}

type emailRenderedResult {
	errors: [String]
	status: String!
	value: emailRendered
}

type endorsement {
	addAssociatedContractCommands: [addAssociatedContractCommandGraph]
	addClauseCommands: [addClauseCommand]
	addContractHolderAddressCommands: [addAddressCommand]
	addContractHolderContactCommands: [addContactCommand]
	addContractHolderFactCommands: [AddFactCommandGraphType]
	addContractHolderIdentityCommands: [addIdentityCommand]
	addContractInsuredAddressCommands: [addAddressCommand]
	addContractInsuredCommands: [addEntityCommand]
	addContractInsuredContactCommands: [addContactCommand]
	addContractInsuredFactCommands: [AddFactCommandGraphType]
	addContractInsuredIdentityCommands: [addIdentityCommand]
	addDiscountCommands: [addDiscountCommand]
	addLoadingCommands: [addLoadingCommand]
	addOtherContractHolderAddressCommands: [addAddressCommand]
	addOtherContractHolderCommands: [addEntityCommand]
	addOtherContractHolderContactCommands: [addContactCommand]
	addOtherContractHolderFactCommands: [AddFactCommandGraphType]
	addOtherContractHolderIdentityCommands: [addIdentityCommand]
	addPolicyFactCommands: [AddFactCommandGraphType]
	afterEndorsement: policy
	beforeEndorsement: policy
	cancellationMotive: String
	createdAt: DateTime
	createdBy: login
	effectiveDate: DateTime
	endorsementDate: DateTime
	id: String!
	isApproved: Boolean!
	isRejected: Boolean!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	policy: policy
	reasonOfChange: String
	removeAssociatedContractCommands: [removeAssociatedContractCommandGraph]
	removeBenefitOptionCommands: [removeBenefitOptionCommand]
	removeContractHolderAddressCommands: [removeCommand]
	removeContractHolderContactCommands: [removeCommand]
	removeContractHolderFactCommands: [removeCommand]
	removeContractHolderIdentityCommands: [removeCommand]
	removeContractInsuredAddressCommands: [removeEntityPrimitiveCommand]
	removeContractInsuredCommands: [removeCommand]
	removeContractInsuredContactCommands: [removeEntityPrimitiveCommand]
	removeContractInsuredFactCommands: [removeEntityPrimitiveCommand]
	removeContractInsuredIdentityCommands: [removeEntityPrimitiveCommand]
	removeDiscountCommands: [removeCommand]
	removeLoadingCommands: [removeCommand]
	removeOtherContractHolderAddressCommands: [removeEntityPrimitiveCommand]
	removeOtherContractHolderCommands: [removeCommand]
	removeOtherContractHolderContactCommands: [removeEntityPrimitiveCommand]
	removeOtherContractHolderFactCommands: [removeEntityPrimitiveCommand]
	removeOtherContractHolderIdentityCommands: [removeEntityPrimitiveCommand]
	removePolicyFactCommands: [removeCommand]
	source: endorsementSource
	status: String
	submissionDate: DateTime
	transactions: [transaction]
	type: String
	updateContractHolderAddressCommands: [updateAddressCommand]
	updateContractHolderContactCommands: [updateContactCommand]
	updateContractHolderFactCommands: [updateFactCommand]
	updateContractHolderIdentityCommands: [updateIdentityCommand]
	updateContractInsuredAddressCommands: [updateAddressCommand]
	updateContractInsuredCompanyCommands: [updateContractCompanyCommand]
	updateContractInsuredContactCommands: [updateContactCommand]
	updateContractInsuredFactCommands: [updateFactCommand]
	updateContractInsuredIdentityCommands: [updateIdentityCommand]
	updateContractInsuredIndividualCommands: [updateContractIndividualCommand]
	updateContractInsuredObjectCommands: [updateContractObjectCommand]
	updateDiscountCommands: [updateDiscountCommand]
	updateLoadingCommands: [updateLoadingCommand]
	updateOtherContractHolderAddressCommands: [updateAddressCommand]
	updateOtherContractHolderCompanyCommands: [updateContractCompanyCommand]
	updateOtherContractHolderContactCommands: [updateContactCommand]
	updateOtherContractHolderFactCommands: [updateFactCommand]
	updateOtherContractHolderIdentityCommands: [updateIdentityCommand]
	updateOtherContractHolderIndividualCommands: [updateContractIndividualCommand]
	updatePolicyCommands: [updatePolicyGraphType]
	updatePolicyFactCommands: [updateFactCommand]
	upsertBenefitOptionCommands: [upsertBenefitOptionCommand]
}

type engine {
	id: String
	name: String
	runTime: String
	version: String
}

"Error codes and images"
type errors {
	code: String
	message: String
}

type evaluateScriptResult {
	errors: [String]
	status: String!
	value: String
}

"A log of events"
type eventLog {
	by: login
	id: String!
	timestamp: DateTime!
	type: String!
}

type excelRule {
	resultCell: resultCell
}

type exclusion {
	benefitOptionKey: String
	benefitParentTypeId: String
	benefitTypeId: String
	codeName: exclusionCodeName
	createdAt: DateTime
	createdBy: login
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	remark: String
}

type exclusionCodeName {
	code: String!
	name: String
}

"The product exclusion settings"
type exclusionSettings {
	codeNames: [exclusionCodeName]
}

type faceRecognitionOutput {
	value: scalarValue
	valueJsonString: String
}

type faceRecognitionResult {
	errors: [String!]
	status: String
	value: faceRecognitionOutput
}

"A fact"
type fact {
	id: String!
	type: String
	value: scalarValue
	values: scalarValue @deprecated(reason: "use 'Value'")
}

"A fact template"
type factTemplate {
	id: ID!
	name: String
	possibleValueTemplates: [possibleValueTemplate]
}

"An address field"
type field {
	type: String!
	value: String
}

type fieldsDiff {
	after: String
	before: String
	changes: [fieldsDiffItem]
	diffType: FieldsDiffType
	timeStamp: Date
}

type fieldsDiffItem {
	after: String
	before: String
	path: String
}

type fieldsWhere {
	condition: fieldsWhereCondition
	path: String!
	value: scalarValue
}

"Lists files and files summaries"
type fileListing {
	commonPrefixes: [String]
	continuationToken: String
	objectSummaries: [fileSummary]
}

type fileSummary {
	fileName: String!
	isPublic: Boolean!
	key: String!
	lastModifiedAt: DateTimeOffset
	metadata: [keyValue]
	size: Int!
}

type fileSystemConfig {
	accessKeyId: String
	accessKeySecret: String
	bucketName: String
	endpoint: String
	id: String!
	providerId: String
}

type filesystem_Error {
	code: String
	message: String
}

type filesystem_Result {
	errors: [String]
	errors_2: [filesystem_Error]
	isSuccess: Boolean!
	status: String
}

type font {
	emSize: Int!
	familyName: String!
	fontStyle: fontStyleInput
}

type functionInput {
	id: String
	liquid: String
	name: String
	type: String
	var: String
}

type functionOutput {
	id: String
	name: String
	valueJsonString: String
	var: String
}

"A result object with a created status object and potential errors"
type functionRenderOutput {
	errors: [String]
	status: String
	value: [functionOutput]
}

type functionTemplate implements templateInterface {
	createdAt: DateTime
	createdBy: login
	description: String
	engine: engine
	events: [eventLog]
	fileKey: String
	graphQlQuery: String
	id: String!
	inputs: [functionInput]
	lastModifiedAt: DateTime
	lastModifiedBy: login
	logicalId: String
	name: String
	outputs: [functionOutput]
	tags: [String]!
	type: String
}

"Ids of case, proposal and offer which the policy was generated from"
type generatedFrom {
	caseId: String!
	offerId: String!
	proposalId: String!
}

"guaranteeOfPayment"
type guaranteeOfPayment {
	approvedAmount: Decimal
	approvedAt: DateTime
	approvedBy: login
	attachments: [attachment]
	createdAt: DateTime
	createdBy: login
	currencyCode: currencyCodeEnumeration
	doctor: String
	estimatedAmount: Decimal
	events: [guaranteeOfPaymentEventLog]
	excessAmount: Decimal
	fields: String
	id: ID
	issuerNumber: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	member: customerInterface
	notes: [note]
	policy: policy
	provider: entityInterface
	providerId: String
	rejectedAt: DateTime
	rejectedBy: login
	rejectionCodes: [rejectionCodeName]
	rejectionRemarks: String
	status: String
}

"A log of guarantee of payment event"
type guaranteeOfPaymentEventLog {
	by: login
	timestamp: DateTime!
	type: String!
	updateType: String
}

"Gets all guarantee of payments"
type guaranteeOfPayments {
	list: [guaranteeOfPayment]
	totalCount: Int!
}

type headerFooter {
	center: String
	fontName: String
	fontSize: Int
	htmUrl: String
	html: String
	left: String
	line: Boolean
	right: String
	spacing: Float
}

"A user's identity (customer or internal user)"
type identity {
	id: String!
	type: String!
	value: String
}

type illustration {
	description: String
	id: String!
	name: String
	points: [point!]
}

type indicativePrice {
	amount: Decimal!
	appliedDiscounts: [discount]
	appliedTaxes: [tax]
	currencyCode: currencyCodeEnumeration
	discounts: [discount]
	formattedOriginalPrice: String
	formattedPrice: String!
	originalPrice: Decimal!
	type: String!
}

"An individual"
type individual implements customerInterface & entityInterface {
	acceptsMarketing: Boolean
	achievements: [achievement]
	addresses: [address]
	associatedLogin: login
	attachments: [attachment]
	beneficiaryOf: [policy]
	caseHolderOf: [case]
	chineseFirstName: String
	chineseLastName: String
	contacts: [contact]
	countryOfResidency: String
	courseProgressions(
		"a course progression filter"
		where: courseProgressionWhereInput
	): [courseProgression]
	createdAt: DateTime
	createdBy: login
	dateOfBirth: Date
	disabilities(
		"A disability search filter"
		filter: disabilityFilterInput,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput
	): [disability]
	email: String
	employmentStatus: String
	englishFirstName: String
	englishLastName: String
	entityType: String
	events: [eventLog]
	facts: [fact]
	fields: String
	gender: String
	hasActivePolicy: Boolean
	holderOf: [policy]
	id: String!
	identities: [identity]
	incomeRange: range
	insuredBy: [policy]
	integrations: [integration]
	internalCode: String
	kyc: kyc
	lastModifiedAt: DateTime
	lastModifiedBy: login
	maritalStatus: String
	name: String
	notes: [note]
	notificationList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): notifications
	notifications(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): [notification]
	occupation: String
	paymentMethods: [paymentMethodInterface]
	photoPath: String
	preferredCommunicationChannel: String
	preferredLanguage: String
	relationshipList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): relationships
	relationships(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): [relationship]
	reviews(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: reviewWhereInput
	): reviews
	salutation: String
	source: String
	stakeholders: [stakeholder]
	status: String
	subscriptions: [subscription]
	tags: [String]
	telephoneNumber: String
	type: individualTypeEnumeration
	uninsuredBy: [policy]
}

"An individuals agent code"
type individualAgentCode {
	englishFirstName: String
	englishLastName: String
	fields: String
	source: String
}

type individuals {
	list: [individual]
	totalCount: Int!
}

type individualsAgentCode {
	list: [individualAgentCode]
	totalCount: Int!
}

type insurer {
	createdAt: DateTime
	createdBy: login
	detailedName: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	logoUrls: logoUrls
	name: String
	tenantId: String
}

type integration {
	"Entity id on the integrated system"
	externalEntityId: String
	"Product id on the integrated system"
	externalProductId: String
	"Integration id of the system"
	systemId: String
}

"An internal user"
type internal implements entityInterface {
	achievements: [achievement]
	addresses: [address]
	associatedLogin: login
	attachments: [attachment]
	chineseFirstName: String
	chineseLastName: String
	contacts: [contact]
	courseProgressions(
		"a course progression filter"
		where: courseProgressionWhereInput
	): [courseProgression]
	createdAt: DateTime
	createdBy: login
	description: String
	englishFirstName: String
	englishLastName: String
	entityType: String
	events: [eventLog]
	facts: [fact]
	fields: String
	gender: String
	id: String!
	identities: [identity]
	internalCode: String
	isActive: Boolean!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	notes: [note]
	notificationList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): notifications
	notifications(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): [notification]
	paymentMethods: [paymentMethodInterface]
	photoPath: String
	relationshipList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): relationships
	relationships(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): [relationship]
	reviews(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: reviewWhereInput
	): reviews
	source: String
	status: String
	subscriptions: [subscription]
	tags: [String]
	title: String
}

"An internal message"
type internalMessage {
	dataJsonString: String
	renderedHtml: String
}

"An internal review"
type internalReview {
	comment: String!
	createdAt: DateTime
	createdBy: login
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	status: String!
}

type internals {
	list: [internal]
	totalCount: Int!
}

type itemOption {
	createdAt: DateTime
	createdBy: login
	id: String!
	isCorrect: Boolean
	lastModifiedAt: DateTime
	lastModifiedBy: login
	localizedContent: String
}

"jacket"
type jacket {
	clauses(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput
	): [clause]
	createdAt: DateTime
	createdBy: login
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	status: String
	title: String
}

"The instance of jacket was added into offer"
type jacketInstance {
	createdAt: DateTime
	createdBy: login
	id: String!
	jacket: jacket
	lastModifiedAt: DateTime
	lastModifiedBy: login
	order: Int
	storedByValue: Boolean
}

"Gets all jackets"
type jackets {
	list: [jacket]
	totalCount: Int!
}

type jobDetail {
	asAppId: String
	asLoginId: String
	graphQlOperationType: String
	graphQlQuery: String
	graphQlVariables: String
	jobId: String
	type: String
}

type jobSchedule {
	createdAt: DateTime
	createdById: String
	cronExpression: String
	datacenterId: String
	description: String
	id: String!
	isActive: Boolean!
	jobDetail: jobDetail
	lastCheckedAt: DateTime
	lastModifiedAt: DateTime
	lastModifiedById: String
	name: String
	tenantId: String
}

type jobSchedules {
	list: [jobSchedule]
	totalCount: Int
}

type keyValue {
	key: String!
	value: scalarValue
}

"a kyc representation"
type kyc {
	providerInfos: [kycProviderInfo]
	status: String
}

"a kyc provider info representation"
type kycProviderInfo {
	id: String!
	providerEnum: kycProviderEnum
	providerEvents: [String]
	providerReference: String
	providerStatus: String
}

type lesson {
	createdAt: DateTime
	createdBy: login
	description: String
	durationInSeconds: Int
	id: String!
	items: [lessonItem]
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	passingRatio: Decimal
	version: String
	weight: Decimal
}

type lessonItem {
	createdAt: DateTime
	createdBy: login
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	localizedContent: String
	options: [itemOption]
	type: lessonItemTypes
}

"An answer to an item of a lesson"
type lessonItemAnswer {
	answer: [String]
	itemId: String!
}

"a loading"
type loading {
	calculationJsonLogic: String
	codeName: loadingCodeName
	currencyCode: currencyCodeEnumeration
	flat: Decimal
	formattedNewPrice: String
	formattedOriginalPrice: String
	id: String!
	newPrice: Decimal
	order: Int
	originalPrice: Decimal
	ratio: Decimal
}

type loadingCodeName {
	code: String
	name: String
}

"The product loading settings"
type loadingSettings {
	codeNames: [loadingCodeName]
	maxLoadingMultiplier: Decimal
}

"A login"
type login {
	accessFailedCount: Int!
	associatedUser: entityInterface
	createdAt: DateTime
	createdBy: login
	email: String
	events(
		"The date events created from."
		fromDate: DateTimeOffset,
		"The login event field to group by"
		groupBy: String,
		"Sort login events"
		sort: sortInput,
		"The date events created to."
		toDate: DateTimeOffset,
		"the list of login event types to be filtered on."
		types: [String]
	): [eventLog]
	id: String!
	inheritedLogins: [login!]!
	isActive: Boolean!
	isEmailConfirmed: Boolean!
	isTelephoneNumberConfirmed: Boolean!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	lockoutEndDateUtc: DateTimeOffset
	permissionGroups: [permissionGroup]
	policyUpdateRequests(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"the list of status to be filtered on."
		statusFilter: [String]
	): policyUpdateRequests @deprecated(reason: "use `endorsements` instead")
	targetedPermissionSchemas: [targetedPermissionSchema]
	targettedPermissions: [targettedPermission]
	telephoneNumber: String
	username: String!
}

"Gets all logins"
type logins {
	list: [login]
	totalCount: Int!
}

type logoUrls {
	"flexible width color"
	typeA: String
	"flexible width grey"
	typeB: String
	"static width color"
	typeC: String
	"static width grey"
	typeD: String
	"static width left color"
	typeE: String
}

type marginSettings {
	bottom: Float
	left: Float
	right: Float
	top: Float
}

"Policy members"
type members {
	"Gets list"
	list: [policyMember]
	"Gets a reportItems"
	totalCount: Int
}

"Policy members movements"
type membersActivity {
	"Gets list"
	list: [policyMember]
	"Gets a reportItems"
	totalCount: Int
}

"Policy members movements"
type membersMovements {
	"Gets list"
	list: [policyMember]
	"Gets a reportItems"
	totalCount: Int
}

type motorDetails {
	body: String
	drive: String
	engineCapacity: Int
	engineType: String
	gearbox: String
	horsePower: Int
	imageUrl: String
	years: [Int]
}

type motorGeneration {
	id: String
	name: String
	trims(
		"The id of trim"
		id: String
	): [motorTrim]
}

type motorMake {
	generations(
		"The id of generation"
		id: String,
		"The id of model"
		modelsId: String
	): [motorGeneration]
	id: String
	models(
		"The id of model"
		id: String
	): [motorModel]
	name: String
	trims(
		"The id of generation"
		generationId: String,
		"The id of generation"
		id: String,
		"The id of model"
		modelsId: String
	): [motorTrim]
}

type motorModel {
	generations(
		"The id of generation"
		id: String
	): [motorGeneration]
	id: String
	name: String
	trims(
		"The id of generation"
		generationId: String,
		"The id of generation"
		id: String
	): [motorTrim]
}

type motorTrim {
	details: motorDetails
	id: String
	name: String
}

"Note with title and description"
type note {
	content: String
	createdAt: DateTime
	createdBy: login
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	title: String
}

"A notification with multiple channels"
type notification {
	chatMessage: chatMessage
	createdAt: DateTime
	createdBy: login
	emailMessage: emailMessage
	fromEntityId: String
	id: String!
	internalMessage: internalMessage
	lastModifiedAt: DateTime
	lastModifiedBy: login
	pushMessage: pushMessage
	smsMessage: smsMessage
	status: String
	timestamp: DateTime
	type: String
}

type notificationConfig {
	clientId: String!
	emailConfig: emailConfig
}

"A notification subscription with a topic and a list of entities subscribed"
type notificationSubscription {
	entities: [entityInterface]
	id: String
	tags: [tag]
	topicName: String
}

"Gets all notification subscriptions"
type notificationSubscriptions {
	list: [notificationSubscription]
	totalCount: Int!
}

type notificationTemplate implements templateInterface {
	createdAt: DateTime
	createdBy: login
	description: String
	events: [eventLog]
	graphQlQuery: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	localizedHtml: String
	logicalId: String
	name: String
	tags: [String]!
	type: String
}

"Notification trigger"
type notificationTrigger {
	cronExpression: String!
	id: String!
	notification: sendNotification
}

"Paginated notifications"
type notifications {
	list: [notification]
	totalCount: Int!
}

type notifications_Error {
	code: String
	message: String
}

type notifications_Result {
	errors: [String]
	errors_2: [notifications_Error]
	isSuccess: Boolean!
	status: String
}

"An object"
type object implements entityInterface {
	achievements: [achievement]
	addresses: [address]
	associatedLogin: login
	attachments: [attachment]
	contacts: [contact]
	courseProgressions(
		"a course progression filter"
		where: courseProgressionWhereInput
	): [courseProgression]
	createdAt: DateTime
	createdBy: login
	entityType: String
	events: [eventLog]
	facts: [fact]
	fields: String
	id: String!
	identities: [identity]
	insuredBy: [policy]
	internalCode: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	notes: [note]
	notificationList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): notifications
	notifications(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): [notification]
	paymentMethods: [paymentMethodInterface]
	photoPath: String
	relationshipList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): relationships
	relationships(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): [relationship]
	reviews(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: reviewWhereInput
	): reviews
	source: String
	status: String
	subscriptions: [subscription]
	tags: [String]
	typeId: String
}

type objects {
	list: [object]
	totalCount: Int!
}

"An offer"
type offer {
	amount: Decimal
	associatedContracts: [associatedContract]
	benefitOptions: [benefitOptionChoice]
	benefitSummary: benefitSummary
	clauses(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput
	): [clause]
	commissionSplitRules: [commission]
	commissionSummary: [commission]
	createdAt: DateTime
	createdBy: login
	currencyCode: currencyCodeEnumeration
	endDate: DateTime
	events: [eventLog]
	exclusions: [exclusion]
	facts: [fact]
	fields: String
	fieldsSchema: dataSchema
	id: String!
	isPremiumOverridden: Boolean!
	jackets(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput
	): [jacketInstance]
	lastModifiedAt: DateTime
	lastModifiedBy: login
	offerNumber: String
	policyId: String
	policyNumber: String
	premium: pricing
	pricing: String
	product: product
	productTreeId: String
	productTreeRecords: [productTreeRecord]
	stakeholders: [stakeholder]
	startDate: DateTime
	status: String
	underwriting: String
	values: [keyValue]
	valuesJsonString: String
}

type operationCodeName {
	code: String!
	description: String
	name: String
}

"The product operation settings"
type operationSettings {
	codeNames: [operationCodeName]
}

"An organization user"
type organization implements entityInterface {
	achievements: [achievement]
	addresses: [address]
	associatedLogin: login
	attachments: [attachment]
	contacts: [contact]
	courseProgressions(
		"a course progression filter"
		where: courseProgressionWhereInput
	): [courseProgression]
	createdAt: DateTime
	createdBy: login
	entityType: String
	events: [eventLog]
	facts: [fact]
	fields: String
	id: String!
	identities: [identity]
	internalCode: String
	isActive: Boolean!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	notes: [note]
	notificationList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): notifications
	notifications(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: notificationWhere
	): [notification]
	paymentMethods: [paymentMethodInterface]
	photoPath: String
	relationshipList(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): relationships
	relationships(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"Filter relationships by type"
		types: [String],
		"a relationship filter"
		where: relationshipWhereInput
	): [relationship]
	reviews(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"a notification filter"
		where: reviewWhereInput
	): reviews
	source: String
	status: String
	subscriptions: [subscription]
	tags: [String]
	type: String
}

type organizations {
	list: [organization]
	totalCount: Int!
}

type otherId {
	id: String!
	key: String!
}

"otpLogin with a Token to be verifed with the One Time Password for access token creation"
type otpLogin {
	token: String!
}

"A token for otp login verification"
type otpLoginResult {
	errors: [String]
	otpLogin: otpLogin
	status: String!
}

type pageObject {
	footerSettings: headerFooter
	headerSettings: headerFooter
	html: String
	id: String!
}

"PanelProviderTier"
type panelProviderTier {
	attachments: [attachment]
	createdAt: DateTime
	createdBy: login
	description: String
	events: [eventLog]
	fields: String
	id: ID
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	panel: organization
	serviceItemAgreedFees: [serviceItemAgreedFee]
}

"Gets all panel provider tiers"
type panelProviderTiers {
	list: [panelProviderTier]
	totalCount: Int!
}

"The password validators"
type passwordValidators {
	requireConfirmPhoneNumber: Boolean!
	requireConfirmedEmail: Boolean!
	requireDigit: Boolean!
	requireLength: Int!
	requireLetter: Boolean!
	requireLowercase: Boolean!
	requireNonAlphanumeric: Boolean!
	requireUniqueChars: Int!
	requireUppercase: Boolean!
}

"A payment info"
type paymentInfo {
	amount: Decimal
	comment: String
	createdAt: DateTime
	createdBy: login
	currencyCode: currencyCodeEnumeration
	endDate: Date
	formattedPayment: String
	frequency: paymentFrequency
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	method: paymentMethod
	name: String
	payor: entityInterface
	startDate: Date
}

type pdfAttachment {
	fileName: String!
	htmlContent: String
	password: String
}

type pdfDrawing {
	font: font
	id: String!
	liquidSource: String
	page: Int!
	point1: point!
	point2: point!
	textAlignment: textAlignmentEnumeration
	verticalAlignment: verticalAlignmentEnumeration
}

type pdfDrawingTemplate implements templateInterface {
	createdAt: DateTime
	createdBy: login
	description: String
	drawings: [pdfDrawing]
	events: [eventLog]
	fileKey: String!
	graphQlQuery: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	logicalId: String
	name: String
	password: String
	passwordLiquid: String
	tags: [String]!
	type: String
}

type pdfRenderedResult {
	errors: [String]
	status: String!
	value: [Byte]
}

"A fundamental permission"
type permission {
	description: String
	id: String!
	name: String
}

"Group of permission that can target users or target groups"
type permissionGroup {
	createdAt: DateTime
	createdBy: login
	description: String
	events: [eventLog]
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	logins: [login]
	name: String!
	permissionGroups: [permissionGroup]
	productTypes: [String]
	targettedPermissions: [targettedPermission]
}

type permissionSchema {
	actionType: permissionSchemaActionType
	createdAt: DateTime
	createdById: String
	description: String
	id: String
	lastModifiedAt: DateTime
	lastModifiedById: String
	name: String
	objectType: String!
	schema: String
	stateCondition: fieldsWhere
	updateCondition: fieldsWhere
}

type permissionSchemas {
	list: [permissionSchema]
	totalCount: Int
}

type plan {
	createdAt: DateTime
	createdBy: login
	description: String
	id: productId
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	price(
		"A list of dynamic values to be sent to pricing engine."
		values: [keyValueInput],
		"A list of dynamic values to be sent to pricing engine in json string format."
		valuesJsonString: String
	): pricing
	tags: [tag]
}

type point {
	x: Float!
	y: Float!
}

"Gets all policies"
type policies {
	list: [policy]
	totalCount: Int!
}

type policiesUnderwritings {
	list: [policyUnderwriting]
	totalCount: Int
}

type policies_AddPolicyMemberPayload {
	errors: [policies_AddPolicyMemberError!]
	policyMember: policies_PolicyMemberState
}

type policies_Address {
	fields: [policies_KeyValuePairOfStringAndString!]
	id: String
	type: String
}

type policies_ArgumentError implements policies_UserError {
	code: String!
	message: String!
}

type policies_AttachedRulesQueryInterfaceOfpoliciesAttachedCommandPermissionAndpolicies_AttachedRuleFilter {
	count: Long!
	list: [policies_policiesAttachedCommandPermission]
}

type policies_AttachedRulesQueryInterfaceOfpoliciesAttachedExternalApiCallAndpolicies_AttachedRuleFilter {
	count: Long!
	list: [policies_policiesAttachedExternalApiCall]
}

type policies_AttachedRulesQueryInterfaceOfpoliciesAttachedFilterAndpolicies_AttachedRuleFilter {
	count: Long!
	list: [policies_policiesAttachedFilter]
}

type policies_AttachedRulesQueryInterfaceOfpoliciesAttachedObjectValidationAndpolicies_AttachedRuleFilter {
	count: Long!
	list: [policies_policiesAttachedObjectValidation]
}

type policies_AttachedRulesQueryInterfaceOfpoliciesAttachedPostHandleValidationAndpolicies_AttachedRuleFilter {
	count: Long!
	list: [policies_policiesAttachedPostHandleValidation]
}

type policies_Attachment {
	createdAt: DateTime!
	createdById: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	path: String
}

type policies_BadFileContentError implements policies_UserError {
	code: String!
	message: String!
}

type policies_Contact {
	id: String
	type: String
	value: String
}

type policies_CreatedStatus {
	id: String
	ids: [String]
}

type policies_CustomReason {
	archived: Boolean
	category: policies_Category!
	createdAt: DateTime!
	id: String!
	lastModifiedAt: DateTime
	name: String!
	type: String!
}

type policies_DeletePolicyMemberPayload {
	errors: [policies_DeletePolicyMemberError!]
	result: policies_NoContentResult
}

type policies_DeletePolicyMembersPayload {
	errors: [policies_DeletePolicyMembersError!]
	result: policies_NoContentResult
}

type policies_Entity {
	addresses: [policies_Address]
	attachments: [policies_Attachment]
	contacts: [policies_Contact]
	createdAt: DateTime!
	createdById: String
	facts: [policies_Fact]
	fields: String
	id: String
	identities: [policies_Identity]
	internalCode: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	links: [policies_Link]
	name: String
	notes: [policies_Note]
	photoPath: String
	source: String
}

type policies_Error {
	code: String
	message: String
}

type policies_ExtendedPolicyMember {
	activity: [policies_PolicyMember]
	createdAt: DateTime
	createdById: String
	"Primary memberId for which this member is dependent of"
	dependentOf: String
	endDate: DateTime
	endorsementId: String
	fields: String
	id: String
	individualId: String
	"Internal code to be assigned to the individual when the policy is issued. Displayed as `MemberId` in FE."
	internalCode: String
	isEndorsement: Boolean!
	isPrinted: Boolean!
	isRemoved: Boolean!
	lastModifiedAt: DateTime
	"""

	Was generated by FE. Same for different policies in renewal. Different for the same individual with different policies.
	Only used by the system. Is not displayed to the user.
	"""
	memberId: String
	planId: String
	policyContractHolder: policies_Entity
	policyId: String
	policyIssuerNumber: String
	startDate: DateTime
	timestamp: DateTime!
	underwritingResult: policies_PolicyMemberUnderwritingResult
	validationResult: policies_PolicyMemberValidationResult
}

type policies_ExternalApiCall {
	afterCall: [String!]
	beforeCall: [String!]
	contentType: String
	contextSlug: String
	expectedContentExpression: String
	expectedResponseExpression: String
	headers: [policies_KeyValuePairOfStringAndString!]
	itemValidationExpression: String
	method: String!
	stringContent: String
	timeout: String
	url: String!
}

type policies_Fact {
	id: String
	type: String
	value: String
}

type policies_FieldInvalidOptionError implements policies_FieldValidationError & policies_UserError {
	code: String!
	message: String!
	propertyPath: String!
}

type policies_FieldInvalidTypeError implements policies_FieldValidationError & policies_UserError {
	code: String!
	message: String!
	propertyPath: String!
}

type policies_FieldNoExtraAllowedError implements policies_FieldValidationError & policies_UserError {
	code: String!
	message: String!
	propertyPath: String!
}

type policies_FieldOneOfError implements policies_UserError {
	code: String!
	errors: [policies_FieldValidationError!]!
	message: String!
}

type policies_FieldRequiredError implements policies_FieldValidationError & policies_UserError {
	code: String!
	message: String!
	propertyPath: String!
}

type policies_FieldUniqueError implements policies_FieldValidationError & policies_UserError {
	code: String!
	message: String!
	propertyPath: String!
}

type policies_FormatArgument {
	addOpOnResult: Int
	currentIncrement: Int
	dictionary: [policies_KeyValuePairOfStringAndString!]
	expectedType: String
	format: String
	graphQlQuery: String
	jsonPath: String
	order: Int!
	splitIndex: Int
	splitOn: String
	type: String
}

type policies_Identity {
	id: String
	type: String
	value: String
}

type policies_InsuredPersonDetailReportResult {
	reportPath: String!
}

type policies_IssueCertificatePayload {
	certificateNumber: Int
	errors: [policies_IssueCertificateError!]
}

type policies_KeyValuePairOfStringAndObject {
	key: String!
}

type policies_KeyValuePairOfStringAndString {
	key: String!
	value: String!
}

type policies_Link {
	targetId: String
	type: String
	values: [policies_KeyValuePairOfStringAndObject!]
}

type policies_MemberNotFoundError implements policies_UserError {
	code: String!
	message: String!
}

type policies_MemberValidationError {
	field: policies_MemberField!
	individualId: String
	memberId: String
	scope: policies_MemberValidationScope
	type: policies_MemberValidationType!
	value: String
}

type policies_MemberValidationResult {
	isValid: Boolean!
	memberValidationErrors: [policies_MemberValidationError!]
}

"Result with status only"
type policies_NoContentResult {
	isSuccess: Boolean!
}

type policies_Note {
	content: String
	createdAt: DateTime!
	createdById: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	title: String
}

type policies_PoliciesPricingResult {
	errors: [String]
	errors_2: [policies_Error]
	isSuccess: Boolean!
	list: [policies_PolicyPricingResult!]!
	status: String
}

type policies_PolicyContractHolderNotFoundError implements policies_UserError {
	code: String!
	message: String!
}

type policies_PolicyIssuedError implements policies_UserError {
	code: String!
	message: String!
}

"""

This is not a policy member, but a huge bag of properties.
Can be a member, a member movement, a member activity.
"""
type policies_PolicyMember {
	activity: [policies_PolicyMember]
	createdAt: DateTime
	createdById: String
	"Primary memberId for which this member is dependent of"
	dependentOf: String
	endDate: DateTime
	endorsementId: String
	fields: String
	id: String
	"Internal code to be assigned to the individual when the policy is issued. Displayed as `MemberId` in FE."
	internalCode: String
	isEndorsement: Boolean!
	isPrinted: Boolean!
	isRemoved: Boolean!
	lastModifiedAt: DateTime
	"""

	Was generated by FE. Same for different policies in renewal. Different for the same individual with different policies.
	Only used by the system. Is not displayed to the user.
	"""
	memberId: String
	planId: String
	policyId: String
	startDate: DateTime
	timestamp: DateTime!
	underwritingResult: policies_PolicyMemberUnderwritingResult
	validationResult: policies_PolicyMemberValidationResult
}

type policies_PolicyMemberEndorsementFields {
	pricingFields: [String!]!
	underwritingFields: [String!]!
}

type policies_PolicyMemberExistsError implements policies_UserError {
	code: String!
	message: String!
}

type policies_PolicyMemberMovementResult {
	items: [policies_ExtendedPolicyMember]
	totalCount: Long!
}

type policies_PolicyMemberNotFoundError implements policies_UserError {
	code: String!
	message: String!
}

type policies_PolicyMemberState {
	fields: Any
	memberId: String
	planId: String!
	policyId: String!
	policyMemberId: String!
}

type policies_PolicyMemberStatistic {
	hasIndividualId: Boolean!
	hasInternalCode: Boolean!
	hasMovementsWithoutCreatedAtField: Boolean!
	hasMovementsWithoutCreatedByIdField: Boolean!
	hasStartDate: Boolean!
	hasUniqueIndividualId: Boolean
	hasUniqueInternalCode: Boolean
	memberId: String
	policyId: String
}

type policies_PolicyMemberStatisticGraph {
	members: [policies_PolicyMemberStatistic]
	totalCount: String
}

type policies_PolicyMemberUpload {
	createdAt: DateTime!
	id: String!
	lastModifiedAt: DateTime
	path: String!
	policyId: String!
	status: policies_PolicyMemberUploadStatus!
	validationErrors: [policies_UserError!]
}

type policies_PolicyMemberUploadCollectionSegment {
	items: [policies_PolicyMemberUpload!]
	"Information to aid in pagination."
	pageInfo: CollectionSegmentInfo!
	totalCount: Int!
}

type policies_PolicyNotFoundError implements policies_UserError {
	code: String!
	message: String!
}

type policies_PolicyPricingResult {
	errors: [String]
	errors_2: [policies_Error]
	isSuccess: Boolean!
	policyId: String!
	pricing: String!
	status: String
}

type policies_ProductNotFoundError implements policies_UserError {
	code: String!
	message: String!
}

type policies_ProductPlanNotFoundError implements policies_UserError {
	code: String!
	message: String!
}

type policies_Reason {
	archived: Boolean
	category: policies_Category!
	createdAt: DateTime!
	id: String!
	lastModifiedAt: DateTime
	name: String!
	type: String!
}

type policies_ReasonCollectionSegment {
	items: [policies_Reason!]
	"Information to aid in pagination."
	pageInfo: CollectionSegmentInfo!
	totalCount: Int!
}

type policies_ReferenceGeneratorConfig {
	arguments: [policies_FormatArgument]
	format: String
	type: String
}

type policies_RegisterPolicyMemberUploadPayload {
	errors: [policies_RegisterPolicyMemberUploadError!]
	uploadResult: policies_PolicyMemberUpload
}

type policies_RequiredArgumentError implements policies_UserError {
	code: String!
	message: String!
}

type policies_Result {
	errors: [String]
	errors_2: [policies_Error]
	isSuccess: Boolean!
	status: String
}

type policies_ResultOfCreatedStatus {
	errors: [String]
	errors_2: [policies_Error]
	isSuccess: Boolean!
	status: String
	value: policies_CreatedStatus
}

type policies_ResultOfInt64 {
	errors: [String]
	errors_2: [policies_Error]
	isSuccess: Boolean!
	status: String
	value: Long!
}

type policies_ResultOfMemberValidationResult {
	errors: [String]
	errors_2: [policies_Error]
	isSuccess: Boolean!
	status: String
	value: policies_MemberValidationResult
}

type policies_ScriptError {
	code: String!
	message: String!
}

type policies_ScriptResult {
	errors: [String!]
	errors_2: [policies_ScriptError!]
	status: String!
	value: String!
}

type policies_SystemReason {
	archived: Boolean
	category: policies_Category!
	createdAt: DateTime!
	id: String!
	lastModifiedAt: DateTime
	name: String!
	type: String!
}

type policies_UpdatePolicyMemberPayload {
	errors: [policies_UpdatePolicyMemberError!]
	policyMember: policies_PolicyMemberState
}

type policies_UploadFileNotFoundError implements policies_UserError {
	code: String!
	message: String!
}

type policies_policiesAttachedCommandPermission {
	action: policies_AttachedRuleAllowAction!
	command: String!
	commandExpression: String
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

type policies_policiesAttachedExternalApiCall {
	apiCalls: [policies_ExternalApiCall!]!
	description: String
	eventExpression: String
	forEach: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

type policies_policiesAttachedFilter {
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

type policies_policiesAttachedObjectValidation {
	action: policies_AttachedRuleAllowAction!
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

type policies_policiesAttachedPostHandleValidation {
	action: policies_AttachedRuleAllowAction!
	description: String
	eventExpression: String
	group: Int!
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

"A policy"
type policy {
	acceptedOffer: offer
	associatedContracts: [associatedContract]
	attachments: [attachment]
	beneficiaryEligibilities: [beneficiaryEligibility]
	benefitOptions: [benefitOptionChoice]
	benefitSummary: benefitSummary
	cancellationReason: String
	cancellationSummary: String
	cancelledBy: login
	claimBalance: [benefit]
	claims(
		"A claim search filter"
		where: claimWhereInput
	): [claim]
	clauses(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput
	): [clause]
	client: client
	commissionSplitRules: [commission]
	commissionSummary: [commission]
	contractBeneficiaryEligibilities: [beneficiaryEligibility]
	contractHolder: entityInterface
	contractInsured: [entityInterface]
	coolingOffExpiryDate: DateTime
	createdAt: DateTime
	createdBy: login
	description: String
	endDate: Date
	endorsements(
		"the endorsement where input"
		where: endorsementWhereInput
	): [endorsement]
	events: [eventLog]
	exclusions: [exclusion]
	extraFields: String
	facts: [fact]
	fields: String
	fieldsDiffs(
		"the FieldsDiff where input"
		where: fieldsDiffWhereInput
	): [fieldsDiff]
	fieldsSchema: dataSchema
	generatedFrom: generatedFrom
	holder: entityInterface
	id: String!
	insured: [entityInterface]
	isCoolingOffSubmitted: Boolean
	isIssued: Boolean!
	isPremiumOverriden: Boolean!
	isRenewal: Boolean
	issueDate: DateTime
	issuedBy: login
	issuerNumber: String
	jackets: [jacketInstance]
	lapseReason: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	memberEndorsementFields: policies_PolicyMemberEndorsementFields
	"Policy members info"
	members(
		"filter"
		filter: policyMembersFilterAggregateInput,
		"set to false in order to get terminated movememnts"
		filterOutTerminatedMemberMovements: Boolean,
		"set to false in order to account for underwriting not approved movements"
		filterOutUnderwritingNotApproved: Boolean,
		"true for the members who already reached the end date"
		isTerminated: Boolean,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"sort items"
		sort2: [sortInput]
	): members
	"Policy members activity"
	membersActivity(
		"filter"
		filter: policyMembersFilterAggregateInput,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"sort items"
		sort2: [sortInput]
	): membersActivity
	"Policy members movements"
	membersMovements(
		"filter"
		filter: policyMembersFilterAggregateInput,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"sort items"
		sort2: [sortInput]
	): membersMovements
	notes: [note]
	offers: [offer]
	"Issuer number of policy originally renewed from, supposed to keep the same value each renewal"
	originalIssuerNumber: String
	otherContractHolders: [entityInterface]
	otherHolders: [entityInterface]
	paymentInfos: [paymentInfo]
	premium: pricing
	previousPolicies: [policy]
	pricing: String
	"Policy pricing"
	pricingData: PricingRootGraphType
	product: product
	productTreeId: String
	productTreeRecords: [productTreeRecord]
	proposal: proposal
	referrer: internal
	rejectedBy: login
	rejectionCodes: [rejectionCodeName]
	rejectionRemarks: String
	renewalNumber: String
	"Supposed to be incremented each time when we renewing policy"
	renewalVersion: Int
	source: String
	stakeholders: [stakeholder]
	startDate: Date
	status: String
	tags: [tag]
	transactions(
		"excludes transactions tied to an endorsement when set to true"
		excludeEndorsements: Boolean,
		"A transaction search filter"
		where: transactionWhereInput
	): [transaction]
	transformedBy: login
	"Underwritings"
	underwritings(
		"filter"
		filter: policyUnderwritingFilterInput,
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput
	): policiesUnderwritings
	values: [keyValue]
	valuesJsonString: String
}

type policyDebitNoteNumber {
	debitNoteNumber: String!
	policyId: String!
}

"Policy member"
type policyMember {
	"DateTime when the member was created the first time"
	createdAt: DateTime
	createdById: String
	"MemberId the member is dependent of"
	dependentOf: String
	endDate: Date
	endorsementId: String
	fields: String
	"Unique state identifier, will be new each time when the member gets updated or removed."
	id: String!
	"Internal code of the member, assigned when the policy gets issued, supposed to be used for individual creation"
	internalCode: String
	isPrinted: Boolean!
	isRemoved: Boolean!
	"Date time when the member was last modified"
	lastModifiedAt: DateTime
	"Member unique id(HKID, passport number, etc)"
	memberId: String!
	planId: String
	policyId: String!
	startDate: Date
	timestamp: DateTime
	underwritingResult: PolicyMemberUnderwritingResult
	validationResult: PolicyMemberValidationResult
}

type policyMemberMovementNumber {
	memberMovementNumber: String!
	policyId: String!
}

type policyMemberMovementReportItem {
	amount: Decimal
	endorsement: endorsement
	movementType: String
	policy: policy
}

"Policy Members Movements Report"
type policyMembersMovementsReport {
	"Report"
	list: [policyMemberMovementReportItem]
	"Report total reportItems"
	totalCount: Int
}

"A result of a policy operation"
type policyResult {
	errors: [String]
	policyStatus: policyStatus
	status: String!
}

"A policy status"
type policyStatus {
	id: String!
	status: String
}

type policyUnderwriting {
	fields: String
	id: String
	policyId: String
	policyMember: policyMember
	remarks: [policyUnderwritingRemark]
	status: String
}

type policyUnderwritingRemark {
	fields: String
	id: String
	remark: String
	remarkType: String
}

"A policy update request"
type policyUpdateRequest {
	approvalStatus: String
	createdAt: DateTime
	createdBy: login
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	policyId: String!
	updateBeneficiaryEligibilityCommands: [updateBeneficiaryEligibility]
	updatePaymentInfoCommands: [updatePaymentInfo]
	updatePolicyCommands: [updatePolicyGraphType]
	upsertBenefitOptionCommands: [upsertBenefitOption]
}

"All policy update request"
type policyUpdateRequests {
	list: [policyUpdateRequest]
	totalCount: Int!
}

"A possible value coming from a template"
type possibleValue {
	"Can be only 'Boolean', 'Date', 'Number', 'String'"
	scalarType: String!
	values: [scalarValue]
}

"A template to get possible values"
type possibleValueTemplate {
	factDescription: String
	factName: String
	factType: String!
	possibleValues: [possibleValue]
}

"preOtpLogin with a Token for creating an otpLogin"
type preOtpLogin {
	token: String!
}

"Result of preOtpLogin creation with a token for future generation of otpLogin"
type preOtpLoginResult {
	errors: [String]
	preOtpLogin: preOtpLogin
	status: String!
}

type premiumToUpdate {
	amount: Decimal
	currencyCode: currencyCodeEnumeration
	discountCodes: [String]
	grossAmount: Decimal
	isAmountChanged: Boolean!
	isCurrencyCodeChanged: Boolean!
	isDiscountCodesChanged: Boolean
	isGrossAmountChanged: Boolean
	isPricedAtStartDate: Boolean
}

type price {
	amount: Decimal!
	currencyCode: currencyCodeEnumeration
	formattedPrice: String!
}

type pricing {
	amount: Decimal
	amountLogic: String
	appliedDiscounts: [discount]
	appliedTaxes: [tax]
	convertedPrices(
		"The conversion options"
		options: exchangeRateConversionOptionsInput!
	): [pricing]!
	createdAt: DateTime
	createdBy: login
	currencyCode: currencyCodeEnumeration
	discountCodes: [String]
	discounts: [discount]
	formattedOriginalPrice: String
	formattedPrice: String
	indicativePrices: [indicativePrice]
	isPricedAtStartDate: Boolean
	lastModifiedAt: DateTime
	lastModifiedBy: login
	loadings: [loading]
	metadata: String
	options: [pricingOption]
	originalPrice: Decimal
	paymentFrequency: paymentFrequency
}

type pricingOption {
	description: String
	id: String!
	key: String
	name: String
	value: scalarValue
	valueJsonString: String
	values: [keyValue] @deprecated(reason: "use `value` instead")
}

"A product"
type product {
	applicationFormUrl: String
	benefitGraph: [benefitGraph]
	benefits(
		"include optional benefits"
		includeOptionals: Boolean,
		"The benefit type ids."
		typeIds: [String]
	): [benefit] @deprecated(reason: "not used anymore")
	brochureUrl: String
	changeEffectiveDate: Date
	claimFactTemplateGraph: factTemplate
	claimSettings: claimSettings
	createdAt: DateTime
	createdBy: login
	description: String
	enrollmentUrl: String
	events: [detailedEventLog]
	exclusionSettings: exclusionSettings
	facts: [fact]
	fields: String
	illustrations(
		"A list of dynamic values to be sent to pricing engine."
		values: [keyValueInput],
		"A list of dynamic values to be sent to pricing engine in json string format."
		valuesJsonString: String
	): [illustration!]
	importantNotes: String
	insurer: insurer
	internalReviews: [internalReview]
	issuerProductId: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	launchPeriodEndDate: Date
	launchPeriodStartDate: Date
	lifecycleStage: String
	loadingSettings: loadingSettings
	majorExclusions: String
	name: String
	premiumTableUrl: String
	pricing(
		"A list of the discount codes input by customers."
		discountCodes: [String],
		"To calculate price at a certain date"
		pricingDate: DateTimeOffset,
		"A list of dynamic values to be sent to pricing engine."
		values: [keyValueInput],
		"A list of dynamic values to be sent to pricing engine in json string format."
		valuesJsonString: String
	): pricing
	productId: productId
	productTreeId: String
	rejectionSettings: rejectionSettings
	representation: String
	scores(
		"The id of the advisor"
		advisorId: String!,
		"A list of dynamic values to check underwriting rules"
		values: [keyValueInput]
	): [score]
	scripts: [script]
	slug: String
	status: String
	tags: [tag]
	templateRelationships(where: templateRelationshipWhereInput): [templateRelationship]
	tenantId: String
	termsAndConditionsUrl: String
	type: productType
	underwriting: underwriting
	underwritingRulesJson: String
}

type productConfig {
	clientId: String
	displayedBenefits: [displayedBenefits]
	displayedInsurers: [displayedInsurers]
	displayedProducts: [displayedProducts]
	displayedTypes: [String!]!
	id: String!
}

"A product id"
type productId {
	plan: String!
	type: String!
	version: String
}

"A product id"
type productIdToUpdate {
	isPlanChanged: Boolean!
	isTypeChanged: Boolean!
	isVersionChanged: Boolean!
	plan: String
	type: String
	version: String
}

"A reference to record of product tree resolution"
type productTreeRecord {
	recordId: String!
	type: String!
}

type productType {
	code: String
	createdAt: DateTime
	createdBy: login
	dataSchemas(where: dataSchemaWhereInput): [dataSchema!]
	description: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	logoUrl: String
	name: String
	tenantId: String
	typeId: String!
}

"Gets all products of all types"
type products {
	list: [product]
	totalCount: Int!
}

type products_CreatedStatus {
	id: String
	ids: [String]
}

type products_DiscountCode {
	createdAt: DateTime!
	createdById: String
	description: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	name: String
	productIds: [products_ProductId]
	productTypeId: String
	redemptionLimit: Int
	type: products_DiscountType!
	validFrom: DateTime
	validTo: DateTime
	value: Decimal!
}

type products_Error {
	code: String
	message: String
}

type products_FilePathResult {
	errors: [String]
	errors_2: [products_Error]
	filePath: String
	isSuccess: Boolean!
	status: String
}

type products_GenericDiscountCode8QueryInterface {
	list: [products_DiscountCode]
	totalCount: Long!
}

type products_GenericProductImportHistoryRecord8QueryInterface {
	list: [products_ProductImportHistoryRecord]
	totalCount: Long!
}

type products_GenericSbu8QueryInterface {
	list: [products_Sbu]
	totalCount: Long!
}

type products_ProductId {
	plan: String
	type: String
	version: String
}

type products_ProductImportHistoryPackage {
	exportedAt: DateTime!
	exportedBy: String
	includedEntries: [String]
	productId: products_ProductId
	productLastModifiedAt: DateTime
	productLastModifiedBy: String
	productLifecycleStage: String
	productName: String
	relativeFilePath: String
	requestId: String
	tenant: String
}

type products_ProductImportHistoryRecord {
	id: String
	importedAt: DateTime!
	importedBy: String
	importedById: String
	package: products_ProductImportHistoryPackage
}

type products_ProductImportInfo {
	exportedAt: DateTime!
	exportedBy: String
	includedEntries: [String]
	productId: products_ProductId
	productLastModifiedAt: DateTime
	productLastModifiedBy: String
	productLifecycleStage: String
	productName: String
	tenant: String
	validationMessages: [products_ProductImportValidationMessage]
}

type products_ProductImportValidationMessage {
	code: String
	entry: String
	level: products_ProductImportValidationMessageLevel!
	meta: products_ProductImportValidationMessageMeta
}

type products_ProductImportValidationMessageMeta {
	lockedBy: String
}

type products_ProductPricingResult {
	errors: [String]
	errors_2: [products_Error]
	isSuccess: Boolean!
	pricing: String
	status: String
}

type products_Result {
	errors: [String]
	errors_2: [products_Error]
	isSuccess: Boolean!
	status: String
}

type products_ResultOfCreatedStatus {
	errors: [String]
	errors_2: [products_Error]
	isSuccess: Boolean!
	status: String
	value: products_CreatedStatus
}

type products_ResultOfString {
	errors: [String]
	errors_2: [products_Error]
	isSuccess: Boolean!
	status: String
	value: String
}

type products_Sbu {
	amount: Decimal!
	createdAt: DateTime!
	createdById: String
	endDate: DateTime!
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	startDate: DateTime!
}

"a proposal"
type proposal {
	basket(
		"the offer where input"
		where: offerWhere
	): [offer]
	case: case
	createdAt: DateTime
	createdBy: login
	expiryDate: Date
	id: String!
	isIssued: Boolean!
	isRejected: Boolean!
	issuedAt: DateTime
	issuedBy: login
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	notes: [note]
	policies(
		"the policy where input"
		where: policyWhereInput
	): [policy]
	proposalNumber: String
	referralCode: String
	rejectedBy: login
	rejectionCodes: [rejectionCodeName]
	rejectionRemarks: String
	renewalHistory: renewalHistory
	stakeholders: [stakeholder]
	status: String
	totalPrice: pricing
	transactions: [transaction]
}

type providerSettings {
	providers: [entityInterface]
}

"A push message"
type pushMessage {
	content: String
	data: [pushMessageData]
	title: String
	token: String
	topic: String
}

type pushMessageData {
	type: String!
	value: String!
}

"A range"
type range {
	exclusiveMaximum: Boolean
	exclusiveMinimum: Boolean
	maximum: Float
	minimum: Float
}

type rejectionCodeName {
	code: String!
	name: String
}

type rejectionReason {
	description: String
}

"The product rejection settings"
type rejectionSettings {
	codeNames: [rejectionCodeName]
}

"An entity's relationship with another entity"
type relationship {
	createdAt: DateTime
	createdBy: login
	entity: entityInterface
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	targetEntityId: String
	type: String!
	value: scalarValue
	values: [relationshipValue]
}

"A relationship value"
type relationshipValue {
	key: String!
	value: String!
}

"Gets all relationships"
type relationships {
	list: [relationship]
	totalCount: Int!
}

"remark for a claim"
type remark {
	fields: String
	id: String!
	remarkFull: String!
	remarkShort: String!
}

"Remarks"
type remarks {
	count: Int
	list: [remark]
}

type removeAssociatedContractCommandGraph {
	commandId: String
	endorsementId: String
	id: String
	removedBy: login
	timestamp: DateTime
}

type removeBenefitOptionCommand {
	commandId: String
	endorsementId: String
	removedBy: login
	timestamp: DateTime
	typeId: String
}

type removeCommand {
	commandId: String
	endorsementId: String
	id: String
	removedBy: login
	timestamp: DateTime
}

type removeEntityPrimitiveCommand {
	commandId: String
	endorsementId: String
	entityId: String
	primitiveId: String
	removedBy: login
	timestamp: DateTime
}

type renewalHistory {
	renewalCount: Int!
	renewedFrom: proposal
	renewedTo: proposal
}

type requestManager_Address {
	addressLine1: String
	addressLine2: String
	addressLine3: String
	addressLine4: String
	addressType: String
	country: requestManager_COUNTRY
	postCode: String
	useForMail: Boolean
	validFrom: DateTime
	validTo: DateTime
}

type requestManager_CollectionSegmentInfo {
	hasNextPage: Boolean
	hasPreviousPage: Boolean
}

type requestManager_Contact {
	contactChannel: String
	email: String
	phoneArea: String
	phoneCountry: requestManager_COUNTRY
	phoneNumber: String
	validFrom: DateTime
	validTo: DateTime
}

type requestManager_ExceptionError {
	code: String!
	message: String!
}

type requestManager_ExternalRef {
	domain: String
	domainAggregate: String
	refId: String
	type: String
}

type requestManager_Identity {
	expiryDate: DateTime
	identifierNumber: String
	identifyDocumentId: String
	identifyType: String
	issuanceCountry: requestManager_COUNTRY
	issueDate: DateTime
	validFrom: DateTime
	validTo: DateTime
}

type requestManager_MarketingPreference {
	email: Boolean
	phone: Boolean
	post: Boolean
	sMS: Boolean
}

type requestManager_Organization {
	glyphOperatingName: String
	glyphRegisteredName: String
	operatingName: String
	organizationType: String
	registeredName: String
	registrationCountry: requestManager_COUNTRY
	registrationDate: DateTime
	registrationNumber: String
}

type requestManager_OrganizationState {
	addresses: [requestManager_Address]
	communications: requestManager_ExternalRef
	contacts: [requestManager_Contact]
	dateCreated: DateTime
	documents: requestManager_ExternalRef
	goneAway: String
	isDeleted: Boolean
	language: String
	marketingPreference: requestManager_MarketingPreference
	masterPartyID: UUID
	organization: requestManager_Organization
	partyAccountID: String
	partyID: UUID
	partyRoles: [requestManager_Role]
	paymentMethods: requestManager_ExternalRef
	requestToBeForgotten: requestManager_RequestToBeForgotten
	sanctions: String
	type: requestManager_PartyType
	validFrom: DateTime
	validTo: DateTime
}

type requestManager_OrganizationStateCollectionSegment {
	items: [requestManager_OrganizationState]
	pageInfo: requestManager_CollectionSegmentInfo
	totalCount: Int
}

type requestManager_PartyState {
	addresses: [requestManager_Address]
	communications: requestManager_ExternalRef
	contacts: [requestManager_Contact]
	dateCreated: DateTime
	documents: requestManager_ExternalRef
	goneAway: String
	isDeleted: Boolean
	language: String
	marketingPreference: requestManager_MarketingPreference
	masterPartyID: UUID
	organization: requestManager_Organization
	partyAccountID: String
	partyID: UUID
	partyRoles: [requestManager_Role]
	paymentMethods: requestManager_ExternalRef
	person: requestManager_Person
	requestToBeForgotten: requestManager_RequestToBeForgotten
	sanctions: String
	type: requestManager_PartyType
	validFrom: DateTime
	validTo: DateTime
}

type requestManager_Person {
	dateOfBirth: DateTime
	dateOfDeath: DateTime
	ethnicity: String
	firstName: String
	gender: String
	glyphName: String
	identities: [requestManager_Identity]
	middleName: String
	mothersMaidenName: String
	nationality: requestManager_COUNTRY
	pep: Boolean
	preferredCommOption: String
	preferredPronouns: String
	prefix: String
	residency: requestManager_COUNTRY
	salutation: String
	suffix: String
	surname: String
}

type requestManager_PersonState {
	addresses: [requestManager_Address]
	communications: requestManager_ExternalRef
	contacts: [requestManager_Contact]
	dateCreated: DateTime
	documents: requestManager_ExternalRef
	goneAway: String
	isDeleted: Boolean
	language: String
	marketingPreference: requestManager_MarketingPreference
	masterPartyID: UUID
	partyAccountID: String
	partyID: UUID
	partyRoles: [requestManager_Role]
	paymentMethods: requestManager_ExternalRef
	person: requestManager_Person
	requestToBeForgotten: requestManager_RequestToBeForgotten
	sanctions: String
	type: requestManager_PartyType
	validFrom: DateTime
	validTo: DateTime
}

type requestManager_PersonStateCollectionSegment {
	items: [requestManager_PersonState]
	pageInfo: requestManager_CollectionSegmentInfo
	totalCount: Int
}

type requestManager_RequestToBeForgotten {
	dateRequested: DateTime
	decision: String
	notes: String
	request: String
}

type requestManager_Role {
	entityId: UUID
	entityType: String
	partyRole: String
	validFrom: DateTime
	validTo: DateTime
}

type requestManager_WorkflowCompletedOfOrganizationStateCollectionSegment {
	exceptionErrors: [requestManager_ExceptionError!]!
	workflowRunState: requestManager_WorkflowRunStateOfOrganizationStateCollectionSegment!
}

type requestManager_WorkflowCompletedOfPartyState {
	exceptionErrors: [requestManager_ExceptionError!]!
	workflowRunState: requestManager_WorkflowRunStateOfPartyState!
}

type requestManager_WorkflowCompletedOfPersonStateCollectionSegment {
	exceptionErrors: [requestManager_ExceptionError!]!
	workflowRunState: requestManager_WorkflowRunStateOfPersonStateCollectionSegment!
}

type requestManager_WorkflowRunState {
	errors: [requestManager_IBusinessError!]!
	id: String!
	status: String!
}

type requestManager_WorkflowRunStateOfOrganizationStateCollectionSegment {
	errors: [requestManager_IBusinessError!]!
	id: String!
	output: requestManager_OrganizationStateCollectionSegment
	status: String!
}

type requestManager_WorkflowRunStateOfPartyState {
	errors: [requestManager_IBusinessError!]!
	id: String!
	output: requestManager_PartyState
	status: String!
}

type requestManager_WorkflowRunStateOfPersonStateCollectionSegment {
	errors: [requestManager_IBusinessError!]!
	id: String!
	output: requestManager_PersonStateCollectionSegment
	status: String!
}

"A result object with potential errors"
type result {
	errors: [String!]
	errors_2: [errors!]
	"'success' or 'failure'"
	status: String!
}

type resultCell {
	columnIndex: Int
	rowIndex: Int
	type: cellType
}

type review {
	comment: String
	createdAt: DateTime
	createdBy: login
	id: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	relatedId: String
	scores: [score]
	type: String
}

type reviews {
	aggregate: review
	list: [review]
	totalCount: Int
}

"A representation of a scalar value object"
type scalarValue {
	arrayValue: [scalarValue]
	booleanValue: Boolean
	dateValue: DateTime
	numberValue: Decimal
	objectValue: [keyValue]
	stringValue: String
}

type score {
	comment: String
	description: String
	id: String!
	name: String
	type: String
	value: Decimal
}

type script {
	externalTableDataUrl: String
	externalTableDataUrls: [String!]
	id: String!
	inputSchema: String
	name: String!
	outputSchema: String
	referenceSourceCode: String!
	referenceSourceCodeUrl: String
	sourceCode: String
	type: scriptTypeEnum
}

type scripts {
	list: [script!]
	totalCount: Int!
}

type section {
	createdAt: DateTime
	createdBy: login
	description: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	lessons: [lesson]
	name: String
	sections: [section]
}

"Send notification"
type sendNotification {
	chatMessage: chatMessage
	emailMessage: emailMessage
	fromEntityId: String
	internalMessage: internalMessage
	offerId: String
	policyId: String
	pushMessage: pushMessage
	smsMessage: smsMessage
	toEntityId: String
	toEntityIds: [String]
	toTopic: String
	toTopicId: String
	type: String
}

type serviceItem {
	description: String
	id: String!
	name: String!
}

type serviceItemAgreedFee {
	createdAt: DateTime
	createdBy: login
	currency: String!
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	rate: Decimal!
	serviceItem: serviceItem
}

type serviceItemAgreedFees {
	list: [serviceItemAgreedFee]
	totalCount: Int
}

type serviceItems {
	list: [serviceItem]
	totalCount: Int
}

"A sms message"
type smsMessage {
	body: String
	from: String
	templateRendering: templateRendering
	to: String
}

type smsRendered {
	body: String
}

type smsRenderedResult {
	errors: [String]
	status: String!
	value: smsRendered
}

type smsTemplate implements templateInterface {
	bodyLiquid: String
	createdAt: DateTime
	createdBy: login
	description: String
	events: [eventLog]
	graphQlQuery: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	logicalId: String
	name: String
	tags: [String]!
	type: String
}

type stakeholder {
	entity: entityInterface
	id: String
	type: String!
}

type stringResult {
	errors: [String]
	status: String!
	value: String
}

type subscription {
	cancelledBy: login
	createdAt: DateTime
	createdBy: login
	discounts: [subscriptionDiscount]
	endDate: DateTime
	id: String
	interval: intervalType
	intervalCount: Int
	isCancelled: Boolean!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	offers: [offer]
	paymentDates: [DateTime]
	paymentMethod: paymentMethodInterface
	startDate: DateTime
	transactions: [transaction]
}

type subscriptionDiscount {
	date: DateTime
	discountAmount: Decimal
	interval: intervalType
}

type tag {
	description: String
	id: String!
	name: String
	type: String
}

type targetedPermissionSchema {
	permissionSchema: permissionSchema
	targetIds: [String!]!
}

"A permission applied to a user or a target group"
type targettedPermission {
	permission: permission
	targetIds: [String!]!
}

type tax {
	calculationLogic: String
	code: String
	createdAt: DateTime
	createdBy: login
	flat: Decimal
	formattedFlat: String
	formattedNewPrice: String
	formattedOriginalPrice: String
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
	newPrice: Decimal
	order: Int
	originalPrice: Decimal
	ratio: Decimal
}

type templateRelationship {
	action: String!
	id: String!
	template: templateInterface
}

type templateRenderParameters {
	contentJsonString: String
	name: String!
	variablesJsonString: String
}

type templateRendering {
	input: templateRenderParameters
	templateId: String!
}

"Template query"
type templates {
	list: [templateInterface]
	totalCount: Int!
}

type templates_GenericTemplateStatistics8QueryInterface {
	list: [templates_TemplateStatistics]
	totalCount: Long!
}

type templates_TemplateStatistics {
	createdAt: DateTime!
	createdById: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	productCode: String
	templateId: String
	vendor: String
}

type tenantSettings {
	hosts: [String]
	tenantId: String
}

"A securitiy token response"
type token {
	accessToken: String
	error: String
	errorDescription: String
	expiresIn: Int
	identityToken: String
	refreshToken: String
	requiresTwoFactor: Boolean
	tokenType: String
}

type tokenPaymentMethod implements paymentMethodInterface {
	createdAt: DateTime
	createdBy: login
	entityId: String
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	name: String
}

"Access tokens"
type tokenResult {
	errors: [String]
	status: String!
	token: token
}

"A transaction"
type transaction {
	accountCode: String
	accountType: String
	amount: Decimal
	approvalCode: String
	attachments: [attachment]
	createdAt: DateTime
	createdBy: login
	currencyCode: currencyCodeEnumeration
	dateTime: DateTimeOffset
	debitNoteNumber: String
	description: String
	dueDateTime: DateTimeOffset
	endorsementId: String
	events: [eventLog]
	facts: [fact]
	fields: String
	formattedTransaction: String
	id: ID!
	isSettled: Boolean
	lastModifiedAt: DateTime
	lastModifiedBy: login
	method: paymentMethod
	notes: [note]
	object: objectUnion
	policy: policy
	postDateTime: DateTimeOffset
	providerTransactionId: String
	settledToTransactionId: String
	settledTransactions(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput
	): transactions
	stakeholders: [stakeholder]
	status: String
	subscription: subscription
	transactionNumber: String
	type: String
}

type transactionRedirection {
	httpMethod: String!
	parameters: scalarValue
	parametersJsonString: String
	token: String
	transactionId: String!
	url: String
}

type transactionRedirectionResult {
	errors: [String]
	status: String
	value: transactionRedirection
}

"Gets all transactions"
type transactions {
	list: [transaction]
	totalCount: Int!
}

type transactions_CreateCheckoutSessionResponse {
	publicKey: String
	sessionId: String
	url: String
}

type transactions_CreatedStatus {
	id: String
	ids: [String]
}

type transactions_Error {
	code: String
	message: String
}

type transactions_PaymentProviderPrice {
	priceList: [String]
}

type transactions_PaymentProviderProduct {
	productList: [String]
}

type transactions_Result {
	errors: [String]
	errors_2: [transactions_Error]
	isSuccess: Boolean!
	status: String
}

type transactions_ResultOfCreateCheckoutSessionResponse {
	errors: [String]
	errors_2: [transactions_Error]
	isSuccess: Boolean!
	status: String
	value: transactions_CreateCheckoutSessionResponse
}

type transactions_ResultOfCreatedStatus {
	errors: [String]
	errors_2: [transactions_Error]
	isSuccess: Boolean!
	status: String
	value: transactions_CreatedStatus
}

type transactions_SubsCription {
	subsCriptionObjectString: String
}

type treatment {
	category: String
	code: String
	id: String
	name: String
	subSystem: String
	system: String
}

type treatments {
	list: [treatment]
	totalCount: Int!
}

type uiSchema {
	createdAt: DateTime
	id: String!
	lastModifiedAt: DateTime
	name: String!
	schema: String!
	standard: uiSchemaStandardGraphType
}

type uiSchemaStandardGraphType {
	type: uiSchemaStandardTypeEnum
	version: String
}

type uiSchemas {
	list: [uiSchema]
	totalCount: Int
}

type underwriting {
	excelPath: String
	excelRules: excelRule
	jsonLogicRules: String
	jsonSchema(
		"A list of dynamic values to be sent to the underwriting engine."
		values: [keyValueInput]
	): String
	sourceType: String
	variables: [underwritingVariable]
}

type underwritingVariable {
	description: String
	id: String
	jsonSchemaValidation: String
	name: String
}

type updateAddressCommand {
	commandId: String
	entityId: String
	fields: [field]
	id: String
	modifiedBy: login
	timestamp: DateTime
	type: String
}

"Chosen beneficiary eligibility"
type updateBeneficiaryEligibility {
	benefitTypeId: String
	entityId: String
	isBenefitTypeIdChanged: Boolean!
	isEntityIdChanged: Boolean!
	isIsRevocableChanged: Boolean!
	isNotesChanged: Boolean!
	isRatioChanged: Boolean!
	isRevocable: Boolean
	notes: String
	ratio: Decimal
}

"A command to update a contact"
type updateContactCommand {
	commandId: String
	entityId: String
	id: String
	modifiedBy: login
	timestamp: DateTime
	type: String
	value: String
}

type updateContractCompanyCommand {
	acceptsMarketing: Boolean
	commandId: String
	entityId: String
	id: String
	internalCode: String
	isAcceptsMarketingChanged: Boolean!
	isIdChanged: Boolean!
	isInternalCodeChanged: Boolean!
	isNameFormatChanged: Boolean!
	isNatureOfBusinessChanged: Boolean
	isPhotoPathChanged: Boolean!
	isRegistrationNumberChanged: Boolean
	isSourceChanged: Boolean!
	modifiedBy: login
	nameFormat: String
	natureOfBusiness: String
	photoPath: String
	registrationNumber: String
	source: String
	timestamp: DateTime
}

"A command to update an individual"
type updateContractIndividualCommand {
	acceptsMarketing: Boolean
	chineseFirstName: String
	chineseLastName: String
	commandId: String
	countryOfResidency: String
	dateOfBirth: Date
	employmentStatus: String
	englishFirstName: String
	englishLastName: String
	gender: String
	id: String
	incomeRange: range
	internalCode: String
	isAcceptsMarketingChanged: Boolean!
	isChineseFirstNameChanged: Boolean!
	isChineseLastNameChanged: Boolean!
	isCountryOfResidencyChanged: Boolean!
	isDateOfBirthChanged: Boolean!
	isEmploymentStatusChanged: Boolean!
	isEnglishFirstNameChanged: Boolean!
	isEnglishLastNameChanged: Boolean!
	isGenderChanged: Boolean!
	isIdChanged: Boolean
	isIncomeRangeChanged: Boolean!
	isInternalCodeChanged: Boolean!
	isMaritalStatusChanged: Boolean!
	isNameFormatChanged: Boolean!
	isOccupationChanged: Boolean!
	isPhotoPathChanged: Boolean!
	isPreferredCommunicationChannelChanged: Boolean!
	isPreferredLanguageChanged: Boolean!
	isSalutationChanged: Boolean!
	isSourceChanged: Boolean!
	isTypeChanged: Boolean!
	maritalStatus: String
	modifiedBy: login
	nameFormat: String
	occupation: String
	photoPath: String
	preferredCommunicationChannel: String
	preferredLanguage: String
	salutation: String
	source: String
	timestamp: DateTime
	type: individualTypeEnumeration
}

type updateContractObjectCommand {
	commandId: String
	id: String
	internalCode: String
	isIdChanged: Boolean!
	isInternalCodeChanged: Boolean!
	isNameFormatChanged: Boolean!
	isPhotoPathChanged: Boolean!
	isSourceChanged: Boolean!
	isTypeIdChanged: Boolean!
	modifiedBy: login
	nameFormat: String
	photoPath: String
	source: String
	timestamp: DateTime
	typeId: String
}

type updateDiscountCommand {
	calculationJsonLogic: String
	commandId: String
	discountId: String
	isCalculationJsonLogicChanged: Boolean
	isNameChanged: Boolean
	isOrderChanged: Boolean
	modifiedBy: login
	name: String
	order: Int
	timestamp: DateTime
}

"An update fact command"
type updateFactCommand {
	commandId: String
	entityId: String
	id: String
	isTypeChanged: Boolean!
	isValueChanged: Boolean!
	modifiedBy: login
	timestamp: DateTime
	type: String
	value: scalarValue
}

"A command to update an identity"
type updateIdentityCommand {
	commandId: String
	entityId: String
	id: String
	modifiedBy: login
	timestamp: DateTime
	type: String
	value: String
}

type updateLoadingCommand {
	calculationJsonLogic: String
	code: String
	commandId: String
	flat: Decimal
	isCalculationJsonLogicChanged: Boolean
	isCodeChanged: Boolean
	isFlatChanged: Boolean
	isOrderChanged: Boolean
	isRatioChanged: Boolean
	modifiedBy: login
	order: Int
	ratio: Decimal
	timestamp: DateTime
}

"the payment information to update"
type updatePaymentInfo {
	amount: Decimal
	comment: String
	currencyCode: currencyCodeEnumeration
	endDate: DateTime
	frequency: paymentFrequency
	isAmountChanged: Boolean!
	isCommentChanged: Boolean!
	isCurrencyCodeChanged: Boolean!
	isEndDateChanged: Boolean!
	isFrequencyChanged: Boolean!
	isMethodChanged: Boolean!
	isNameChanged: Boolean!
	isPayorIdChanged: Boolean!
	isStartDateChanged: Boolean!
	method: paymentMethod
	name: String
	payorId: String
	startDate: DateTime
}

"initializes or updates a policy"
type updatePolicyGraphType {
	commandId: String
	contractHolderCompany: updateContractCompanyCommand
	contractHolderIndividual: updateContractIndividualCommand
	description: String
	endDate: Date
	holderId: String @deprecated(reason: "use the specific entity field updates instead")
	insuredIds: [String] @deprecated(reason: "use the specific entity field updates instead")
	isContractHolderCompanyChanged: Boolean!
	isContractHolderIndividualChanged: Boolean!
	isDescriptionChanged: Boolean!
	isEndDateChanged: Boolean!
	isHolderIdChanged: Boolean! @deprecated(reason: "use the specific entity field updates instead")
	isInsuredIdsChanged: Boolean! @deprecated(reason: "use the specific entity field updates instead")
	isIssueDateChanged: Boolean!
	isIssuerNumberChanged: Boolean!
	isPremiumChanged: Boolean!
	isProductIdChanged: Boolean!
	isReferralCodeChanged: Boolean!
	isSourceChanged: Boolean!
	isStartDateChanged: Boolean!
	isStatusChanged: Boolean!
	isValuesChanged: Boolean!
	issueDate: Date
	issuerNumber: String
	modifiedBy: login
	premium: premiumToUpdate
	productId: productIdToUpdate
	referralCode: String
	source: String
	startDate: Date
	status: String
	timestamp: DateTime
	values: [keyValue]
}

"Chosen benefit option"
type upsertBenefitOption {
	"Input the key if the benefit has a set of options"
	key: String
	offerId: String
	typeId: String!
	value: scalarValue
}

type upsertBenefitOptionCommand {
	commandId: String
	insuredId: String
	key: String
	timestamp: DateTime
	typeId: String
	upsertedBy: login
	value: scalarValue
}

type urlRouting {
	order: Int
	regexPattern: String
	url: String
}

"Stored data item containing dynamic fields set up by FE"
type userStorageItem {
	createdAt: Date
	createdById: String
	fields: String
	key: String!
	lastModifiedAt: Date
	lastModifiedById: String
}

"Stored items for current user"
type userStorageItems {
	count(
		"filter"
		where: userStorageItemsWhereInput
	): Int!
	list(
		"Limit of items to query"
		limit: Int,
		"Skip an amount of items"
		skip: Int,
		"sort items"
		sort: sortInput,
		"filter"
		where: userStorageItemsWhereInput
	): [userStorageItem]
}

type users_Address {
	fields: [users_KeyValuePairOfStringAndString!]
	id: String
	type: String
}

type users_AgentReminder {
	agentCode: String
	branchCode: String
	count: Int!
	createdAt: DateTime!
	createdById: String
	from: DateTime
	id: String
	isChecked: Boolean!
	lastModifiedAt: DateTime!
	lastModifiedById: String
	to: DateTime
	type: String
}

type users_AgreedFee {
	createdAt: DateTime!
	createdById: String
	currency: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	organizationNegotiatedItem: users_OrganizationNegotiatedItem
	rate: Decimal
}

type users_AgreedFeeGroup {
	agreedFees: [users_AgreedFee]
	createdAt: DateTime!
	createdById: String
	from: DateTime
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	remarks: String
	to: DateTime
}

type users_AttachedRulesQueryInterfaceOfusersAttachedCommandPermissionAndusers_AttachedRuleFilter {
	count: Long!
	list: [users_usersAttachedCommandPermission]
}

type users_AttachedRulesQueryInterfaceOfusersAttachedExternalApiCallAndusers_AttachedRuleFilter {
	count: Long!
	list: [users_usersAttachedExternalApiCall]
}

type users_AttachedRulesQueryInterfaceOfusersAttachedFilterAndusers_AttachedRuleFilter {
	count: Long!
	list: [users_usersAttachedFilter]
}

type users_AttachedRulesQueryInterfaceOfusersAttachedObjectValidationAndusers_AttachedRuleFilter {
	count: Long!
	list: [users_usersAttachedObjectValidation]
}

type users_AttachedRulesQueryInterfaceOfusersAttachedPostHandleValidationAndusers_AttachedRuleFilter {
	count: Long!
	list: [users_usersAttachedPostHandleValidation]
}

type users_Attachment {
	createdAt: DateTime!
	createdById: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	path: String
}

type users_Contact {
	id: String
	type: String
	value: String
}

type users_CreatedStatus {
	id: String
	ids: [String]
}

type users_Diagnosis {
	chapter: String
	classKind: String
	code: String
	createdAt: DateTime!
	createdById: String
	depthInKind: Int
	fields: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	title: String
}

type users_Error {
	code: String
	message: String
}

type users_ExternalApiCall {
	afterCall: [String!]
	beforeCall: [String!]
	contentType: String
	contextSlug: String
	expectedContentExpression: String
	expectedResponseExpression: String
	headers: [users_KeyValuePairOfStringAndString!]
	itemValidationExpression: String
	method: String!
	stringContent: String
	timeout: String
	url: String!
}

type users_Fact {
	id: String
	type: String
	value: String
}

type users_GenericAgentReminder8QueryInterface {
	list: [users_AgentReminder]
	totalCount: Long!
}

type users_GenericAgreedFee8QueryInterface {
	list: [users_AgreedFee]
	totalCount: Long!
}

type users_GenericAgreedFeeGroup8QueryInterface {
	list: [users_AgreedFeeGroup]
	totalCount: Long!
}

type users_GenericNegotiatedItem8QueryInterface {
	list: [users_NegotiatedItem]
	totalCount: Long!
}

type users_GenericNetwork8QueryInterface {
	list: [users_Network]
	totalCount: Long!
}

type users_GenericOrganizationNegotiatedItem8QueryInterface {
	list: [users_OrganizationNegotiatedItem]
	totalCount: Long!
}

type users_GenericOrganizationProviderTier8QueryInterface {
	list: [users_OrganizationProviderTier]
	totalCount: Long!
}

type users_GenericServiceRate8QueryInterface {
	list: [users_ServiceRate]
	totalCount: Long!
}

type users_GenericServicingAgentChangeLog8QueryInterface {
	list: [users_ServicingAgentChangeLog]
	totalCount: Long!
}

type users_Identity {
	id: String
	type: String
	value: String
}

type users_Integration {
	externalEntityId: String
	externalProductId: String
	systemId: String
}

type users_KeyValuePairOfStringAndString {
	key: String!
	value: String!
}

type users_NegotiatedItem {
	createdAt: DateTime!
	createdById: String
	fields: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
}

type users_Network {
	createdAt: DateTime!
	createdById: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	metroValue: Decimal!
	pointValue: Decimal!
	type: String
}

type users_Note {
	content: String
	createdAt: DateTime!
	createdById: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	title: String
}

type users_Organization {
	addresses: [users_Address]
	attachments: [users_Attachment]
	contacts: [users_Contact]
	createdAt: DateTime!
	createdById: String
	email: String
	entityId: String
	entityType: String
	facts: [users_Fact]
	fields: String
	identities: [users_Identity]
	internalCode: String
	isActive: Boolean!
	lastModifiedAt: DateTime!
	lastModifiedById: String
	name: String
	nameFormat: String
	notes: [users_Note]
	photoPath: String
	referalCode: String
	source: String
	status: String
	tags: [String]
	type: String
}

type users_OrganizationNegotiatedItem {
	createdAt: DateTime!
	createdById: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	negotiatedItem: users_NegotiatedItem
	organization: users_Organization
	organizationCode: String
}

type users_OrganizationProviderTier {
	agreedFeeGroups: [users_AgreedFeeGroup]
	createdAt: DateTime!
	createdById: String
	description: String
	fields: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	name: String
	organization: users_Organization
}

type users_Result {
	errors: [String]
	errors_2: [users_Error]
	isSuccess: Boolean!
	status: String
}

type users_ResultOfCreatedStatus {
	errors: [String]
	errors_2: [users_Error]
	isSuccess: Boolean!
	status: String
	value: users_CreatedStatus
}

type users_ResultOfIntegration {
	errors: [String]
	errors_2: [users_Error]
	isSuccess: Boolean!
	status: String
	value: users_Integration
}

type users_ResultOfString {
	errors: [String]
	errors_2: [users_Error]
	isSuccess: Boolean!
	status: String
	value: String
}

type users_ServiceRate {
	createdAt: DateTime!
	createdById: String
	doctorId: String
	id: String!
	lastModifiedAt: DateTime!
	lastModifiedById: String
	networkType: String!
	providerId: String
	rate: Decimal!
	serviceCode: String!
}

type users_ServicingAgentChangeLog {
	createdAt: DateTime!
	createdById: String
	currentServicingAgentCode: String
	currentServicingAgentName: String
	errorCode: String
	id: String
	lastModifiedAt: DateTime!
	lastModifiedById: String
	message: String
	newServicingAgentCode: String
	newServicingAgentName: String
	policyName: String
	policyNo: String
	status: String
}

type users_usersAttachedCommandPermission {
	action: users_AttachedRuleAllowAction!
	command: String!
	commandExpression: String
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

type users_usersAttachedExternalApiCall {
	apiCalls: [users_ExternalApiCall!]!
	description: String
	eventExpression: String
	forEach: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

type users_usersAttachedFilter {
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

type users_usersAttachedObjectValidation {
	action: users_AttachedRuleAllowAction!
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

type users_usersAttachedPostHandleValidation {
	action: users_AttachedRuleAllowAction!
	description: String
	eventExpression: String
	group: Int!
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

"A result object with potential errors"
type validatePolicyResult {
	errors: [String!]
	errors_2: [errors!]
	planName: String!
	policyNumber: String!
	"'success' or 'failure'"
	status: String!
}

type validateProductResult {
	errors: [errors]
	productId: productId
	status: String!
}

type wkhtmltopdfTemplate implements templateInterface {
	createdAt: DateTime
	createdBy: login
	description: String
	events: [eventLog]
	footerSettings: headerFooter
	graphQlQuery: String
	headerSettings: headerFooter
	html: String!
	id: String!
	lastModifiedAt: DateTime
	lastModifiedBy: login
	logicalId: String
	marginSettings: marginSettings
	name: String
	orientation: orientationEnumeration
	pageObjects: [pageObject]
	password: String
	passwordLiquid: String
	tags: [String]!
	type: String
}

enum ApplyPolicy {
	AFTER_RESOLVER
	BEFORE_RESOLVER
}

enum ClaimInvestigationStatus {
	CLOSED
	NOT_OPENED
	OPENED
}

enum ConsentRequestStatus {
	APPROVED
	CANCELLED
	REJECTED
	SENT
}

enum EscalatedClaimStatus {
	ESCALATED
	INVESTIGATION_CLOSED
	NOT_ESCALATED
}

enum EventConsumeStatus {
	ERROR
	SKIPPED
	SUCCESS
}

enum EvidenceRequestStatus {
	CANCELLED
	COLLECTED
	RECEIVED
	REMINDER_SENT
	SENT
}

enum FieldsDiffType {
	ADD
	REMOVE
	UPDATE
}

enum HotChocolate_SortEnumType {
	ASC
	DESC
}

enum Language {
	CLEAR_SCRIPT
	CONSTANT
	"A Clear Script function receiving a single context parameter"
	CONTEXT_FORMULA
	GRAPHQL
	"A Clear Script function receiving two parameters: input and fields"
	LOCAL_FORMULA
	MATHJS
}

enum PolicyMemberUnderwritingResult {
	APPROVED
	MANUAL_APPROVED
	MANUAL_PENDING
	MANUAL_REJECTED
	PENDING
	REJECTED
}

enum PolicyMemberValidationResult {
	INVALID
	VALID
}

enum SortEnumType {
	ASC
	DESC
}

enum TenantStatus {
	ACTIVE
	INACTIVE
}

enum TraceStepType {
	FIELD_INVOKED
	FIELD_REFERENCED
	FIELD_RESOLVED
}

enum billing_BillingBillStatus {
	CREATED
	ISSUED
	OVERDUE
	PAID
}

enum billing_BillingPeriod {
	ANNUAL
	DAILY
	MONTHLY
	QUARTERLY
	WEEKLY
}

enum billing_BillingPremiumInstallmentStatus {
	CREATED
	PREMIUM_COLLECTED
	PREMIUM_COLLECTION_FAILED
	REVENUE_OWED
}

enum billing_CurrencyCode {
	ADP
	AED
	AFA
	AFN
	ALK
	ALL
	AMD
	ANG
	AOA
	AOK
	AON
	AOR
	ARA
	ARP
	ARS
	ARY
	ATS
	AUD
	AWG
	AYM
	AZM
	AZN
	BAD
	BAM
	BBD
	BDS
	BDT
	BEC
	BEF
	BEL
	BGJ
	BGK
	BGL
	BGN
	BHD
	BIF
	BMD
	BND
	BOB
	BOP
	BOV
	BRB
	BRC
	BRE
	BRL
	BRN
	BRR
	BSD
	BTN
	BUK
	BWP
	BYB
	BYN
	BYR
	BZD
	CAD
	CDF
	CHC
	CHE
	CHF
	CHW
	CLF
	CLP
	CNX
	CNY
	COP
	COU
	CRC
	CSD
	CSJ
	CSK
	CUC
	CUP
	CVE
	CYP
	CZK
	DDM
	DEM
	DJF
	DKK
	DOP
	DZD
	ECS
	ECV
	EEK
	EGP
	ERN
	ESA
	ESB
	ESP
	ETB
	EUR
	FIM
	FJD
	FKP
	FRF
	GBP
	GEK
	GEL
	GHC
	GHP
	GHS
	GIP
	GMD
	GNE
	GNF
	GNS
	GQE
	GRD
	GTQ
	GWE
	GWP
	GYD
	HKD
	HNL
	HRD
	HRK
	HTG
	HUF
	IDR
	IEP
	ILP
	ILR
	ILS
	INR
	IQD
	IRR
	ISJ
	ISK
	ITL
	JMD
	JOD
	JPY
	KES
	KGS
	KHR
	KMF
	KPW
	KRW
	KWD
	KYD
	KZT
	LAJ
	LAK
	LBP
	LKR
	LRD
	LSL
	LSM
	LTL
	LTT
	LUC
	LUF
	LUL
	LVL
	LVR
	LYD
	MAD
	MDL
	MGA
	MGF
	MKD
	MLF
	MMK
	MNT
	MOP
	MRO
	MTL
	MTP
	MUR
	MVQ
	MVR
	MWK
	MXN
	MXV
	MYR
	MZE
	MZM
	MZN
	NAD
	NGN
	NIC
	NIO
	NLG
	NOK
	NPR
	NZD
	OMR
	PAB
	PEH
	PEI
	PEN
	PES
	PGK
	PHP
	PKR
	PLN
	PLZ
	PTE
	PYG
	QAR
	RHD
	ROK
	ROL
	RON
	RSD
	RUB
	RUR
	RWF
	SAR
	SBD
	SCR
	SDD
	SDG
	SDP
	SEK
	SGD
	SHP
	SIT
	SKK
	SLL
	SOS
	SRD
	SRG
	SSP
	STD
	SUR
	SVC
	SYP
	SZL
	THB
	TJR
	TJS
	TMM
	TMT
	TND
	TOP
	TPE
	TRL
	TRY
	TTD
	TWD
	TZS
	UAH
	UAK
	UGS
	UGW
	UGX
	UNDEFINED
	USD
	USN
	USS
	UYI
	UYN
	UYP
	UYU
	UZS
	VEB
	VEF
	VNC
	VND
	VUV
	WST
	XAF
	XAG
	XAU
	XBA
	XBB
	XBC
	XBD
	XCD
	XDR
	XEU
	XFO
	XFU
	XOF
	XPD
	XPF
	XPT
	XRE
	XSU
	XTS
	XUA
	XXX
	YDD
	YER
	YUD
	YUM
	YUN
	ZAL
	ZAR
	ZMK
	ZMW
	ZRN
	ZRZ
	ZWC
	ZWD
	ZWL
	ZWN
	ZWR
}

enum billing_DirectDebitPaymentChannelStatus {
	CREATED
	DELETED
}

enum billing_EndorsementSource {
	ADMIN_PORTAL
	HR_PORTAL
}

enum billing_FieldsDiffType {
	ADD
	REMOVE
	UPDATE
}

enum billing_ManualPaymentChannelStatus {
	CREATED
	DELETED
	PARTIALLY_SUCCEEDED
	SUCCEEDED
}

enum billing_PaymentChannelType {
	DIRECT_DEBIT
	MANUAL
}

enum billing_PaymentFrequency {
	ANNUALLY
	MONTHLY
	ONE_TIME
	QUARTERLY
	SEMI_ANNUALLY
}

enum billing_PaymentMethodType {
	ATM
	BANK_TRANSFER
	CASH
	CHEQUE
	CPF
	CREDIT_CARD
	GIRO
	SELF_SERVICE_PAYMENT_MACHINE
}

enum billing_PolicyEventType {
	ACCEPT_ENDORSEMENT
	ADD_ADD_ASSOCIATED_CONTRACT_TO_POLICY_TO_ENDORSEMENT
	ADD_ADD_CLAUSE_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_HOLDER_ADDRESS_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_HOLDER_CONTACT_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_HOLDER_FACT_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_HOLDER_IDENTITY_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_INSURED_ADDRESS_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_INSURED_CONTACT_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_INSURED_FACT_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_INSURED_IDENTITY_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_INSURED_TO_ENDORSEMENT
	ADD_ADD_DISCOUNT_TO_ENDORSEMENT
	ADD_ADD_LOADING_TO_ENDORSEMENT
	ADD_ADD_OTHER_CONTRACT_HOLDER_ADDRESS_TO_ENDORSEMENT
	ADD_ADD_OTHER_CONTRACT_HOLDER_CONTACT_TO_ENDORSEMENT
	ADD_ADD_OTHER_CONTRACT_HOLDER_FACT_TO_ENDORSEMENT
	ADD_ADD_OTHER_CONTRACT_HOLDER_IDENTITY_TO_ENDORSEMENT
	ADD_ADD_OTHER_CONTRACT_HOLDER_TO_ENDORSEMENT
	ADD_ADD_POLICY_FACT_TO_ENDORSEMENT
	ADD_ASSOCIATED_CONTRACT_TO_POLICY
	ADD_ATTACHMENT
	ADD_BENEFICIARY_ELIGIBILITY
	ADD_CLAUSE_TO_POLICY
	ADD_COMMISSION
	ADD_CONTRACT_HOLDER_ADDRESS
	ADD_CONTRACT_HOLDER_CONTACT
	ADD_CONTRACT_HOLDER_FACT
	ADD_CONTRACT_HOLDER_IDENTITY
	ADD_CONTRACT_INSURED
	ADD_CONTRACT_INSURED_ADDRESS
	ADD_CONTRACT_INSURED_CONTACT
	ADD_CONTRACT_INSURED_FACT
	ADD_CONTRACT_INSURED_IDENTITY
	ADD_DISCOUNT
	ADD_DISCOUNT_TO_OFFER
	ADD_ENDORSEMENT
	ADD_EXCLUSION
	ADD_EXCLUSION_TO_OFFER
	ADD_INSURED
	ADD_LOADING
	ADD_LOADING_TO_OFFER
	ADD_NOTE
	ADD_OFFER
	ADD_OTHER_CONTRACT_HOLDER
	ADD_OTHER_CONTRACT_HOLDER_ADDRESS
	ADD_OTHER_CONTRACT_HOLDER_CONTACT
	ADD_OTHER_CONTRACT_HOLDER_FACT
	ADD_OTHER_CONTRACT_HOLDER_IDENTITY
	ADD_OTHER_HOLDER
	ADD_PAYMENT_INFO
	ADD_POLICY_FACT
	ADD_REMOVE_ASSOCIATED_CONTRACT_TO_POLICY_TO_ENDORSEMENT
	ADD_REMOVE_BENEFIT_OPTION_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_HOLDER_ADDRESS_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_HOLDER_CONTACT_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_HOLDER_FACT_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_HOLDER_IDENTITY_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_INSURED_ADDRESS_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_INSURED_CONTACT_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_INSURED_FACT_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_INSURED_IDENTITY_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_INSURED_TO_ENDORSEMENT
	ADD_REMOVE_DISCOUNT_TO_ENDORSEMENT
	ADD_REMOVE_LOADING_TO_ENDORSEMENT
	ADD_REMOVE_OTHER_CONTRACT_HOLDER_ADDRESS_TO_ENDORSEMENT
	ADD_REMOVE_OTHER_CONTRACT_HOLDER_CONTACT_TO_ENDORSEMENT
	ADD_REMOVE_OTHER_CONTRACT_HOLDER_FACT_TO_ENDORSEMENT
	ADD_REMOVE_OTHER_CONTRACT_HOLDER_IDENTITY_TO_ENDORSEMENT
	ADD_REMOVE_OTHER_CONTRACT_HOLDER_TO_ENDORSEMENT
	ADD_REMOVE_POLICY_FACT_TO_ENDORSEMENT
	ADD_STAKEHOLDER_TO_POLICY
	ADD_TAG
	ADD_UPDATE_BENEFICIARY_ELIGIBILITY_TO_UPDATE_REQUEST
	ADD_UPDATE_CONTRACT_HOLDER_ADDRESS_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_HOLDER_COMPANY_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_HOLDER_CONTACT_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_HOLDER_FACT_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_HOLDER_IDENTITY_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_HOLDER_INDIVIDUAL_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_ADDRESS_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_COMPANY_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_CONTACT_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_FACT_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_IDENTITY_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_INDIVIDUAL_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_OBJECT_TO_ENDORSEMENT
	ADD_UPDATE_DISCOUNT_TO_ENDORSEMENT
	ADD_UPDATE_LOADING_TO_ENDORSEMENT
	ADD_UPDATE_OTHER_CONTRACT_HOLDER_ADDRESS_TO_ENDORSEMENT
	ADD_UPDATE_OTHER_CONTRACT_HOLDER_COMPANY_TO_ENDORSEMENT
	ADD_UPDATE_OTHER_CONTRACT_HOLDER_CONTACT_TO_ENDORSEMENT
	ADD_UPDATE_OTHER_CONTRACT_HOLDER_FACT_TO_ENDORSEMENT
	ADD_UPDATE_OTHER_CONTRACT_HOLDER_IDENTITY_TO_ENDORSEMENT
	ADD_UPDATE_OTHER_CONTRACT_HOLDER_INDIVIDUAL_TO_ENDORSEMENT
	ADD_UPDATE_PAYMENT_INFO_TO_UPDATE_REQUEST
	ADD_UPDATE_POLICY_FACT_TO_ENDORSEMENT
	ADD_UPDATE_POLICY_TO_ENDORSEMENT
	ADD_UPDATE_POLICY_TO_UPDATE_REQUEST
	ADD_UPDATE_PRODUCT_TO_ENDORSEMENT
	ADD_UPSERT_BENEFIT_OPTION_TO_ENDORSEMENT
	ADD_UPSERT_BENEFIT_OPTION_TO_UPDATE_REQUEST
	CACHE_PRICING
	CANCEL
	CANCEL_ENDORSEMENT
	CLAUSE_BATCH_TO_ENDORSEMENT
	CLAUSE_BATCH_TO_POLICY
	COMPLETE
	CONTRACT_HOLDER_FACT_BATCH
	CONVERT_OFFER
	CREATE_UPDATE_REQUEST
	CREATION
	DELETE
	DELETE_UPDATE_REQUEST
	INITIALIZE_PAYMENT
	LEGACY_IMPORT
	PAYMENT
	POLICY_FACT_BATCH
	POLICY_JACKET_BATCH
	POLICY_JACKET_BATCH_TO_ENDORSEMENTS
	REFUND
	REJECT
	REJECT_ENDORSEMENT
	REMOVE_ASSOCIATED_CONTRACT_OF_POLICY
	REMOVE_ATTACHMENT
	REMOVE_BENEFICIARY_ELIGIBILITY
	REMOVE_BENEFIT_OPTION
	REMOVE_BENEFIT_OPTION_FROM_POLICY
	REMOVE_CLAUSE_FROM_POLICY
	REMOVE_COMMAND_FROM_ENDORSEMENT
	REMOVE_COMMISSION
	REMOVE_CONTRACT_HOLDER_ADDRESS
	REMOVE_CONTRACT_HOLDER_CONTACT
	REMOVE_CONTRACT_HOLDER_FACT
	REMOVE_CONTRACT_HOLDER_IDENTITY
	REMOVE_CONTRACT_INSURED
	REMOVE_CONTRACT_INSURED_ADDRESS
	REMOVE_CONTRACT_INSURED_CONTACT
	REMOVE_CONTRACT_INSURED_FACT
	REMOVE_CONTRACT_INSURED_IDENTITY
	REMOVE_DISCOUNT
	REMOVE_DISCOUNT_FROM_OFFER
	REMOVE_ENDORSEMENT
	REMOVE_EXCLUSION
	REMOVE_EXCLUSION_FROM_OFFER
	REMOVE_INSURED
	REMOVE_JACKET_FROM_POLICY
	REMOVE_JACKET_FROM_POLICY_TO_ENDORSEMENT
	REMOVE_LOADING
	REMOVE_LOADING_FROM_OFFER
	REMOVE_NOTE
	REMOVE_OFFER
	REMOVE_OTHER_CONTRACT_HOLDER
	REMOVE_OTHER_CONTRACT_HOLDER_ADDRESS
	REMOVE_OTHER_CONTRACT_HOLDER_CONTACT
	REMOVE_OTHER_CONTRACT_HOLDER_FACT
	REMOVE_OTHER_CONTRACT_HOLDER_IDENTITY
	REMOVE_OTHER_HOLDER
	REMOVE_PAYMENT_INFO
	REMOVE_POLICY_FACT
	REMOVE_STAKEHOLDER_FROM_POLICY
	REMOVE_TAG
	REVIEW_UPDATE_REQUEST
	SUBMIT_ENDORSEMENT
	UPDATE_ATTACHMENT
	UPDATE_BENEFICIARY_ELIGIBILITY
	UPDATE_CLAUSE_OF_POLICY
	UPDATE_COMMISSION
	UPDATE_CONTRACT_HOLDER_ADDRESS
	UPDATE_CONTRACT_HOLDER_COMPANY
	UPDATE_CONTRACT_HOLDER_CONTACT
	UPDATE_CONTRACT_HOLDER_FACT
	UPDATE_CONTRACT_HOLDER_IDENTITY
	UPDATE_CONTRACT_HOLDER_INDIVIDUAL
	UPDATE_CONTRACT_INSURED_ADDRESS
	UPDATE_CONTRACT_INSURED_COMPANY
	UPDATE_CONTRACT_INSURED_CONTACT
	UPDATE_CONTRACT_INSURED_FACT
	UPDATE_CONTRACT_INSURED_IDENTITY
	UPDATE_CONTRACT_INSURED_INDIVIDUAL
	UPDATE_CONTRACT_INSURED_OBJECT
	UPDATE_DISCOUNT
	UPDATE_DISCOUNT_OF_OFFER
	UPDATE_ENDORSEMENT
	UPDATE_LOADING
	UPDATE_LOADING_OF_OFFER
	UPDATE_NOTE
	UPDATE_OFFER
	UPDATE_OTHER_CONTRACT_HOLDER_ADDRESS
	UPDATE_OTHER_CONTRACT_HOLDER_COMPANY
	UPDATE_OTHER_CONTRACT_HOLDER_CONTACT
	UPDATE_OTHER_CONTRACT_HOLDER_FACT
	UPDATE_OTHER_CONTRACT_HOLDER_IDENTITY
	UPDATE_OTHER_CONTRACT_HOLDER_INDIVIDUAL
	UPDATE_PAYMENT_INFO
	UPDATE_POLICY
	UPDATE_POLICY_FACT
	UPDATE_PRODUCT
	UPDATE_STAKEHOLDER_OF_POLICY
	UPDATE_TRANSACTION
	UPSERT_BENEFIT_OPTION
	UPSERT_BENEFIT_OPTION_BATCH
	UPSERT_BENEFIT_OPTION_OF_POLICY
}

enum cases_FieldsWhereCondition {
	ARRAY_CONTAINS
	EQUALS
	EXISTS
	GREATER_THAN
	IN
	LESS_THAN
	STRING_CONTAINS
}

enum cases_OrderByType {
	ASC
	DSC
}

enum cellType {
	BLANK
	BOOLEAN
	ERROR
	FORMULA
	NUMERIC
	STRING
	UNKNOWN
}

enum claims_AttachedRuleAllowAction {
	ALLOW
	DENY
}

enum claims_ClaimDataInsightGroupByType {
	MONTHLY
	WEEKLY
}

enum claims_ClaimDataInsightPeriod {
	LAST_FOUR_WEEKS
	LAST_SIX_MONTHS
	LAST_THREE_MONTHS
	POLICY_PERIOD
}

enum claims_ClaimEventType {
	ADD_ATTACHMENT
	ADD_BENEFIT
	ADD_FACT
	ADD_GUARANTEE_OF_PAYMENT
	ADD_NOTE
	ADD_STAKEHOLDER
	CREATE
	DELETE
	FACT_BATCH
	LEGACY_IMPORT
	REJECT
	REMOVE_ATTACHMENT
	REMOVE_BENEFIT
	REMOVE_FACT
	REMOVE_GUARANTEE_OF_PAYMENT
	REMOVE_NOTE
	REMOVE_STAKEHOLDER
	REVERSE
	UNDEFINED
	UPDATE
	UPDATE_ATTACHMENT
	UPDATE_BENEFIT
	UPDATE_FACT
	UPDATE_NOTE
	UPDATE_STAKEHOLDER
}

enum claims_CurrencyCode {
	ADP
	AED
	AFA
	AFN
	ALK
	ALL
	AMD
	ANG
	AOA
	AOK
	AON
	AOR
	ARA
	ARP
	ARS
	ARY
	ATS
	AUD
	AWG
	AYM
	AZM
	AZN
	BAD
	BAM
	BBD
	BDT
	BEC
	BEF
	BEL
	BGJ
	BGK
	BGL
	BGN
	BHD
	BIF
	BMD
	BND
	BOB
	BOP
	BOV
	BRB
	BRC
	BRE
	BRL
	BRN
	BRR
	BSD
	BTN
	BUK
	BWP
	BYB
	BYN
	BYR
	BZD
	CAD
	CDF
	CHC
	CHE
	CHF
	CHW
	CLF
	CLP
	CNX
	CNY
	COP
	COU
	CRC
	CSD
	CSJ
	CSK
	CUC
	CUP
	CVE
	CYP
	CZK
	DDM
	DEM
	DJF
	DKK
	DOP
	DZD
	ECS
	ECV
	EEK
	EGP
	ERN
	ESA
	ESB
	ESP
	ETB
	EUR
	FIM
	FJD
	FKP
	FRF
	GBP
	GEK
	GEL
	GHC
	GHP
	GHS
	GIP
	GMD
	GNE
	GNF
	GNS
	GQE
	GRD
	GTQ
	GWE
	GWP
	GYD
	HKD
	HNL
	HRD
	HRK
	HTG
	HUF
	IDR
	IEP
	ILP
	ILR
	ILS
	INR
	IQD
	IRR
	ISJ
	ISK
	ITL
	JMD
	JOD
	JPY
	KES
	KGS
	KHR
	KMF
	KPW
	KRW
	KWD
	KYD
	KZT
	LAJ
	LAK
	LBP
	LKR
	LRD
	LSL
	LSM
	LTL
	LTT
	LUC
	LUF
	LUL
	LVL
	LVR
	LYD
	MAD
	MDL
	MGA
	MGF
	MKD
	MLF
	MMK
	MNT
	MOP
	MRO
	MTL
	MTP
	MUR
	MVQ
	MVR
	MWK
	MXN
	MXV
	MYR
	MZE
	MZM
	MZN
	NAD
	NGN
	NIC
	NIO
	NLG
	NOK
	NPR
	NZD
	OMR
	PAB
	PEH
	PEI
	PEN
	PES
	PGK
	PHP
	PKR
	PLN
	PLZ
	PTE
	PYG
	QAR
	RHD
	ROK
	ROL
	RON
	RSD
	RUB
	RUR
	RWF
	SAR
	SBD
	SCR
	SDD
	SDG
	SDP
	SEK
	SGD
	SHP
	SIT
	SKK
	SLL
	SOS
	SRD
	SRG
	SSP
	STD
	SUR
	SVC
	SYP
	SZL
	THB
	TJR
	TJS
	TMM
	TMT
	TND
	TOP
	TPE
	TRL
	TRY
	TTD
	TWD
	TZS
	UAH
	UAK
	UGS
	UGW
	UGX
	UNDEFINED
	USD
	USN
	USS
	UYI
	UYN
	UYP
	UYU
	UZS
	VEB
	VEF
	VNC
	VND
	VUV
	WST
	XAF
	XAG
	XAU
	XBA
	XBB
	XBC
	XBD
	XCD
	XDR
	XEU
	XFO
	XFU
	XOF
	XPD
	XPF
	XPT
	XRE
	XSU
	XTS
	XUA
	XXX
	YDD
	YER
	YUD
	YUM
	YUN
	ZAL
	ZAR
	ZMK
	ZMW
	ZRN
	ZRZ
	ZWC
	ZWD
	ZWL
	ZWN
	ZWR
}

enum claims_FieldsWhereCondition {
	ARRAY_CONTAINS
	EQUALS
	EXISTS
	GREATER_THAN
	IN
	LESS_THAN
	STRING_CONTAINS
}

enum claims_OrderByType {
	ASC
	DSC
}

enum companyTypeEnumeration {
	CUSTOMER
	LEAD
	UNDEFINED
}

enum componentStatusEnumeration {
	DEPRECATED
	DRAFT
	PUBLISHED
}

"A list of all country code types"
enum countryCodeEnumGraphTypeEnum {
	HK
}

"A list of all possible currency codes"
enum currencyCodeEnumeration {
	ADP
	AED
	AFA
	AFN
	ALK
	ALL
	AMD
	ANG
	AOA
	AOK
	AON
	AOR
	ARA
	ARP
	ARS
	ARY
	ATS
	AUD
	AWG
	AYM
	AZM
	AZN
	BAD
	BAM
	BBD
	BDS
	BDT
	BEC
	BEF
	BEL
	BGJ
	BGK
	BGL
	BGN
	BHD
	BIF
	BMD
	BND
	BOB
	BOP
	BOV
	BRB
	BRC
	BRE
	BRL
	BRN
	BRR
	BSD
	BTN
	BUK
	BWP
	BYB
	BYN
	BYR
	BZD
	CAD
	CDF
	CHC
	CHE
	CHF
	CHW
	CLF
	CLP
	CNX
	CNY
	COP
	COU
	CRC
	CSD
	CSJ
	CSK
	CUC
	CUP
	CVE
	CYP
	CZK
	DDM
	DEM
	DJF
	DKK
	DOP
	DZD
	ECS
	ECV
	EEK
	EGP
	ERN
	ESA
	ESB
	ESP
	ETB
	EUR
	FIM
	FJD
	FKP
	FRF
	GBP
	GEK
	GEL
	GHC
	GHP
	GHS
	GIP
	GMD
	GNE
	GNF
	GNS
	GQE
	GRD
	GTQ
	GWE
	GWP
	GYD
	HKD
	HNL
	HRD
	HRK
	HTG
	HUF
	IDR
	IEP
	ILP
	ILR
	ILS
	INR
	IQD
	IRR
	ISJ
	ISK
	ITL
	JMD
	JOD
	JPY
	KES
	KGS
	KHR
	KMF
	KPW
	KRW
	KWD
	KYD
	KZT
	LAJ
	LAK
	LBP
	LKR
	LRD
	LSL
	LSM
	LTL
	LTT
	LUC
	LUF
	LUL
	LVL
	LVR
	LYD
	MAD
	MDL
	MGA
	MGF
	MKD
	MLF
	MMK
	MNT
	MOP
	MRO
	MTL
	MTP
	MUR
	MVQ
	MVR
	MWK
	MXN
	MXV
	MYR
	MZE
	MZM
	MZN
	NAD
	NGN
	NIC
	NIO
	NLG
	NOK
	NPR
	NZD
	OMR
	PAB
	PEH
	PEI
	PEN
	PES
	PGK
	PHP
	PKR
	PLN
	PLZ
	PTE
	PYG
	QAR
	RHD
	ROK
	ROL
	RON
	RSD
	RUB
	RUR
	RWF
	SAR
	SBD
	SCR
	SDD
	SDG
	SDP
	SEK
	SGD
	SHP
	SIT
	SKK
	SLL
	SOS
	SRD
	SRG
	SSP
	STD
	SUR
	SVC
	SYP
	SZL
	THB
	TJR
	TJS
	TMM
	TMT
	TND
	TOP
	TPE
	TRL
	TRY
	TTD
	TWD
	TZS
	UAH
	UAK
	UGS
	UGW
	UGX
	UNDEFINED
	USD
	USN
	USS
	UYI
	UYN
	UYP
	UYU
	UZS
	VEB
	VEF
	VNC
	VND
	VUV
	WST
	XAF
	XAG
	XAU
	XBA
	XBB
	XBC
	XBD
	XCD
	XDR
	XEU
	XFO
	XFU
	XOF
	XPD
	XPF
	XPT
	XRE
	XSU
	XTS
	XUA
	XXX
	YDD
	YER
	YUD
	YUM
	YUN
	ZAL
	ZAR
	ZMK
	ZMW
	ZRN
	ZRZ
	ZWC
	ZWD
	ZWL
	ZWN
	ZWR
}

"A list of all possible DataSchema standards"
enum dataSchemaStandardTypeEnum {
	JSON_SCHEMA
	STATE_CHART
}

"ui where endorsement was created"
enum endorsementSource {
	ADMIN_PORTAL
	HR_PORTAL
}

"A list of all possible conditions"
enum fieldsWhereCondition {
	ARRAY_CONTAINS
	EQUALS
	EXISTS
	GREATER_THAN
	IN
	LESS_THAN
	STRING_CONTAINS
}

enum fontStyleInput {
	BOLD
	BOLD_ITALIC
	ITALIC
	REGULAR
	STRIKEOUT
	UNDERLINE
}

enum individualTypeEnumeration {
	BENEFICIARY
	CUSTOMER
	LEAD
	PIPELINE
	PROCESSING
	UNDEFINED
}

"entity internal code generation strategy"
enum internalCodeGenerationStrategy {
	RANDOM
	SEQUENTIAL
}

enum intervalType {
	DAY
	MONTH
	WEEK
	YEAR
}

enum kycProviderEnum {
	MANUAL
	ONFIDO
}

"An enumeration of different types of lesson item"
enum lessonItemTypes {
	HEADLINE
	HTML
	IMAGE
	LIST
	QUIZZ
	TEXT
	VIDEO
}

enum notifications_OrderByType {
	ASC
	DSC
}

enum orientationEnumeration {
	LANDSCAPE
	PORTRAIT
}

"The list of possible payment frequencies"
enum paymentFrequency {
	ANNUALLY
	MONTHLY
	ONE_TIME
	QUARTERLY
	SEMI_ANNUALLY
}

"The list of possible payment methods"
enum paymentMethod {
	ATM
	BANK_TRANSFER
	CASH
	CHEQUE
	CPF
	CREDIT_CARD
	GIRO
	SELF_SERVICE_PAYMENT_MACHINE
}

"A list of all possible actions covered for permission schemas, like read and write"
enum permissionSchemaActionType {
	READ
	WRITE
}

enum policies_AttachedRuleAllowAction {
	ALLOW
	DENY
}

enum policies_Category {
	TERMINATION
}

enum policies_CurrencyCode {
	ADP
	AED
	AFA
	AFN
	ALK
	ALL
	AMD
	ANG
	AOA
	AOK
	AON
	AOR
	ARA
	ARP
	ARS
	ARY
	ATS
	AUD
	AWG
	AYM
	AZM
	AZN
	BAD
	BAM
	BBD
	BDS
	BDT
	BEC
	BEF
	BEL
	BGJ
	BGK
	BGL
	BGN
	BHD
	BIF
	BMD
	BND
	BOB
	BOP
	BOV
	BRB
	BRC
	BRE
	BRL
	BRN
	BRR
	BSD
	BTN
	BUK
	BWP
	BYB
	BYN
	BYR
	BZD
	CAD
	CDF
	CHC
	CHE
	CHF
	CHW
	CLF
	CLP
	CNX
	CNY
	COP
	COU
	CRC
	CSD
	CSJ
	CSK
	CUC
	CUP
	CVE
	CYP
	CZK
	DDM
	DEM
	DJF
	DKK
	DOP
	DZD
	ECS
	ECV
	EEK
	EGP
	ERN
	ESA
	ESB
	ESP
	ETB
	EUR
	FIM
	FJD
	FKP
	FRF
	GBP
	GEK
	GEL
	GHC
	GHP
	GHS
	GIP
	GMD
	GNE
	GNF
	GNS
	GQE
	GRD
	GTQ
	GWE
	GWP
	GYD
	HKD
	HNL
	HRD
	HRK
	HTG
	HUF
	IDR
	IEP
	ILP
	ILR
	ILS
	INR
	IQD
	IRR
	ISJ
	ISK
	ITL
	JMD
	JOD
	JPY
	KES
	KGS
	KHR
	KMF
	KPW
	KRW
	KWD
	KYD
	KZT
	LAJ
	LAK
	LBP
	LKR
	LRD
	LSL
	LSM
	LTL
	LTT
	LUC
	LUF
	LUL
	LVL
	LVR
	LYD
	MAD
	MDL
	MGA
	MGF
	MKD
	MLF
	MMK
	MNT
	MOP
	MRO
	MTL
	MTP
	MUR
	MVQ
	MVR
	MWK
	MXN
	MXV
	MYR
	MZE
	MZM
	MZN
	NAD
	NGN
	NIC
	NIO
	NLG
	NOK
	NPR
	NZD
	OMR
	PAB
	PEH
	PEI
	PEN
	PES
	PGK
	PHP
	PKR
	PLN
	PLZ
	PTE
	PYG
	QAR
	RHD
	ROK
	ROL
	RON
	RSD
	RUB
	RUR
	RWF
	SAR
	SBD
	SCR
	SDD
	SDG
	SDP
	SEK
	SGD
	SHP
	SIT
	SKK
	SLL
	SOS
	SRD
	SRG
	SSP
	STD
	SUR
	SVC
	SYP
	SZL
	THB
	TJR
	TJS
	TMM
	TMT
	TND
	TOP
	TPE
	TRL
	TRY
	TTD
	TWD
	TZS
	UAH
	UAK
	UGS
	UGW
	UGX
	UNDEFINED
	USD
	USN
	USS
	UYI
	UYN
	UYP
	UYU
	UZS
	VEB
	VEF
	VNC
	VND
	VUV
	WST
	XAF
	XAG
	XAU
	XBA
	XBB
	XBC
	XBD
	XCD
	XDR
	XEU
	XFO
	XFU
	XOF
	XPD
	XPF
	XPT
	XRE
	XSU
	XTS
	XUA
	XXX
	YDD
	YER
	YUD
	YUM
	YUN
	ZAL
	ZAR
	ZMK
	ZMW
	ZRN
	ZRZ
	ZWC
	ZWD
	ZWL
	ZWN
	ZWR
}

enum policies_FieldsWhereCondition {
	ARRAY_CONTAINS
	EQUALS
	EXISTS
	GREATER_THAN
	IN
	LESS_THAN
	STRING_CONTAINS
}

enum policies_MemberField {
	EMAIL
	HKID
	PASSPORT_NO
	SEQUENCE_NO
	STAFF_NO
}

enum policies_MemberValidationScope {
	COMPANY
	POLICY
	SYSTEM
}

enum policies_MemberValidationType {
	UNIQUE
}

enum policies_OrderByType {
	ASC
	DSC
}

enum policies_PolicyEventType {
	ACCEPT_ENDORSEMENT
	ADD_ADD_ASSOCIATED_CONTRACT_TO_POLICY_TO_ENDORSEMENT
	ADD_ADD_CLAUSE_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_HOLDER_ADDRESS_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_HOLDER_CONTACT_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_HOLDER_FACT_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_HOLDER_IDENTITY_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_INSURED_ADDRESS_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_INSURED_CONTACT_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_INSURED_FACT_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_INSURED_IDENTITY_TO_ENDORSEMENT
	ADD_ADD_CONTRACT_INSURED_TO_ENDORSEMENT
	ADD_ADD_DISCOUNT_TO_ENDORSEMENT
	ADD_ADD_LOADING_TO_ENDORSEMENT
	ADD_ADD_OTHER_CONTRACT_HOLDER_ADDRESS_TO_ENDORSEMENT
	ADD_ADD_OTHER_CONTRACT_HOLDER_CONTACT_TO_ENDORSEMENT
	ADD_ADD_OTHER_CONTRACT_HOLDER_FACT_TO_ENDORSEMENT
	ADD_ADD_OTHER_CONTRACT_HOLDER_IDENTITY_TO_ENDORSEMENT
	ADD_ADD_OTHER_CONTRACT_HOLDER_TO_ENDORSEMENT
	ADD_ADD_POLICY_FACT_TO_ENDORSEMENT
	ADD_ASSOCIATED_CONTRACT_TO_POLICY
	ADD_ATTACHMENT
	ADD_BENEFICIARY_ELIGIBILITY
	ADD_CLAUSE_TO_POLICY
	ADD_COMMISSION
	ADD_CONTRACT_HOLDER_ADDRESS
	ADD_CONTRACT_HOLDER_CONTACT
	ADD_CONTRACT_HOLDER_FACT
	ADD_CONTRACT_HOLDER_IDENTITY
	ADD_CONTRACT_INSURED
	ADD_CONTRACT_INSURED_ADDRESS
	ADD_CONTRACT_INSURED_CONTACT
	ADD_CONTRACT_INSURED_FACT
	ADD_CONTRACT_INSURED_IDENTITY
	ADD_DISCOUNT
	ADD_DISCOUNT_TO_OFFER
	ADD_ENDORSEMENT
	ADD_EXCLUSION
	ADD_EXCLUSION_TO_OFFER
	ADD_INSURED
	ADD_LOADING
	ADD_LOADING_TO_OFFER
	ADD_NOTE
	ADD_OFFER
	ADD_OTHER_CONTRACT_HOLDER
	ADD_OTHER_CONTRACT_HOLDER_ADDRESS
	ADD_OTHER_CONTRACT_HOLDER_CONTACT
	ADD_OTHER_CONTRACT_HOLDER_FACT
	ADD_OTHER_CONTRACT_HOLDER_IDENTITY
	ADD_OTHER_HOLDER
	ADD_PAYMENT_INFO
	ADD_POLICY_FACT
	ADD_REMOVE_ASSOCIATED_CONTRACT_TO_POLICY_TO_ENDORSEMENT
	ADD_REMOVE_BENEFIT_OPTION_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_HOLDER_ADDRESS_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_HOLDER_CONTACT_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_HOLDER_FACT_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_HOLDER_IDENTITY_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_INSURED_ADDRESS_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_INSURED_CONTACT_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_INSURED_FACT_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_INSURED_IDENTITY_TO_ENDORSEMENT
	ADD_REMOVE_CONTRACT_INSURED_TO_ENDORSEMENT
	ADD_REMOVE_DISCOUNT_TO_ENDORSEMENT
	ADD_REMOVE_LOADING_TO_ENDORSEMENT
	ADD_REMOVE_OTHER_CONTRACT_HOLDER_ADDRESS_TO_ENDORSEMENT
	ADD_REMOVE_OTHER_CONTRACT_HOLDER_CONTACT_TO_ENDORSEMENT
	ADD_REMOVE_OTHER_CONTRACT_HOLDER_FACT_TO_ENDORSEMENT
	ADD_REMOVE_OTHER_CONTRACT_HOLDER_IDENTITY_TO_ENDORSEMENT
	ADD_REMOVE_OTHER_CONTRACT_HOLDER_TO_ENDORSEMENT
	ADD_REMOVE_POLICY_FACT_TO_ENDORSEMENT
	ADD_STAKEHOLDER_TO_POLICY
	ADD_TAG
	ADD_UPDATE_BENEFICIARY_ELIGIBILITY_TO_UPDATE_REQUEST
	ADD_UPDATE_CONTRACT_HOLDER_ADDRESS_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_HOLDER_COMPANY_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_HOLDER_CONTACT_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_HOLDER_FACT_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_HOLDER_IDENTITY_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_HOLDER_INDIVIDUAL_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_ADDRESS_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_COMPANY_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_CONTACT_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_FACT_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_IDENTITY_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_INDIVIDUAL_TO_ENDORSEMENT
	ADD_UPDATE_CONTRACT_INSURED_OBJECT_TO_ENDORSEMENT
	ADD_UPDATE_DISCOUNT_TO_ENDORSEMENT
	ADD_UPDATE_LOADING_TO_ENDORSEMENT
	ADD_UPDATE_OTHER_CONTRACT_HOLDER_ADDRESS_TO_ENDORSEMENT
	ADD_UPDATE_OTHER_CONTRACT_HOLDER_COMPANY_TO_ENDORSEMENT
	ADD_UPDATE_OTHER_CONTRACT_HOLDER_CONTACT_TO_ENDORSEMENT
	ADD_UPDATE_OTHER_CONTRACT_HOLDER_FACT_TO_ENDORSEMENT
	ADD_UPDATE_OTHER_CONTRACT_HOLDER_IDENTITY_TO_ENDORSEMENT
	ADD_UPDATE_OTHER_CONTRACT_HOLDER_INDIVIDUAL_TO_ENDORSEMENT
	ADD_UPDATE_PAYMENT_INFO_TO_UPDATE_REQUEST
	ADD_UPDATE_POLICY_FACT_TO_ENDORSEMENT
	ADD_UPDATE_POLICY_TO_ENDORSEMENT
	ADD_UPDATE_POLICY_TO_UPDATE_REQUEST
	ADD_UPDATE_PRODUCT_TO_ENDORSEMENT
	ADD_UPSERT_BENEFIT_OPTION_TO_ENDORSEMENT
	ADD_UPSERT_BENEFIT_OPTION_TO_UPDATE_REQUEST
	CACHE_PRICING
	CANCEL
	CANCEL_ENDORSEMENT
	CLAUSE_BATCH_TO_ENDORSEMENT
	CLAUSE_BATCH_TO_POLICY
	COMPLETE
	CONTRACT_HOLDER_FACT_BATCH
	CONVERT_OFFER
	CREATE_UPDATE_REQUEST
	CREATION
	DELETE
	DELETE_UPDATE_REQUEST
	INITIALIZE_PAYMENT
	LEGACY_IMPORT
	PAYMENT
	POLICY_FACT_BATCH
	POLICY_JACKET_BATCH
	POLICY_JACKET_BATCH_TO_ENDORSEMENTS
	REFUND
	REJECT
	REJECT_ENDORSEMENT
	REMOVE_ASSOCIATED_CONTRACT_OF_POLICY
	REMOVE_ATTACHMENT
	REMOVE_BENEFICIARY_ELIGIBILITY
	REMOVE_BENEFIT_OPTION
	REMOVE_BENEFIT_OPTION_FROM_POLICY
	REMOVE_CLAUSE_FROM_POLICY
	REMOVE_COMMAND_FROM_ENDORSEMENT
	REMOVE_COMMISSION
	REMOVE_CONTRACT_HOLDER_ADDRESS
	REMOVE_CONTRACT_HOLDER_CONTACT
	REMOVE_CONTRACT_HOLDER_FACT
	REMOVE_CONTRACT_HOLDER_IDENTITY
	REMOVE_CONTRACT_INSURED
	REMOVE_CONTRACT_INSURED_ADDRESS
	REMOVE_CONTRACT_INSURED_CONTACT
	REMOVE_CONTRACT_INSURED_FACT
	REMOVE_CONTRACT_INSURED_IDENTITY
	REMOVE_DISCOUNT
	REMOVE_DISCOUNT_FROM_OFFER
	REMOVE_ENDORSEMENT
	REMOVE_EXCLUSION
	REMOVE_EXCLUSION_FROM_OFFER
	REMOVE_INSURED
	REMOVE_JACKET_FROM_POLICY
	REMOVE_JACKET_FROM_POLICY_TO_ENDORSEMENT
	REMOVE_LOADING
	REMOVE_LOADING_FROM_OFFER
	REMOVE_NOTE
	REMOVE_OFFER
	REMOVE_OTHER_CONTRACT_HOLDER
	REMOVE_OTHER_CONTRACT_HOLDER_ADDRESS
	REMOVE_OTHER_CONTRACT_HOLDER_CONTACT
	REMOVE_OTHER_CONTRACT_HOLDER_FACT
	REMOVE_OTHER_CONTRACT_HOLDER_IDENTITY
	REMOVE_OTHER_HOLDER
	REMOVE_PAYMENT_INFO
	REMOVE_POLICY_FACT
	REMOVE_STAKEHOLDER_FROM_POLICY
	REMOVE_TAG
	REVIEW_UPDATE_REQUEST
	SUBMIT_ENDORSEMENT
	UPDATE_ATTACHMENT
	UPDATE_BENEFICIARY_ELIGIBILITY
	UPDATE_CLAUSE_OF_POLICY
	UPDATE_COMMISSION
	UPDATE_CONTRACT_HOLDER_ADDRESS
	UPDATE_CONTRACT_HOLDER_COMPANY
	UPDATE_CONTRACT_HOLDER_CONTACT
	UPDATE_CONTRACT_HOLDER_FACT
	UPDATE_CONTRACT_HOLDER_IDENTITY
	UPDATE_CONTRACT_HOLDER_INDIVIDUAL
	UPDATE_CONTRACT_INSURED_ADDRESS
	UPDATE_CONTRACT_INSURED_COMPANY
	UPDATE_CONTRACT_INSURED_CONTACT
	UPDATE_CONTRACT_INSURED_FACT
	UPDATE_CONTRACT_INSURED_IDENTITY
	UPDATE_CONTRACT_INSURED_INDIVIDUAL
	UPDATE_CONTRACT_INSURED_OBJECT
	UPDATE_DISCOUNT
	UPDATE_DISCOUNT_OF_OFFER
	UPDATE_ENDORSEMENT
	UPDATE_LOADING
	UPDATE_LOADING_OF_OFFER
	UPDATE_NOTE
	UPDATE_OFFER
	UPDATE_OTHER_CONTRACT_HOLDER_ADDRESS
	UPDATE_OTHER_CONTRACT_HOLDER_COMPANY
	UPDATE_OTHER_CONTRACT_HOLDER_CONTACT
	UPDATE_OTHER_CONTRACT_HOLDER_FACT
	UPDATE_OTHER_CONTRACT_HOLDER_IDENTITY
	UPDATE_OTHER_CONTRACT_HOLDER_INDIVIDUAL
	UPDATE_PAYMENT_INFO
	UPDATE_POLICY
	UPDATE_POLICY_FACT
	UPDATE_PRODUCT
	UPDATE_STAKEHOLDER_OF_POLICY
	UPDATE_TRANSACTION
	UPSERT_BENEFIT_OPTION
	UPSERT_BENEFIT_OPTION_BATCH
	UPSERT_BENEFIT_OPTION_OF_POLICY
}

enum policies_PolicyMemberUnderwritingResult {
	APPROVED
	MANUAL_APPROVED
	MANUAL_PENDING
	MANUAL_REJECTED
	PENDING
	REJECTED
}

enum policies_PolicyMemberUploadStatus {
	CANCELED
	CANCELING
	ERROR_REMOVED
	ERROR_REMOVING
	FAILED
	IMPORTED
	IMPORTING
	IMPORTING_ERROR
	REGISTERED
	REVERSED
	REVERSING
	VALIDATED
	VALIDATING
	VALIDATING_ERROR
}

enum policies_PolicyMemberValidationResult {
	INVALID
	VALID
}

enum products_DiscountType {
	AMOUNT
	PERCENTAGE
}

enum products_OrderByType {
	ASC
	DSC
}

enum products_ProductImportValidationMessageLevel {
	ERROR
	WARNING
}

"A list of possible proration behaviours"
enum prorationBehaviourEnumeration {
	CHARGE_IMMEDIATELY
	NEXT_INTERVAL
	NONE
}

"A list of all public holiday types"
enum publicHolidayTypeEnumGraphTypeEnum {
	BANK
	PUBLIC
}

enum requestManager_COUNTRY {
	GBR
	HKG
	TWN
	USA
}

enum requestManager_PartyType {
	ORGANIZATION
	PERSON
}

enum requestManager_SortEnumType {
	ASC
	DESC
}

enum scriptTypeEnum {
	CANCELLATION
	CLAIM
	PRICING
	UNDERWRITING
}

enum templates_OrderByType {
	ASC
	DSC
}

enum textAlignmentEnumeration {
	CENTER
	LEFT
	RIGHT
}

"A list of all possible transactionStatuses"
enum transactionStatusEnumeration {
	ACCEPTED
	APPROVED
	CANCELLED_BY_USER
	FAILED
	NOT_STARTED
	PENDING
	REFUNDED
	REJECTED
	SUCCEED
	TIMEOUT
	UNDEFINED
}

enum transactions_CurrencyCode {
	ADP
	AED
	AFA
	AFN
	ALK
	ALL
	AMD
	ANG
	AOA
	AOK
	AON
	AOR
	ARA
	ARP
	ARS
	ARY
	ATS
	AUD
	AWG
	AYM
	AZM
	AZN
	BAD
	BAM
	BBD
	BDS
	BDT
	BEC
	BEF
	BEL
	BGJ
	BGK
	BGL
	BGN
	BHD
	BIF
	BMD
	BND
	BOB
	BOP
	BOV
	BRB
	BRC
	BRE
	BRL
	BRN
	BRR
	BSD
	BTN
	BUK
	BWP
	BYB
	BYN
	BYR
	BZD
	CAD
	CDF
	CHC
	CHE
	CHF
	CHW
	CLF
	CLP
	CNX
	CNY
	COP
	COU
	CRC
	CSD
	CSJ
	CSK
	CUC
	CUP
	CVE
	CYP
	CZK
	DDM
	DEM
	DJF
	DKK
	DOP
	DZD
	ECS
	ECV
	EEK
	EGP
	ERN
	ESA
	ESB
	ESP
	ETB
	EUR
	FIM
	FJD
	FKP
	FRF
	GBP
	GEK
	GEL
	GHC
	GHP
	GHS
	GIP
	GMD
	GNE
	GNF
	GNS
	GQE
	GRD
	GTQ
	GWE
	GWP
	GYD
	HKD
	HNL
	HRD
	HRK
	HTG
	HUF
	IDR
	IEP
	ILP
	ILR
	ILS
	INR
	IQD
	IRR
	ISJ
	ISK
	ITL
	JMD
	JOD
	JPY
	KES
	KGS
	KHR
	KMF
	KPW
	KRW
	KWD
	KYD
	KZT
	LAJ
	LAK
	LBP
	LKR
	LRD
	LSL
	LSM
	LTL
	LTT
	LUC
	LUF
	LUL
	LVL
	LVR
	LYD
	MAD
	MDL
	MGA
	MGF
	MKD
	MLF
	MMK
	MNT
	MOP
	MRO
	MTL
	MTP
	MUR
	MVQ
	MVR
	MWK
	MXN
	MXV
	MYR
	MZE
	MZM
	MZN
	NAD
	NGN
	NIC
	NIO
	NLG
	NOK
	NPR
	NZD
	OMR
	PAB
	PEH
	PEI
	PEN
	PES
	PGK
	PHP
	PKR
	PLN
	PLZ
	PTE
	PYG
	QAR
	RHD
	ROK
	ROL
	RON
	RSD
	RUB
	RUR
	RWF
	SAR
	SBD
	SCR
	SDD
	SDG
	SDP
	SEK
	SGD
	SHP
	SIT
	SKK
	SLL
	SOS
	SRD
	SRG
	SSP
	STD
	SUR
	SVC
	SYP
	SZL
	THB
	TJR
	TJS
	TMM
	TMT
	TND
	TOP
	TPE
	TRL
	TRY
	TTD
	TWD
	TZS
	UAH
	UAK
	UGS
	UGW
	UGX
	UNDEFINED
	USD
	USN
	USS
	UYI
	UYN
	UYP
	UYU
	UZS
	VEB
	VEF
	VNC
	VND
	VUV
	WST
	XAF
	XAG
	XAU
	XBA
	XBB
	XBC
	XBD
	XCD
	XDR
	XEU
	XFO
	XFU
	XOF
	XPD
	XPF
	XPT
	XRE
	XSU
	XTS
	XUA
	XXX
	YDD
	YER
	YUD
	YUM
	YUN
	ZAL
	ZAR
	ZMK
	ZMW
	ZRN
	ZRZ
	ZWC
	ZWD
	ZWL
	ZWN
	ZWR
}

enum transactions_Interval {
	DAY
	MONTH
	WEEK
	YEAR
}

enum transactions_PaymentMethodType {
	ATM
	BANK_TRANSFER
	CASH
	CHEQUE
	CREDIT_CARD
	GIRO
	SELF_SERVICE_PAYMENT_MACHINE
}

enum transactions_TransactionStatus {
	ACCEPTED
	APPROVED
	CANCELLED_BY_USER
	FAILED
	NOT_STARTED
	PENDING
	REFUNDED
	REJECTED
	SUCCEED
	TIMEOUT
	UNDEFINED
}

"A list of all possible UiSchema standards"
enum uiSchemaStandardTypeEnum {
	GRAPHQL
	JSON_SCHEMA
}

"An enumeration of different types of users"
enum userEnumeration {
	COMPANY
	INDIVIDUAL
	INTERNAL
	OBJECT
	ORGANIZATION
	UNDEFINED
}

enum users_AttachedRuleAllowAction {
	ALLOW
	DENY
}

enum users_EntityTypes {
	COMPANY
	INDIVIDUAL
	INTERNAL
	OBJECT
	ORGANIZATION
	UNDEFINED
}

enum users_FieldsWhereCondition {
	ARRAY_CONTAINS
	EQUALS
	EXISTS
	GREATER_THAN
	IN
	LESS_THAN
	STRING_CONTAINS
}

enum users_KycProviderEnum {
	MANUAL
	ONFIDO
}

enum users_KycStatusEnum {
	CLEAR
	CONSIDER
	PENDING
	REJECTED
}

enum users_OrderByType {
	ASC
	DSC
}

enum verticalAlignmentEnumeration {
	BOTTOM
	CENTER
	TOP
}

scalar Any

"The `Byte` scalar type represents non-fractional whole numeric values. Byte can represent values between 0 and 255."
scalar Byte

"The `Date` scalar represents an ISO-8601 compliant date type."
scalar Date

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

"The `DateTimeOffset` scalar type represents a date, time and offset from UTC. `DateTimeOffset` expects timestamps to be formatted in accordance with the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard."
scalar DateTimeOffset

"The built-in `Decimal` scalar type."
scalar Decimal

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

"The `Milliseconds` scalar type represents a period of time represented as the total number of milliseconds."
scalar Milliseconds

"The name scalar represents a valid GraphQL name as specified in the spec and can be used to refer to fields or types."
scalar Name

"The `Seconds` scalar type represents a period of time represented as the total number of seconds."
scalar Seconds

"The `TimeSpan` scalar represents an ISO-8601 compliant duration type."
scalar TimeSpan

scalar UUID

"The UnsignedInt scalar type represents a unsigned 32-bit numeric non-fractional value greater than or equal to 0."
scalar UnsignedInt

"The `Upload` scalar type represents a file upload."
scalar Upload

input AddMetadataGraphType {
	bucketName: String
	key: String!
	metadata: [keyValueInput]
}

input ApproveConsentRequestInput {
	consentRequestId: ID!
	investigationId: ID!
}

input AttachNodeFieldResolverInput {
	fieldName: String!
	resolver: ExpressionInput!
}

input BooleanOperationFilterInput {
	eq: Boolean
	neq: Boolean
}

input CancelConsentRequestInput {
	consentRequestId: ID!
	investigationId: ID!
}

input CancelEvidenceRequestInput {
	evidenceRequestId: ID!
	investigationId: ID!
	summary: String!
}

input ChangeNodeFieldTypeInput {
	fieldName: String!
	type: String!
}

input ClaimInvestigationFindingsInput {
	investigationId: ID!
	requestId: ID!
	summary: String!
	uploadedFiles: [FileInput!]!
}

input ClaimInvestigationModelFilterInput {
	and: [ClaimInvestigationModelFilterInput!]
	approverName: StringOperationFilterInput
	closedAt: ComparableNullableOfDateTimeOffsetOperationFilterInput
	consentRequests: ListFilterInputTypeOfConsentRequestModelFilterInput
	createdAt: ComparableDateTimeOffsetOperationFilterInput
	escalatedClaim: EscalatedClaimModelFilterInput
	evidenceRequests: ListFilterInputTypeOfEvidenceRequestModelFilterInput
	findings: FindingsSummaryModelFilterInput
	handlerName: StringOperationFilterInput
	id: ComparableGuidOperationFilterInput
	openedAt: ComparableDateTimeOffsetOperationFilterInput
	or: [ClaimInvestigationModelFilterInput!]
	status: ClaimInvestigationStatusOperationFilterInput
	updatedAt: ComparableDateTimeOffsetOperationFilterInput
}

input ClaimInvestigationModelSortInput {
	approverName: SortEnumType
	closedAt: SortEnumType
	createdAt: SortEnumType
	escalatedClaim: EscalatedClaimModelSortInput
	findings: FindingsSummaryModelSortInput
	handlerName: SortEnumType
	id: SortEnumType
	openedAt: SortEnumType
	status: SortEnumType
	updatedAt: SortEnumType
}

input ClaimInvestigationStatusOperationFilterInput {
	eq: ClaimInvestigationStatus
	in: [ClaimInvestigationStatus!]
	neq: ClaimInvestigationStatus
	nin: [ClaimInvestigationStatus!]
}

input CmsConfigWhereInputGraphType {
	and: [CmsConfigWhereInputGraphType]
	appId: String
	appId_in: [String]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [CmsConfigWhereInputGraphType]
}

input CollectEvidenceInput {
	evidenceRequestId: ID!
	files: [FileInput!]!
	investigationId: ID!
	notes: String!
	requestedDocuments: [RequestedDocumentsInput!]!
	uploadedDocuments: [FileInput!]!
}

input ComparableDateTimeOffsetOperationFilterInput {
	eq: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime!]
	lt: DateTime
	lte: DateTime
	neq: DateTime
	ngt: DateTime
	ngte: DateTime
	nin: [DateTime!]
	nlt: DateTime
	nlte: DateTime
}

input ComparableGuidOperationFilterInput {
	eq: ID
	gt: ID
	gte: ID
	in: [ID!]
	lt: ID
	lte: ID
	neq: ID
	ngt: ID
	ngte: ID
	nin: [ID!]
	nlt: ID
	nlte: ID
}

input ComparableNullableOfDateTimeOffsetOperationFilterInput {
	eq: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime]
	lt: DateTime
	lte: DateTime
	neq: DateTime
	ngt: DateTime
	ngte: DateTime
	nin: [DateTime]
	nlt: DateTime
	nlte: DateTime
}

input Comparablebilling_DateTimeOffsetOperationFilterInput {
	eq: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime!]
	lt: DateTime
	lte: DateTime
	neq: DateTime
	ngt: DateTime
	ngte: DateTime
	nin: [DateTime!]
	nlt: DateTime
	nlte: DateTime
}

input Comparablebilling_DecimalOperationFilterInput {
	eq: Decimal
	gt: Decimal
	gte: Decimal
	in: [Decimal!]
	lt: Decimal
	lte: Decimal
	neq: Decimal
	ngt: Decimal
	ngte: Decimal
	nin: [Decimal!]
	nlt: Decimal
	nlte: Decimal
}

input Comparablebilling_GuidOperationFilterInput {
	eq: UUID
	gt: UUID
	gte: UUID
	in: [UUID!]
	lt: UUID
	lte: UUID
	neq: UUID
	ngt: UUID
	ngte: UUID
	nin: [UUID!]
	nlt: UUID
	nlte: UUID
}

input Comparablebilling_NullableOfDateTimeOffsetOperationFilterInput {
	eq: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime]
	lt: DateTime
	lte: DateTime
	neq: DateTime
	ngt: DateTime
	ngte: DateTime
	nin: [DateTime]
	nlt: DateTime
	nlte: DateTime
}

input Comparablebilling_NullableOfDecimalOperationFilterInput {
	eq: Decimal
	gt: Decimal
	gte: Decimal
	in: [Decimal]
	lt: Decimal
	lte: Decimal
	neq: Decimal
	ngt: Decimal
	ngte: Decimal
	nin: [Decimal]
	nlt: Decimal
	nlte: Decimal
}

input Comparablebilling_NullableOfInt32OperationFilterInput {
	eq: Int
	gt: Int
	gte: Int
	in: [Int]
	lt: Int
	lte: Int
	neq: Int
	ngt: Int
	ngte: Int
	nin: [Int]
	nlt: Int
	nlte: Int
}

input Comparablebilling_TimeSpanOperationFilterInput {
	eq: TimeSpan
	gt: TimeSpan
	gte: TimeSpan
	in: [TimeSpan!]
	lt: TimeSpan
	lte: TimeSpan
	neq: TimeSpan
	ngt: TimeSpan
	ngte: TimeSpan
	nin: [TimeSpan!]
	nlt: TimeSpan
	nlte: TimeSpan
}

input Comparablepolicies_DateTimeOperationFilterInput {
	eq: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime!]
	lt: DateTime
	lte: DateTime
	neq: DateTime
	ngt: DateTime
	ngte: DateTime
	nin: [DateTime!]
	nlt: DateTime
	nlte: DateTime
}

input Comparablepolicies_NullableOfDateTimeOperationFilterInput {
	eq: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime]
	lt: DateTime
	lte: DateTime
	neq: DateTime
	ngt: DateTime
	ngte: DateTime
	nin: [DateTime]
	nlt: DateTime
	nlte: DateTime
}

input ConsentRequestModelFilterInput {
	and: [ConsentRequestModelFilterInput!]
	approvedAt: ComparableNullableOfDateTimeOffsetOperationFilterInput
	approvedBy: UserModelFilterInput
	cancelledAt: ComparableNullableOfDateTimeOffsetOperationFilterInput
	cancelledBy: UserModelFilterInput
	createdAt: ComparableDateTimeOffsetOperationFilterInput
	documents: ListFilterInputTypeOfFileModelFilterInput
	email: EmailModelFilterInput
	id: ComparableGuidOperationFilterInput
	or: [ConsentRequestModelFilterInput!]
	reasons: ListStringOperationFilterInput
	rejectedAt: ComparableNullableOfDateTimeOffsetOperationFilterInput
	rejectedBy: UserModelFilterInput
	reminders: ListFilterInputTypeOfReminderModelFilterInput
	sentAt: ComparableDateTimeOffsetOperationFilterInput
	sentBy: UserModelFilterInput
	status: ConsentRequestStatusOperationFilterInput
	updatedAt: ComparableDateTimeOffsetOperationFilterInput
}

input ConsentRequestStatusOperationFilterInput {
	eq: ConsentRequestStatus
	in: [ConsentRequestStatus!]
	neq: ConsentRequestStatus
	nin: [ConsentRequestStatus!]
}

"Input for creating a node instance or a node reference"
input CreateNodeInput {
	alias: String
	children: [CreateNodeInput!]
	fields: [NodeFieldInput!]
	"generated by server if omitted"
	id: ID
	position: NodePositionInput
	"generated by server if omitted"
	ref: String
	"if type is specified, its state will be extended with provided \"state\" field"
	type: String
}

input EmailInput {
	cc: String!
	recipientName: String
	replyTo: String!
	to: String!
}

input EmailModelFilterInput {
	and: [EmailModelFilterInput!]
	cc: StringOperationFilterInput
	or: [EmailModelFilterInput!]
	recipientName: StringOperationFilterInput
	replyTo: StringOperationFilterInput
	to: StringOperationFilterInput
}

input EntityModelFilterInput {
	and: [EntityModelFilterInput!]
	id: StringOperationFilterInput
	internalCode: StringOperationFilterInput
	name: StringOperationFilterInput
	or: [EntityModelFilterInput!]
}

input EntityModelSortInput {
	id: SortEnumType
	internalCode: SortEnumType
	name: SortEnumType
}

input EscalateClaimInput {
	claimId: String!
	escalationRequestId: ID!
}

input EscalatedClaimModelFilterInput {
	and: [EscalatedClaimModelFilterInput!]
	claimId: StringOperationFilterInput
	claimIssuerNumber: StringOperationFilterInput
	claimantId: StringOperationFilterInput
	escalatedDate: ComparableNullableOfDateTimeOffsetOperationFilterInput
	id: ComparableGuidOperationFilterInput
	isInvestigationOpened: BooleanOperationFilterInput
	memberInternalCode: StringOperationFilterInput
	memberName: StringOperationFilterInput
	or: [EscalatedClaimModelFilterInput!]
	policyHolder: EntityModelFilterInput
	policyId: StringOperationFilterInput
	policyIssuerNumber: StringOperationFilterInput
	status: EscalatedClaimStatusOperationFilterInput
}

input EscalatedClaimModelSortInput {
	claimId: SortEnumType
	claimIssuerNumber: SortEnumType
	claimantId: SortEnumType
	escalatedDate: SortEnumType
	id: SortEnumType
	isInvestigationOpened: SortEnumType
	memberInternalCode: SortEnumType
	memberName: SortEnumType
	policyHolder: EntityModelSortInput
	policyId: SortEnumType
	policyIssuerNumber: SortEnumType
	status: SortEnumType
}

input EscalatedClaimStatusOperationFilterInput {
	eq: EscalatedClaimStatus
	in: [EscalatedClaimStatus!]
	neq: EscalatedClaimStatus
	nin: [EscalatedClaimStatus!]
}

input EvidenceRequestModelFilterInput {
	and: [EvidenceRequestModelFilterInput!]
	cancelledAt: ComparableNullableOfDateTimeOffsetOperationFilterInput
	collectedAt: ComparableNullableOfDateTimeOffsetOperationFilterInput
	collectedBy: UserModelFilterInput
	createdAt: ComparableDateTimeOffsetOperationFilterInput
	email: EmailModelFilterInput
	files: ListFilterInputTypeOfFileModelFilterInput
	id: ComparableGuidOperationFilterInput
	message: StringOperationFilterInput
	notes: StringOperationFilterInput
	or: [EvidenceRequestModelFilterInput!]
	receivedAt: ComparableNullableOfDateTimeOffsetOperationFilterInput
	receivedBy: UserModelFilterInput
	reminders: ListFilterInputTypeOfReminderModelFilterInput
	requestedDocuments: ListFilterInputTypeOfRequestedDocumentsModelFilterInput
	sentAt: ComparableNullableOfDateTimeOffsetOperationFilterInput
	sentBy: UserModelFilterInput
	status: EvidenceRequestStatusOperationFilterInput
	summary: StringOperationFilterInput
	uploadedDocuments: ListFilterInputTypeOfFileModelFilterInput
}

input EvidenceRequestStatusOperationFilterInput {
	eq: EvidenceRequestStatus
	in: [EvidenceRequestStatus!]
	neq: EvidenceRequestStatus
	nin: [EvidenceRequestStatus!]
}

"Expression for an entity, with a engine specification"
input ExpressionInput {
	"Could be: ClearScript, GraphQL, Constant, LocalFormula, ContextFormula"
	language: Language
	text: String
}

input FileInput {
	key: String!
	name: String!
}

input FileModelFilterInput {
	and: [FileModelFilterInput!]
	key: StringOperationFilterInput
	name: StringOperationFilterInput
	or: [FileModelFilterInput!]
}

input FindingsSummaryModelFilterInput {
	and: [FindingsSummaryModelFilterInput!]
	or: [FindingsSummaryModelFilterInput!]
	summary: StringOperationFilterInput
	uploadedFiles: ListFilterInputTypeOfFileModelFilterInput
}

input FindingsSummaryModelSortInput {
	summary: SortEnumType
}

input HotChocolate_AggregateDefinedCommandReadModelFilterInput {
	aggregate: HotChocolate_OpenTypeReadModelFilterInput
	and: [HotChocolate_AggregateDefinedCommandReadModelFilterInput!]
	commandType: HotChocolate_OpenTypeReadModelFilterInput
	date: HotChocolate_ComparableDateTimeOffsetOperationFilterInput
	engine: HotChocolate_StringOperationFilterInput
	id: HotChocolate_StringOperationFilterInput
	or: [HotChocolate_AggregateDefinedCommandReadModelFilterInput!]
	version: HotChocolate_ComparableNullableOfInt32OperationFilterInput
}

input HotChocolate_AggregateDefinedCommandReadModelSortInput {
	aggregate: HotChocolate_OpenTypeReadModelSortInput
	commandType: HotChocolate_OpenTypeReadModelSortInput
	date: HotChocolate_SortEnumType
	engine: HotChocolate_SortEnumType
	id: HotChocolate_SortEnumType
	version: HotChocolate_SortEnumType
}

input HotChocolate_ComparableDateTimeOffsetOperationFilterInput {
	eq: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime!]
	lt: DateTime
	lte: DateTime
	neq: DateTime
	ngt: DateTime
	ngte: DateTime
	nin: [DateTime!]
	nlt: DateTime
	nlte: DateTime
}

input HotChocolate_ComparableGuidOperationFilterInput {
	eq: ID
	gt: ID
	gte: ID
	in: [ID!]
	lt: ID
	lte: ID
	neq: ID
	ngt: ID
	ngte: ID
	nin: [ID!]
	nlt: ID
	nlte: ID
}

input HotChocolate_ComparableInt64OperationFilterInput {
	eq: Long
	gt: Long
	gte: Long
	in: [Long!]
	lt: Long
	lte: Long
	neq: Long
	ngt: Long
	ngte: Long
	nin: [Long!]
	nlt: Long
	nlte: Long
}

input HotChocolate_ComparableNullableOfGuidOperationFilterInput {
	eq: ID
	gt: ID
	gte: ID
	in: [ID]
	lt: ID
	lte: ID
	neq: ID
	ngt: ID
	ngte: ID
	nin: [ID]
	nlt: ID
	nlte: ID
}

input HotChocolate_ComparableNullableOfInt32OperationFilterInput {
	eq: Int
	gt: Int
	gte: Int
	in: [Int]
	lt: Int
	lte: Int
	neq: Int
	ngt: Int
	ngte: Int
	nin: [Int]
	nlt: Int
	nlte: Int
}

input HotChocolate_EventConsumeStatusOperationFilterInput {
	eq: EventConsumeStatus
	in: [EventConsumeStatus!]
	neq: EventConsumeStatus
	nin: [EventConsumeStatus!]
}

input HotChocolate_OpenAddressReadModelFilterInput {
	and: [HotChocolate_OpenAddressReadModelFilterInput!]
	id: HotChocolate_ComparableGuidOperationFilterInput
	or: [HotChocolate_OpenAddressReadModelFilterInput!]
	typeName: HotChocolate_StringOperationFilterInput
	typeVersion: HotChocolate_ComparableNullableOfInt32OperationFilterInput
	version: HotChocolate_ComparableNullableOfInt32OperationFilterInput
}

input HotChocolate_OpenAddressReadModelSortInput {
	id: HotChocolate_SortEnumType
	typeName: HotChocolate_SortEnumType
	typeVersion: HotChocolate_SortEnumType
	version: HotChocolate_SortEnumType
}

input HotChocolate_OpenTypeReadModelFilterInput {
	aggregateId: HotChocolate_ComparableNullableOfGuidOperationFilterInput
	and: [HotChocolate_OpenTypeReadModelFilterInput!]
	engine: HotChocolate_StringOperationFilterInput
	group: HotChocolate_StringOperationFilterInput
	id: HotChocolate_StringOperationFilterInput
	name: HotChocolate_StringOperationFilterInput
	or: [HotChocolate_OpenTypeReadModelFilterInput!]
	payload: HotChocolate_StringOperationFilterInput
	version: HotChocolate_ComparableNullableOfInt32OperationFilterInput
}

input HotChocolate_OpenTypeReadModelSortInput {
	aggregateId: HotChocolate_SortEnumType
	engine: HotChocolate_SortEnumType
	group: HotChocolate_SortEnumType
	id: HotChocolate_SortEnumType
	name: HotChocolate_SortEnumType
	payload: HotChocolate_SortEnumType
	version: HotChocolate_SortEnumType
}

input HotChocolate_ReadModelEventProcessedFilterInput {
	and: [HotChocolate_ReadModelEventProcessedFilterInput!]
	builderType: HotChocolate_StringOperationFilterInput
	checkpoint: HotChocolate_ComparableInt64OperationFilterInput
	eventId: HotChocolate_ComparableGuidOperationFilterInput
	eventSource: HotChocolate_StringOperationFilterInput
	eventType: HotChocolate_StringOperationFilterInput
	id: HotChocolate_StringOperationFilterInput
	message: HotChocolate_StringOperationFilterInput
	or: [HotChocolate_ReadModelEventProcessedFilterInput!]
	result: HotChocolate_EventConsumeStatusOperationFilterInput
	time: HotChocolate_ComparableDateTimeOffsetOperationFilterInput
}

input HotChocolate_ReadModelEventProcessedSortInput {
	builderType: HotChocolate_SortEnumType
	checkpoint: HotChocolate_SortEnumType
	eventId: HotChocolate_SortEnumType
	eventSource: HotChocolate_SortEnumType
	eventType: HotChocolate_SortEnumType
	id: HotChocolate_SortEnumType
	message: HotChocolate_SortEnumType
	result: HotChocolate_SortEnumType
	time: HotChocolate_SortEnumType
}

input HotChocolate_StateDescriptionReadModelFilterInput {
	aggregateType: HotChocolate_OpenTypeReadModelFilterInput
	and: [HotChocolate_StateDescriptionReadModelFilterInput!]
	id: HotChocolate_StringOperationFilterInput
	or: [HotChocolate_StateDescriptionReadModelFilterInput!]
	stateType: HotChocolate_StringOperationFilterInput
}

input HotChocolate_StateDescriptionReadModelSortInput {
	aggregateType: HotChocolate_OpenTypeReadModelSortInput
	id: HotChocolate_SortEnumType
	stateType: HotChocolate_SortEnumType
}

input HotChocolate_StringOperationFilterInput {
	and: [HotChocolate_StringOperationFilterInput!]
	contains: String
	endsWith: String
	eq: String
	in: [String]
	ncontains: String
	nendsWith: String
	neq: String
	nin: [String]
	nstartsWith: String
	or: [HotChocolate_StringOperationFilterInput!]
	startsWith: String
}

input HotChocolate_TenantReadModelFilterInput {
	and: [HotChocolate_TenantReadModelFilterInput!]
	created: HotChocolate_ComparableDateTimeOffsetOperationFilterInput
	createdBy: HotChocolate_StringOperationFilterInput
	id: HotChocolate_StringOperationFilterInput
	name: HotChocolate_StringOperationFilterInput
	or: [HotChocolate_TenantReadModelFilterInput!]
	status: HotChocolate_TenantStatusOperationFilterInput
	tenantsCentreAggregateId: HotChocolate_ComparableGuidOperationFilterInput
}

input HotChocolate_TenantReadModelSortInput {
	created: HotChocolate_SortEnumType
	createdBy: HotChocolate_SortEnumType
	id: HotChocolate_SortEnumType
	name: HotChocolate_SortEnumType
	status: HotChocolate_SortEnumType
	tenantsCentreAggregateId: HotChocolate_SortEnumType
}

input HotChocolate_TenantStatusOperationFilterInput {
	eq: TenantStatus
	in: [TenantStatus!]
	neq: TenantStatus
	nin: [TenantStatus!]
}

input ListFilterInputTypeOfConsentRequestModelFilterInput {
	all: ConsentRequestModelFilterInput
	any: Boolean
	none: ConsentRequestModelFilterInput
	some: ConsentRequestModelFilterInput
}

input ListFilterInputTypeOfEvidenceRequestModelFilterInput {
	all: EvidenceRequestModelFilterInput
	any: Boolean
	none: EvidenceRequestModelFilterInput
	some: EvidenceRequestModelFilterInput
}

input ListFilterInputTypeOfFileModelFilterInput {
	all: FileModelFilterInput
	any: Boolean
	none: FileModelFilterInput
	some: FileModelFilterInput
}

input ListFilterInputTypeOfReminderModelFilterInput {
	all: ReminderModelFilterInput
	any: Boolean
	none: ReminderModelFilterInput
	some: ReminderModelFilterInput
}

input ListFilterInputTypeOfRequestedDocumentsModelFilterInput {
	all: RequestedDocumentsModelFilterInput
	any: Boolean
	none: RequestedDocumentsModelFilterInput
	some: RequestedDocumentsModelFilterInput
}

input ListStringOperationFilterInput {
	all: StringOperationFilterInput
	any: Boolean
	none: StringOperationFilterInput
	some: StringOperationFilterInput
}

input Listbilling_GenericBillingBillFilterFilterInput {
	all: billing_BillingBillFilterInput
	any: Boolean
	none: billing_BillingBillFilterInput
	some: billing_BillingBillFilterInput
}

input Listbilling_GenericBillingPremiumInstallmentFilterFilterInput {
	all: billing_BillingPremiumInstallmentFilterInput
	any: Boolean
	none: billing_BillingPremiumInstallmentFilterInput
	some: billing_BillingPremiumInstallmentFilterInput
}

input Listbilling_GenericBillingPricingBreakdownFilterFilterInput {
	all: billing_BillingPricingBreakdownFilterInput
	any: Boolean
	none: billing_BillingPricingBreakdownFilterInput
	some: billing_BillingPricingBreakdownFilterInput
}

input Listbilling_StringOperationFilterInput {
	all: billing_StringOperationFilterInput
	any: Boolean
	none: billing_StringOperationFilterInput
	some: billing_StringOperationFilterInput
}

input Listpolicies_GenericIUserErrorFilterFilterInput {
	all: policies_UserErrorFilterInput
	any: Boolean
	none: policies_UserErrorFilterInput
	some: policies_UserErrorFilterInput
}

input MarkEvidenceAsReceivedInput {
	evidenceRequestId: ID!
	investigationId: ID!
	requestedDocumentNames: [String!]!
}

"Field of a tree node, defined by a user. Should be domain-specific."
input NodeFieldInput {
	alias: String
	ref: String!
	resolver: ExpressionInput
	"""

	Accepted values:
	+ Int
	+ String
	+ Boolean
	+ Decimal
	any other value will be mapped to a user-defined type with GraphQL language
	"""
	type: String!
}

input NodeLocationInput {
	nodeId: ID
	nodeRef: String
	rootNodeId: ID
}

"Position of a node within a tree could be abstracted as a parent node id + index in it's children list"
input NodePositionInput {
	"""

	Index of the current node within its siblings, starting from 0.
	Index = 0 means the first child, index = 1 means the second child and so on.
	Absence of index means the last child.
	All negative numbers are treated as the last node.
	"""
	index: UnsignedInt
	"""

	Id of node's parent
	Can be the only field to specify, in this case position will be the last child.
	"""
	parentId: ID
}

input NodeScriptInput {
	text: String!
}

input OpenTypeDtoInput {
	name: String!
	version: Int = 1
}

input ProductSchemaInput {
	dataSchema: String
	nodeId: ID!
}

input ReadModelTopicInput {
	aggregateId: ID!
	aggregateTypeId: String!
	readModelTypeId: String!
}

input RejectConsentRequestInput {
	consentRequestId: ID!
	investigationId: ID!
	reason: String!
}

input ReminderModelFilterInput {
	and: [ReminderModelFilterInput!]
	or: [ReminderModelFilterInput!]
	sentAt: ComparableDateTimeOffsetOperationFilterInput
	sentBy: UserModelFilterInput
}

input RequestedDocumentsInput {
	files: [FileInput!]
	name: String!
}

input RequestedDocumentsModelFilterInput {
	and: [RequestedDocumentsModelFilterInput!]
	files: ListFilterInputTypeOfFileModelFilterInput
	name: StringOperationFilterInput
	or: [RequestedDocumentsModelFilterInput!]
	received: BooleanOperationFilterInput
}

input SendConsentRequestInput {
	documents: [FileInput!]!
	email: EmailInput!
	investigationId: ID!
	reasons: [String!]!
}

input SendConsentRequestReminderInput {
	consentRequestId: ID!
	investigationId: ID!
}

input SendEvidenceRequestInput {
	email: EmailInput!
	investigationId: ID!
	message: String!
	requestedDocumentNames: [String!]!
	uploadedDocuments: [FileInput!]!
}

input SendEvidenceRequestReminderInput {
	evidenceRequestId: ID!
	investigationId: ID!
}

input StringOperationFilterInput {
	and: [StringOperationFilterInput!]
	contains: String
	endsWith: String
	eq: String
	in: [String]
	ncontains: String
	nendsWith: String
	neq: String
	nin: [String]
	nstartsWith: String
	or: [StringOperationFilterInput!]
	startsWith: String
}

input UiSchemaInput {
	name: String
	schema: String
}

input UpdateProductSchemaInput {
	dataSchema: String
	nodeId: ID
}

input UpdateUiSchemaInput {
	schema: String
}

input UploadConsentRequestAttachmentInput {
	consentRequestId: ID!
	documents: [FileInput!]!
	investigationId: ID!
}

input UserModelFilterInput {
	and: [UserModelFilterInput!]
	email: StringOperationFilterInput
	id: StringOperationFilterInput
	name: StringOperationFilterInput
	or: [UserModelFilterInput!]
}

"The input for achievement type logic"
input achievementLogicInput {
	and: [achievementLogicInput]
	graphQlQuery: String
	liquidCondition: String
	or: [achievementLogicInput]
}

"An achievement type search filter"
input achievementTypeWhereInput {
	and: [achievementTypeWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [achievementTypeWhereInput]
	type: String
	type_in: [String]
}

"Adds a benefit to claim"
input addBenefitToClaimInput {
	benefitDescription: String
	benefitName: String
	benefitTypeId: String
	currencyCode: currencyCodeEnumeration
	remark: String
	value: scalarValueInput
	values: [claimValueInput]
}

"add clause input"
input addClauseInput {
	htmlOverride: String
	order: Int
	renderParameters: templateRenderParametersInput
	storeTemplateByValue: Boolean
	templateId: String
}

"add to clause jacket input"
input addClauseToJacketInput {
	htmlOverride: String
	id: String!
	order: Int
	renderParameters: templateRenderParametersInput
	templateId: String!
}

input addClauseToPolicyInput {
	commandId: String
	endorsementId: String
	htmlOverride: String
	order: Int
	renderParameters: templateRenderParametersInput
	storeTemplateByValue: Boolean
	templateId: String
	timestamp: Date
	type: String
}

"A command to create a contact detail for a user (customer or internal user)"
input addContactInput {
	type: String!
	value: String
}

input addDataSchemaToProductTypeInput {
	dataSchemaId: String!
	productTypeId: String!
}

"The discount input"
input addDiscountToOfferInput {
	calculationJsonLogic: String
	name: String
	order: Int
}

input addDynamicValueToTemplateInput {
	value: scalarValueInput
	valueJsonString: String
}

input addEmailAttachmentReferenceInput {
	fileName: String!
	filePath: String!
}

input addEmailAttachmentTemplateInput {
	fileName: String!
	templateId: String!
}

"Add fact input"
input addFactInput {
	type: String!
	value: scalarValueInput
	values: scalarValueInput
}

"A command to create an identity for a user (customer or internal user)"
input addIdentityInput {
	type: String!
	value: String
}

"instance of jacket to add into offer"
input addJacketInstanceInput {
	jacketId: String!
	order: Int
	storeJacketByValue: Boolean
}

"Add lesson completion input"
input addLessonCompletionInput {
	itemAnswers: [lessonItemAnswerInput]
	lessonId: String!
}

"Adds an item to a lesson"
input addLessonItemInput {
	addedById: String
	type: lessonItemTypes
}

"Adds a lesson to section of a course"
input addLessonToSectionInput {
	addedById: String
	durationInSeconds: Int
	passingRatio: Decimal
	version: String
	weight: Decimal
}

"A command to create a note for a user or a policy"
input addNoteInput {
	content: String
	title: String
}

"adds an offer to a quote"
input addOfferInput {
	amount: Decimal
	benefitOptions: [benefitOptionInput]
	contractId: String
	currencyCode: currencyCodeEnumeration
	endDate: Date
	fields: String
	fieldsSchemaId: String
	policyId: String
	policyNumber: String
	premium: premiumInput
	pricing: String
	productId: productIdInput
	productTreeId: String
	productTreeRecords: [productTreeRecordInput]
	startDate: Date
	status: String
	underwriting: String
	values: [keyValueInput]
}

"Adds an option to a lesson item"
input addOptionToLessonItemInput {
	addedById: String
	isCorrect: Boolean
}

input addPageObjectToWkhtmltopdfTemplateInput {
	footerSettings: headerFooterInput
	headerSettings: headerFooterInput
	html: String
}

"Input to add the payment info to a policy"
input addPaymentInfoInput {
	amount: Decimal
	comment: String
	currencyCode: currencyCodeEnumeration
	endDate: DateTime
	frequency: paymentFrequency
	method: paymentMethod
	name: String
	payorId: String
	startDate: DateTime
}

input addPdfDrawingInput {
	font: fontInput
	liquidSource: String
	page: Int!
	point1: pointInput!
	point2: pointInput!
	textAlignment: textAlignmentEnumeration
	verticalAlignment: verticalAlignmentEnumeration
}

"instance of jacket to add into policy"
input addPolicyJacketInstanceInput {
	jacketId: String!
	order: Int
	storeJacketByValue: Boolean
}

input addPolicyNumberConfigInput {
	issuerId: String!
	policyNumber: Int
}

"Add proposal input"
input addProposalInput {
	expiryDate: Date
	name: String
	proposalNumber: String
	referralCode: String
	renewalHistory: renewalHistoryInput
	status: String
	totalPrice: premiumInput
}

input addScoreInput {
	comment: String
	type: String
	value: Decimal
}

input addScriptToProductInput {
	productId: productIdInput!
	scriptId: String!
}

input addStakeholderInput {
	entityId: String!
	type: String!
}

input addTargetedPermissionSchemaToLoginInput {
	loginId: String!
	permissionSchemaId: String!
	targetIds: [String!]!
}

"Input to add a permission to a target to a login"
input addTargettedPermissionInput {
	type: String!
	value: String!
}

input addTemplateRelationshipToProductInput {
	action: String!
	productId: productIdInput
	templateId: String!
}

input addUiSchemaToDataSchemaInput {
	dataSchemaId: String!
	uiSchemaId: String!
}

input addUnderwritingVariableInput {
	description: String
	jsonSchemaValidation: String
	name: String
}

"A command to create an address for a user (customer or internal user)"
input addressInput {
	fields: [adressFieldInput]
	type: String!
}

"A command to create an address field"
input adressFieldInput {
	type: String!
	value: String
}

input appWhereInput {
	and: [appWhereInput]
	appId: String
	appId_in: [String]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [appWhereInput]
}

"Approve guarantee of payment input"
input approveGOPInput {
	approvedAmount: Decimal
	excessAmount: Decimal
}

input attachmentInput {
	path: String
	type: String
}

input auth_KeyValuePairOfStringAndListOfStringInput {
	key: String!
	value: [String!]!
}

input auth_KeyValuePairOfStringAndStringInput {
	key: String!
	value: String!
}

input auth_SSOAuthCodeInput {
	authorizationCode: String
	id: String
	redirectUrl: String
	tokenEndpointUrl: String
}

input auth_SSOConfigInput {
	additionalClaims: [auth_KeyValuePairOfStringAndListOfStringInput!]
	claimsMap: [auth_KeyValuePairOfStringAndStringInput!]
	clientId: String
	clientSecret: String
	id: String
	idClaim: String
	keyUrl: String
	keyUrlClaim: String
	tenantId: String
	validateExistingLoginByEmail: Boolean
}

input auth_SSORefreshTokenInput {
	id: String
	refreshToken: String
	tokenEndpointUrl: String
}

input auth_UpdatePasswordValidatorsCommandInput {
	allowExpiredPasswordEasyReset: Boolean
	clientId: String
	enableLockout: Boolean
	exposeErrorMessage: Boolean
	id: String
	lockoutEmailTemplateId: String
	lockoutMaxFailedAccessAttempts: Int
	lockoutTimespanInSeconds: Int
	passwordLifespanInSeconds: Int
	passwordResetRequireDobVerification: Boolean
	requireConfirmPhoneNumber: Boolean
	requireConfirmedEmail: Boolean
	requireDigit: Boolean
	requireLength: Int
	requireLetter: Boolean
	requireLowercase: Boolean
	requireMaxConsecutiveRepeatingCharacters: Boolean
	requireMaxIncrementalSequenceCharacters: Boolean
	requireNonAlphanumeric: Boolean
	requireUniqueChars: Int
	requireUppercase: Boolean
	savePasswordHistoryCount: Int
	tempPasswordLifespanInSeonds: Int
}

input bankPaymentMethodInput {
	accountHolderName: String!
	bankName: String!
	bankNumber: String!
	branchCode: String
}

input batchBenefitDefinitionInput {
	createBenefitDefinitionInputs: [createBenefitDefinitionInput!]
	updateBenefitDefinitionInputs: [updateBenefitDefinitionInput!]
}

input batchBenefitDefinitionTypeInput {
	createBenefitDefinitionTypeInputs: [createBenefitDefinitionTypeInput!]
	updateBenefitDefinitionTypeInputs: [updateBenefitDefinitionTypeInput!]
}

input batchIdInput {
	id: String!
	name: String
}

"Specifies the proceeds eligibility of a beneficiary"
input beneficiaryEligibilityInput {
	"The benefit type id on which the benefit will be earned for the beneficiary."
	benefitTypeId: String
	"The user id"
	entityId: String!
	isRevocable: Boolean
	notes: String
	"The ratio of the policy benefit for this user"
	ratio: Decimal!
}

input benefitBatchInput {
	addBenefitInputs: [benefitInput]
	removeBenefitInputs: [removeBenefitInput]
	updateBenefitInputs: [benefitInput]
}

input benefitDefinitionTypeWhereInput {
	and: [benefitDefinitionTypeWhereInput]
	businessId_contains: String
	businessId_in: [String]
	fields: fieldsWhereInput
	id_in: [String]
	name_contains: String
	or: [benefitDefinitionTypeWhereInput]
	status: String
}

input benefitDefinitionWhereInput {
	and: [benefitDefinitionWhereInput]
	businessId_contains: String
	businessId_in: [String]
	fields: fieldsWhereInput
	id_in: [String]
	name_contains: String
	or: [benefitDefinitionWhereInput]
	status: String
	type: benefitDefinitionTypeWhereInput
}

"an input for a benefit"
input benefitInput {
	condition: conditionInput
	currencyCode: currencyCodeEnumeration
	isValueInput: Boolean
	optionKey: String
	parentOptionKeys: [String]
	parentTypeId: String
	typeId: String!
	value: scalarValueInput
	valueJsonString: String
}

"Chosen benefit option"
input benefitOptionInput {
	insuredId: String
	"Input the key if the benefit has a set of options"
	key: String
	typeId: String!
	"If free to input any value, fill this."
	value: scalarValueInput
}

"A benefit filter"
input benefitWhere {
	and: [benefitWhere]
	or: [benefitWhere]
	rawData_gt: String
	rawData_lt: String
	typeId: String
	typeId_in: [String]
}

input billing_AggregateStateMongoReadModelOfBillingInfoFilterInput {
	aggregate: billing_OpenAddressReadModelFilterInput
	and: [billing_AggregateStateMongoReadModelOfBillingInfoFilterInput!]
	created: Comparablebilling_DateTimeOffsetOperationFilterInput
	id: billing_StringOperationFilterInput
	or: [billing_AggregateStateMongoReadModelOfBillingInfoFilterInput!]
	state: billing_BillingInfoFilterInput
}

input billing_AggregateStateMongoReadModelOfBillingInfoSortInput {
	aggregate: billing_OpenAddressReadModelSortInput
	created: SortEnumType
	id: SortEnumType
	state: billing_BillingInfoSortInput
}

input billing_AggregateStateMongoReadModelOfDirectDebitPaymentChannelFilterInput {
	aggregate: billing_OpenAddressReadModelFilterInput
	and: [billing_AggregateStateMongoReadModelOfDirectDebitPaymentChannelFilterInput!]
	created: Comparablebilling_DateTimeOffsetOperationFilterInput
	id: billing_StringOperationFilterInput
	or: [billing_AggregateStateMongoReadModelOfDirectDebitPaymentChannelFilterInput!]
	state: billing_DirectDebitPaymentChannelFilterInput
}

input billing_AggregateStateMongoReadModelOfDirectDebitPaymentChannelSortInput {
	aggregate: billing_OpenAddressReadModelSortInput
	created: SortEnumType
	id: SortEnumType
	state: billing_DirectDebitPaymentChannelSortInput
}

input billing_AggregateStateMongoReadModelOfManualPaymentChannelFilterInput {
	aggregate: billing_OpenAddressReadModelFilterInput
	and: [billing_AggregateStateMongoReadModelOfManualPaymentChannelFilterInput!]
	created: Comparablebilling_DateTimeOffsetOperationFilterInput
	id: billing_StringOperationFilterInput
	or: [billing_AggregateStateMongoReadModelOfManualPaymentChannelFilterInput!]
	state: billing_ManualPaymentChannelFilterInput
}

input billing_AggregateStateMongoReadModelOfManualPaymentChannelSortInput {
	aggregate: billing_OpenAddressReadModelSortInput
	created: SortEnumType
	id: SortEnumType
	state: billing_ManualPaymentChannelSortInput
}

input billing_AuthorizeDirectDebitCommandInput {
	authorization: String
}

input billing_BillPremiumInstallmentAddAttachmentInput {
	attachmentPath: String!
}

input billing_BillPremiumInstallmentRemoveAttachmentInput {
	attachmentPath: String!
}

input billing_BillSetPaymentChannelInput {
	billRef: String!
	paymentChannelRef: String!
	paymentChannelType: billing_PaymentChannelType!
}

input billing_BillingBillFilterInput {
	amount: Comparablebilling_DecimalOperationFilterInput
	and: [billing_BillingBillFilterInput!]
	id: billing_StringOperationFilterInput
	or: [billing_BillingBillFilterInput!]
	paidAt: Comparablebilling_NullableOfDateTimeOffsetOperationFilterInput
	paymentChannelRef: billing_StringOperationFilterInput
	paymentChannelType: billing_NullableOfPaymentChannelTypeOperationFilterInput
	status: billing_BillingBillStatusOperationFilterInput
	toBeIssuedAt: Comparablebilling_DateTimeOffsetOperationFilterInput
}

input billing_BillingBillReadModelFilterInput {
	aggregate: billing_OpenAddressReadModelFilterInput
	and: [billing_BillingBillReadModelFilterInput!]
	bill: billing_BillingBillFilterInput
	billingInfo: billing_BillingInfoFilterInput
	id: billing_StringOperationFilterInput
	or: [billing_BillingBillReadModelFilterInput!]
	premiumInstallment: billing_BillingPremiumInstallmentFilterInput
}

input billing_BillingBillReadModelSortInput {
	aggregate: billing_OpenAddressReadModelSortInput
	bill: billing_BillingBillSortInput
	billingInfo: billing_BillingInfoSortInput
	id: SortEnumType
	premiumInstallment: billing_BillingPremiumInstallmentSortInput
}

input billing_BillingBillSortInput {
	amount: SortEnumType
	id: SortEnumType
	paidAt: SortEnumType
	paymentChannelRef: SortEnumType
	paymentChannelType: SortEnumType
	status: SortEnumType
	toBeIssuedAt: SortEnumType
}

input billing_BillingBillStatusOperationFilterInput {
	eq: billing_BillingBillStatus
	in: [billing_BillingBillStatus!]
	neq: billing_BillingBillStatus
	nin: [billing_BillingBillStatus!]
}

input billing_BillingInfoFilterInput {
	and: [billing_BillingInfoFilterInput!]
	billedToDate: Comparablebilling_NullableOfDateTimeOffsetOperationFilterInput
	currencyCode: billing_CurrencyCodeOperationFilterInput
	currentPremium: billing_BillingPremiumInstallmentFilterInput
	endDate: Comparablebilling_NullableOfDateTimeOffsetOperationFilterInput
	isDeleted: billing_BooleanOperationFilterInput
	leadTime: Comparablebilling_TimeSpanOperationFilterInput
	nextBillingAmount: Comparablebilling_NullableOfDecimalOperationFilterInput
	nextBillingDate: Comparablebilling_NullableOfDateTimeOffsetOperationFilterInput
	or: [billing_BillingInfoFilterInput!]
	outstandingAmount: Comparablebilling_DecimalOperationFilterInput
	paidToDate: Comparablebilling_NullableOfDateTimeOffsetOperationFilterInput
	period: billing_BillingPeriodOperationFilterInput
	policyRef: billing_StringOperationFilterInput
	premiumInstallments: Listbilling_GenericBillingPremiumInstallmentFilterFilterInput
	startDate: Comparablebilling_NullableOfDateTimeOffsetOperationFilterInput
}

input billing_BillingInfoSortInput {
	billedToDate: SortEnumType
	currencyCode: SortEnumType
	currentPremium: billing_BillingPremiumInstallmentSortInput
	endDate: SortEnumType
	isDeleted: SortEnumType
	leadTime: SortEnumType
	nextBillingAmount: SortEnumType
	nextBillingDate: SortEnumType
	outstandingAmount: SortEnumType
	paidToDate: SortEnumType
	period: SortEnumType
	policyRef: SortEnumType
	startDate: SortEnumType
}

input billing_BillingPeriodOperationFilterInput {
	eq: billing_BillingPeriod
	in: [billing_BillingPeriod!]
	neq: billing_BillingPeriod
	nin: [billing_BillingPeriod!]
}

input billing_BillingPremiumInstallmentFilterInput {
	and: [billing_BillingPremiumInstallmentFilterInput!]
	attachments: Listbilling_StringOperationFilterInput
	bills: Listbilling_GenericBillingBillFilterFilterInput
	dueDate: Comparablebilling_DateTimeOffsetOperationFilterInput
	id: billing_StringOperationFilterInput
	or: [billing_BillingPremiumInstallmentFilterInput!]
	pricingBreakdown: Listbilling_GenericBillingPricingBreakdownFilterFilterInput
	status: billing_BillingPremiumInstallmentStatusOperationFilterInput
}

input billing_BillingPremiumInstallmentSortInput {
	dueDate: SortEnumType
	id: SortEnumType
	status: SortEnumType
}

input billing_BillingPremiumInstallmentStatusOperationFilterInput {
	eq: billing_BillingPremiumInstallmentStatus
	in: [billing_BillingPremiumInstallmentStatus!]
	neq: billing_BillingPremiumInstallmentStatus
	nin: [billing_BillingPremiumInstallmentStatus!]
}

input billing_BillingPricingBreakdownFilterInput {
	accountType: billing_StringOperationFilterInput
	amount: Comparablebilling_DecimalOperationFilterInput
	and: [billing_BillingPricingBreakdownFilterInput!]
	description: billing_StringOperationFilterInput
	or: [billing_BillingPricingBreakdownFilterInput!]
}

input billing_BooleanOperationFilterInput {
	eq: Boolean
	neq: Boolean
}

input billing_CreateBillingInput {
	currencyCode: billing_CurrencyCode!
	leadTime: TimeSpan!
	period: billing_BillingPeriod!
	policyRef: String!
}

input billing_CreateDirectDebitPaymentChannelCommandInput {
	bank: String!
	directDebit: String!
	fields: String
	holderId: String!
}

input billing_CreateManualPaymentChannelCommandInput {
	fields: String
	holderId: String!
}

input billing_CurrencyCodeOperationFilterInput {
	eq: billing_CurrencyCode
	in: [billing_CurrencyCode!]
	neq: billing_CurrencyCode
	nin: [billing_CurrencyCode!]
}

input billing_DirectDebitPaymentChannelFilterInput {
	and: [billing_DirectDebitPaymentChannelFilterInput!]
	authorization: billing_StringOperationFilterInput
	bank: billing_StringOperationFilterInput
	bankResponse: billing_StringOperationFilterInput
	directDebit: billing_StringOperationFilterInput
	fields: billing_StringOperationFilterInput
	holderId: billing_StringOperationFilterInput
	or: [billing_DirectDebitPaymentChannelFilterInput!]
	status: billing_NullableOfDirectDebitPaymentChannelStatusOperationFilterInput
	type: billing_PaymentChannelTypeOperationFilterInput
}

input billing_DirectDebitPaymentChannelSortInput {
	authorization: SortEnumType
	bank: SortEnumType
	bankResponse: SortEnumType
	directDebit: SortEnumType
	fields: SortEnumType
	holderId: SortEnumType
	status: SortEnumType
	type: SortEnumType
}

input billing_ManualPaymentChannelFilterInput {
	and: [billing_ManualPaymentChannelFilterInput!]
	fields: billing_StringOperationFilterInput
	holderId: billing_StringOperationFilterInput
	or: [billing_ManualPaymentChannelFilterInput!]
	status: billing_NullableOfManualPaymentChannelStatusOperationFilterInput
	type: billing_PaymentChannelTypeOperationFilterInput
}

input billing_ManualPaymentChannelSortInput {
	fields: SortEnumType
	holderId: SortEnumType
	status: SortEnumType
	type: SortEnumType
}

input billing_NullableOfDirectDebitPaymentChannelStatusOperationFilterInput {
	eq: billing_DirectDebitPaymentChannelStatus
	in: [billing_DirectDebitPaymentChannelStatus]
	neq: billing_DirectDebitPaymentChannelStatus
	nin: [billing_DirectDebitPaymentChannelStatus]
}

input billing_NullableOfManualPaymentChannelStatusOperationFilterInput {
	eq: billing_ManualPaymentChannelStatus
	in: [billing_ManualPaymentChannelStatus]
	neq: billing_ManualPaymentChannelStatus
	nin: [billing_ManualPaymentChannelStatus]
}

input billing_NullableOfPaymentChannelTypeOperationFilterInput {
	eq: billing_PaymentChannelType
	in: [billing_PaymentChannelType]
	neq: billing_PaymentChannelType
	nin: [billing_PaymentChannelType]
}

input billing_OpenAddressReadModelFilterInput {
	and: [billing_OpenAddressReadModelFilterInput!]
	id: Comparablebilling_GuidOperationFilterInput
	or: [billing_OpenAddressReadModelFilterInput!]
	typeName: billing_StringOperationFilterInput
	typeVersion: Comparablebilling_NullableOfInt32OperationFilterInput
	version: Comparablebilling_NullableOfInt32OperationFilterInput
}

input billing_OpenAddressReadModelSortInput {
	id: SortEnumType
	typeName: SortEnumType
	typeVersion: SortEnumType
	version: SortEnumType
}

input billing_PaymentChannelTypeOperationFilterInput {
	eq: billing_PaymentChannelType
	in: [billing_PaymentChannelType!]
	neq: billing_PaymentChannelType
	nin: [billing_PaymentChannelType!]
}

input billing_SetBankResponseCommandInput {
	bankResponse: String!
	billingInfoId: String!
	policyId: String!
}

input billing_StringOperationFilterInput {
	and: [billing_StringOperationFilterInput!]
	contains: String
	endsWith: String
	eq: String
	in: [String]
	ncontains: String
	nendsWith: String
	neq: String
	nin: [String]
	nstartsWith: String
	or: [billing_StringOperationFilterInput!]
	startsWith: String
}

input billing_UpdateBillingInput {
	currencyCode: billing_CurrencyCode
	leadTime: TimeSpan
	period: billing_BillingPeriod
}

input billing_UpdateDirectDebitPaymentChannelCommandInput {
	directDebit: String
	fields: String
}

input billing_UpdateManualPaymentChannelCommandInput {
	fields: String
}

input binderInput {
	bindingDate: Date
	commissionRule: commissionRuleInput
	endDate: Date
	firstPartyEntityId: String
	name: String
	otherIds: [otherIdInput!]
	secondPartyEntityId: String
	startDate: Date
}

"A binder search filter"
input binderWhereInput {
	and: [binderWhereInput]
	commissionRuleWhere: commissionRuleWhereInput
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [binderWhereInput]
	status: String
}

input bucketWhereInput {
	bucketName: String
}

input cardPaymentMethodInput {
	brand: String
	cardholderName: String
	cvc: String!
	expMonth: Int!
	expYear: Int!
	name: String
	number: String!
}

"a case filter"
input caseWhere {
	and: [caseWhere]
	caseNumber: String
	caseNumber_contains: String
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	facts_contains: factWhereInput
	fieldsWhere: fieldsWhereInput
	havingIssuedPolicies: Boolean
	holderCompany: individualWhereInput
	holderId: String
	holderId_in: [String]
	holderIndividual: individualWhereInput
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	name_contains: String
	or: [caseWhere]
	proposal: proposalWhere
	proposals_contains: proposalWhere
	proposals_every: proposalWhere
	proposals_exist: Boolean
	source: String
	source_contains: String
	stakeholders_contains: stakeholderWhere
	status: String
}

input cases_BrokerFilterInput {
	channel_in: [String]
	code_in: [String]
	contactPersonEmail_contains: String
	contactPersonEmail_in: [String]
	contactPersonFaxNo_in: [String]
	contactPersonTelNo_in: [String]
	contactPerson_contains: String
	contactPerson_in: [String]
	fields: cases_FieldsWhereInput
	group_in: [String]
	id: String
	id_contains: String
	id_in: [String]
}

input cases_BrokerUpsertInput {
	byId: String
	channel: String
	code: String
	contactPerson: String
	contactPersonEmail: String
	contactPersonFaxNo: String
	contactPersonTelNo: String
	fields: String
	group: String
	id: String
}

input cases_CounterFilterInput {
	scope: String
}

input cases_FieldsWhereInput {
	and: [cases_FieldsWhereInput]
	condition: cases_FieldsWhereCondition!
	or: [cases_FieldsWhereInput]
	path: String
	value: cases_ScalarValueInput
}

input cases_GenericBroker3BatchInput {
	create: [cases_BrokerUpsertInput]
	delete: [cases_BrokerUpsertInput]
	update: [cases_BrokerUpsertInput]
}

input cases_GenericBrokerFilterInput {
	and: [cases_GenericBrokerFilterInput]
	or: [cases_GenericBrokerFilterInput]
	where: cases_BrokerFilterInput
}

input cases_GenericBrokerQueryInput {
	asOf: DateTime
	first: Int
	groupBy: cases_GroupByInput
	includeEvents: Boolean
	orderBy: cases_OrderByInput
	orderBy2: [cases_OrderByInput!]
	skip: Int
	where: cases_GenericBrokerFilterInput
}

input cases_GenericCounterFilterInput {
	and: [cases_GenericCounterFilterInput]
	or: [cases_GenericCounterFilterInput]
	where: cases_CounterFilterInput
}

input cases_GenericCounterQueryInput {
	asOf: DateTime
	first: Int
	groupBy: cases_GroupByInput
	includeEvents: Boolean
	orderBy: cases_OrderByInput
	orderBy2: [cases_OrderByInput!]
	skip: Int
	where: cases_GenericCounterFilterInput
}

input cases_GroupByInput {
	fieldName: String
}

input cases_IncreaseCounterCommandInput {
	counterKey: String!
	scope: String!
}

input cases_KeyScalarValueInput {
	key: String
	value: cases_ScalarValueInput
}

input cases_OrderByInput {
	fieldName: String
	type: cases_OrderByType!
}

input cases_ProductTreeRecordInput {
	recordId: String
	type: String
}

input cases_RecordQuoteCommandInput {
	fields: String
	offerId: String
	productTreeRecords: [cases_ProductTreeRecordInput]
	proposalId: String
}

input cases_ScalarValueInput {
	arrayValue: [cases_ScalarValueInput]
	booleanValue: Boolean
	dateValue: DateTime
	numberValue: Decimal
	objectValue: [cases_KeyScalarValueInput]
	stringValue: String
}

"Input to change the expired password"
input changeExpiredPasswordInput {
	currentPassword: String!
	newPassword: String!
	userName: String!
}

"Input to change the password"
input changePasswordInput {
	currentPassword: String!
	ignorePasswordValidation: Boolean
	newPassword: String!
	sendNotificationCommand: sendNotificationInput
}

"A chat message"
input chatMessageInput {
	attachements: [String]
	content: String
	fromName: String
}

input claimBatchInput {
	createClaimCommands: [createClaimBatchInput]
	updateClaimCommands: [updateClaimBatchInput]
}

"ClaimReport Filter Input"
input claimReportFilterInput {
	and: [claimReportFilterInput]
	or: [claimReportFilterInput]
	where: claimReportFilterWhereInput
}

"ClaimReport Filter Where Input"
input claimReportFilterWhereInput {
	claimSnapshots_ClaimSettmentMode: String
	claimSnapshots_ClaimSettmentMode_in: [String]
	claimSnapshots_HasReversal: Boolean
	claimSnapshots_IsPanel: Boolean
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	name: String
	name_in: [String]
	reportDate: DateTimeOffset
	reportDate_gt: DateTimeOffset
	reportDate_lt: DateTimeOffset
}

input claimSettingsInput {
	diagnosisSettings: diagnosisSettingsInput
	operationSettings: operationSettingsInput
	providerSettings: providerSettingsInput
	rejectionSettings: rejectionSettingsInput
}

"ClaimSnapshot Filter Input"
input claimSnapshotFilterInput {
	and: [claimSnapshotFilterInput]
	or: [claimSnapshotFilterInput]
	where: claimSnapshotFilterWhereInput
}

"ClaimSnapshot Filter Where Input"
input claimSnapshotFilterWhereInput {
	approvedDate_gt: DateTimeOffset
	approvedDate_gte: DateTimeOffset
	approvedDate_lt: DateTimeOffset
	approvedDate_lte: DateTimeOffset
	claimApprover: String
	claimHandler: String
	claimId: String
	claimNo: String
	claimReportId: String
	claimReportId_in: [String]
	claimSettlementMode: String
	claimType: String
	claimantInternalCode: String
	claimantName: String
	companyBankAccount: String
	companyBankCode: String
	companyName: String
	createdAt_gt: DateTimeOffset
	createdAt_gte: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdAt_lte: DateTimeOffset
	employeeBankAccount: String
	employeeBankCode: String
	employeeInternalCode: String
	employeeName: String
	exportBatchNumber: String
	exportBatchNumber_contains: String
	formReceivedDate_gt: DateTimeOffset
	formReceivedDate_gte: DateTimeOffset
	formReceivedDate_lt: DateTimeOffset
	formReceivedDate_lte: DateTimeOffset
	hasReversal: Boolean
	id: String
	incurredDate_gt: DateTimeOffset
	incurredDate_gte: DateTimeOffset
	incurredDate_lt: DateTimeOffset
	incurredDate_lte: DateTimeOffset
	invoiceNo: String
	isPanel: Boolean
	panelBankAccount: String
	panelBankCode: String
	panelBankName: String
	panelBranchCode: String
	panelName: String
	panelP400ClientNumber: String
	policyHolder: String
	policyNo: String
	settlementDate_gt: DateTimeOffset
	settlementDate_gte: DateTimeOffset
	settlementDate_lt: DateTimeOffset
	settlementDate_lte: DateTimeOffset
	settlementFollowingWorkingDate_gt: DateTimeOffset
	settlementFollowingWorkingDate_gte: DateTimeOffset
	settlementFollowingWorkingDate_lt: DateTimeOffset
	settlementFollowingWorkingDate_lte: DateTimeOffset
	status: String
	status_in: [String]
}

"Input for the value of the claim"
input claimValueInput {
	approvedAmount: Decimal
	approvedCurrency: currencyCodeEnumeration
	billedAmount: Decimal
	billedCurrency: currencyCodeEnumeration
	unit: String
}

"A claim search filter"
input claimWhereInput {
	and: [claimWhereInput]
	claimantId: String
	claimantId_in: [String]
	claimant_contains: entityWhereInput
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	exportBatchId: String
	exportBatchIdName: String
	exportBatchIdName_contains: String
	exportBatchId_in: [String]
	fields: fieldsWhereInput
	guaranteeOfPaymentId: String
	guaranteeOfPaymentId_exists: Boolean
	guaranteeOfPaymentId_in: [String]
	id: String
	id_in: [String]
	importBatchId: String
	importBatchIdName: String
	importBatchIdName_contains: String
	importBatchId_in: [String]
	issuerNumber: String
	issuerNumber_contains: String
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [claimWhereInput]
	panelId: String
	panelId_exists: Boolean
	panelId_in: [String]
	policyId_in: [String]
	policy_contains: policyWhereInput
	providerId: String
	providerId_exists: Boolean
	providerId_in: [String]
	status: String
}

input claims_AddGopInBatchCommandInput {
	addedById: String
	claimId: String
	guaranteeOfPaymentId: String
}

input claims_AuthorityLimitFilterInput {
	createdAt_gt: DateTime
	createdAt_gte: DateTime
	createdAt_lt: DateTime
	createdAt_lte: DateTime
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTime
	lastModifiedAt_gte: DateTime
	lastModifiedAt_lt: DateTime
	lastModifiedAt_lte: DateTime
	permissionGroupId: String
	permissionGroupId_in: [String]
}

input claims_AuthorityLimitUpsertInput {
	approvalExpenseLimit: Decimal
	approvalPaymentLimit: Decimal
	id: String
	permissionGroupId: String!
	reserveExpenseLimit: Decimal
	reservePaymentLimit: Decimal
}

input claims_BatchIdInput {
	id: String
	name: String
}

input claims_BenefitBalanceCalculationInput {
	individualId: String!
	otherFields: String
	policyId: String!
}

input claims_ClaimDataInsightFilterInput {
	clientTimezone: String = "Asia/Hong_Kong"
	companyId: String
	period: claims_ClaimDataInsightPeriod!
	policyId: String
}

input claims_ClaimIdsInput {
	claimIds: [String]
}

input claims_ClaimRejectionCodeFilterInput {
	code_in: [String]
	description_contains: String
	fieldsWhere: claims_FieldsWhereInput
	id: String
}

input claims_ClaimRejectionCodeUpsertInput {
	code: String
	description: String
	fields: String
	id: String
}

input claims_ClaimRejectionReasonFilterInput {
	code_in: [String]
	fields: claims_FieldsWhereInput
	id: String
	id_in: [String]
	type_in: [String]
}

input claims_ClaimRejectionReasonUpsertInput {
	code: String
	fields: String
	id: String
	type: String
}

input claims_ClaimRequestReasonFilterInput {
	code_in: [String]
	fields: claims_FieldsWhereInput
	id: String
	type_contains: String
	type_in: [String]
}

input claims_ClaimRequestReasonUpsertInput {
	code: String
	fields: String
	id: String
	type: String
}

input claims_CreateAttachedRuleCommandOfclaimsAttachedCommandPermissionInput {
	create: claims_claimsAttachedCommandPermissionInput
	id: String
}

input claims_CreateAttachedRuleCommandOfclaimsAttachedExternalApiCallInput {
	create: claims_claimsAttachedExternalApiCallInput
	id: String
}

input claims_CreateAttachedRuleCommandOfclaimsAttachedFilterInput {
	create: claims_claimsAttachedFilterInput
	id: String
}

input claims_CreateAttachedRuleCommandOfclaimsAttachedObjectValidationInput {
	create: claims_claimsAttachedObjectValidationInput
	id: String
}

input claims_CreateAttachedRuleCommandOfclaimsAttachedPostHandleValidationInput {
	create: claims_claimsAttachedPostHandleValidationInput
	id: String
}

input claims_CreateClaimEventCommandInput {
	claimantId: String
	eventType: claims_ClaimEventType!
	exportBatchId: claims_BatchIdInput
	fields: String
	fieldsPatch: String
	importBatchId: claims_BatchIdInput
	importedById: String
	issuerNumber: String
	panelId: String
	policyId: String
	providerId: String
	reason: String
	remark: String
	status: String
	timeStamp: DateTime!
	updateType: String
	withStatus: String
}

input claims_DeleteAttachedRuleCommandOfclaimsAttachedCommandPermissionInput {
	id: String
}

input claims_DeleteAttachedRuleCommandOfclaimsAttachedExternalApiCallInput {
	id: String
}

input claims_DeleteAttachedRuleCommandOfclaimsAttachedFilterInput {
	id: String
}

input claims_DeleteAttachedRuleCommandOfclaimsAttachedObjectValidationInput {
	id: String
}

input claims_DeleteAttachedRuleCommandOfclaimsAttachedPostHandleValidationInput {
	id: String
}

input claims_ExternalApiCallInput {
	afterCall: [String!]
	beforeCall: [String!]
	contentType: String
	contextSlug: String
	expectedContentExpression: String
	expectedResponseExpression: String
	headers: [claims_KeyValuePairOfStringAndStringInput!]
	itemValidationExpression: String
	method: String!
	stringContent: String
	timeout: String
	url: String!
}

input claims_FieldsWhereInput {
	and: [claims_FieldsWhereInput]
	condition: claims_FieldsWhereCondition!
	or: [claims_FieldsWhereInput]
	path: String
	value: claims_ScalarValueInput
}

input claims_GenericAuthorityLimit3BatchInput {
	create: [claims_AuthorityLimitUpsertInput]
	delete: [claims_AuthorityLimitUpsertInput]
	update: [claims_AuthorityLimitUpsertInput]
}

input claims_GenericAuthorityLimitFilterInput {
	and: [claims_GenericAuthorityLimitFilterInput]
	or: [claims_GenericAuthorityLimitFilterInput]
	where: claims_AuthorityLimitFilterInput
}

input claims_GenericAuthorityLimitQueryInput {
	asOf: DateTime
	first: Int
	groupBy: claims_GroupByInput
	includeEvents: Boolean
	orderBy: claims_OrderByInput
	orderBy2: [claims_OrderByInput!]
	skip: Int
	where: claims_GenericAuthorityLimitFilterInput
}

input claims_GenericClaimRejectionCode3BatchInput {
	create: [claims_ClaimRejectionCodeUpsertInput]
	delete: [claims_ClaimRejectionCodeUpsertInput]
	update: [claims_ClaimRejectionCodeUpsertInput]
}

input claims_GenericClaimRejectionCodeFilterInput {
	and: [claims_GenericClaimRejectionCodeFilterInput]
	or: [claims_GenericClaimRejectionCodeFilterInput]
	where: claims_ClaimRejectionCodeFilterInput
}

input claims_GenericClaimRejectionCodeQueryInput {
	asOf: DateTime
	first: Int
	groupBy: claims_GroupByInput
	includeEvents: Boolean
	orderBy: claims_OrderByInput
	orderBy2: [claims_OrderByInput!]
	skip: Int
	where: claims_GenericClaimRejectionCodeFilterInput
}

input claims_GenericClaimRejectionReason3BatchInput {
	create: [claims_ClaimRejectionReasonUpsertInput]
	delete: [claims_ClaimRejectionReasonUpsertInput]
	update: [claims_ClaimRejectionReasonUpsertInput]
}

input claims_GenericClaimRejectionReasonFilterInput {
	and: [claims_GenericClaimRejectionReasonFilterInput]
	or: [claims_GenericClaimRejectionReasonFilterInput]
	where: claims_ClaimRejectionReasonFilterInput
}

input claims_GenericClaimRejectionReasonQueryInput {
	asOf: DateTime
	first: Int
	groupBy: claims_GroupByInput
	includeEvents: Boolean
	orderBy: claims_OrderByInput
	orderBy2: [claims_OrderByInput!]
	skip: Int
	where: claims_GenericClaimRejectionReasonFilterInput
}

input claims_GenericClaimRequestReason3BatchInput {
	create: [claims_ClaimRequestReasonUpsertInput]
	delete: [claims_ClaimRequestReasonUpsertInput]
	update: [claims_ClaimRequestReasonUpsertInput]
}

input claims_GenericClaimRequestReasonFilterInput {
	and: [claims_GenericClaimRequestReasonFilterInput]
	or: [claims_GenericClaimRequestReasonFilterInput]
	where: claims_ClaimRequestReasonFilterInput
}

input claims_GenericClaimRequestReasonQueryInput {
	asOf: DateTime
	first: Int
	groupBy: claims_GroupByInput
	includeEvents: Boolean
	orderBy: claims_OrderByInput
	orderBy2: [claims_OrderByInput!]
	skip: Int
	where: claims_GenericClaimRequestReasonFilterInput
}

input claims_GenericClaims_AttachedRuleFilterInput {
	and: [claims_GenericClaims_AttachedRuleFilterInput]
	or: [claims_GenericClaims_AttachedRuleFilterInput]
	where: claims_claims_AttachedRuleFilterInput
}

input claims_GenericClaims_AttachedRuleQueryInput {
	asOf: DateTime
	first: Int
	groupBy: claims_GroupByInput
	includeEvents: Boolean
	orderBy: claims_OrderByInput
	orderBy2: [claims_OrderByInput!]
	skip: Int
	where: claims_GenericClaims_AttachedRuleFilterInput
}

input claims_GenericPreExistingCondition3BatchInput {
	create: [claims_PreExistingConditionUpsertInput]
	delete: [claims_PreExistingConditionUpsertInput]
	update: [claims_PreExistingConditionUpsertInput]
}

input claims_GenericPreExistingConditionFilterInput {
	and: [claims_GenericPreExistingConditionFilterInput]
	or: [claims_GenericPreExistingConditionFilterInput]
	where: claims_PreExistingConditionFilterInput
}

input claims_GenericPreExistingConditionQueryInput {
	asOf: DateTime
	first: Int
	groupBy: claims_GroupByInput
	includeEvents: Boolean
	orderBy: claims_OrderByInput
	orderBy2: [claims_OrderByInput!]
	skip: Int
	where: claims_GenericPreExistingConditionFilterInput
}

input claims_GroupByInput {
	fieldName: String
}

input claims_GuaranteeOfPaymentBatchCommandInput {
	addGuaranteeOfPaymentCommands: [claims_AddGopInBatchCommandInput]
}

input claims_ImportClaimCommandInput {
	claimId: String
	createClaimEventCommands: [claims_CreateClaimEventCommandInput]
}

input claims_ImportClaimsCommandInput {
	importClaimCommands: [claims_ImportClaimCommandInput]
}

input claims_KeyScalarValueInput {
	key: String
	value: claims_ScalarValueInput
}

input claims_KeyValuePairOfStringAndStringInput {
	key: String!
	value: String!
}

input claims_OrderByInput {
	fieldName: String
	type: claims_OrderByType!
}

input claims_PreExistingConditionFilterInput {
	code: String
	code_in: [String]
	description: String
	id: String
	id_in: [String]
}

input claims_PreExistingConditionUpsertInput {
	category: String
	classification: String
	code: String
	description: String
	disease: String
	diseaseLevel: String
	id: String
	profile: String
	risk: String
	specialty: String
	subClassification: String
	summary: String
	typeOfDisease: String
}

input claims_PreRequestApprovalCommandInput {
	claimIds: [String]
	modifiedById: String
}

input claims_ReplayEventsInput {
	claimIds: [String]
}

input claims_ScalarValueInput {
	arrayValue: [claims_ScalarValueInput]
	booleanValue: Boolean
	dateValue: DateTime
	numberValue: Decimal
	objectValue: [claims_KeyScalarValueInput]
	stringValue: String
}

input claims_SettlementReportFilterInput {
	claimIdIn: [String]
}

input claims_UpdateAttachedRuleCommandOfclaimsAttachedCommandPermissionInput {
	id: String
	update: claims_claimsAttachedCommandPermissionInput
}

input claims_UpdateAttachedRuleCommandOfclaimsAttachedExternalApiCallInput {
	id: String
	update: claims_claimsAttachedExternalApiCallInput
}

input claims_UpdateAttachedRuleCommandOfclaimsAttachedFilterInput {
	id: String
	update: claims_claimsAttachedFilterInput
}

input claims_UpdateAttachedRuleCommandOfclaimsAttachedObjectValidationInput {
	id: String
	update: claims_claimsAttachedObjectValidationInput
}

input claims_UpdateAttachedRuleCommandOfclaimsAttachedPostHandleValidationInput {
	id: String
	update: claims_claimsAttachedPostHandleValidationInput
}

input claims_UpdateGuaranteeOfPaymentBatchCommandInput {
	updateGuaranteeOfPaymentCommands: [claims_UpdateGuaranteeOfPaymentCommandInput]
}

input claims_UpdateGuaranteeOfPaymentCommandInput {
	currencyCode: claims_CurrencyCode
	doctor: String
	estimatedAmount: Decimal
	fields: String
	fieldsPatch: String
	guaranteeOfPaymentId: String
	isCurrencyCodeChanged: Boolean!
	isDoctorChanged: Boolean!
	isEstimatedAmountChanged: Boolean!
	isFieldsChanged: Boolean!
	isProviderIdChanged: Boolean!
	isStatusChanged: Boolean!
	modifiedById: String
	providerId: String
	status: String
	updateType: String
}

input claims_claimsAttachedCommandPermissionInput {
	action: claims_AttachedRuleAllowAction!
	command: String!
	commandExpression: String
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input claims_claimsAttachedExternalApiCallInput {
	apiCalls: [claims_ExternalApiCallInput!]!
	description: String
	eventExpression: String
	forEach: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input claims_claimsAttachedFilterInput {
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input claims_claimsAttachedObjectValidationInput {
	action: claims_AttachedRuleAllowAction!
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input claims_claimsAttachedPostHandleValidationInput {
	action: claims_AttachedRuleAllowAction!
	description: String
	eventExpression: String
	group: Int!
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input claims_claims_AttachedRuleFilterInput {
	id: String
	userExpression: String
}

"clause batch add input"
input clauseBatchAddInput {
	htmlOverride: String
	order: Int
	renderParameters: templateRenderParametersInput
	storeTemplateByValue: Boolean
	templateId: String
	type: String
}

input clauseBatchInput {
	addClauseInputs: [clauseBatchAddInput]
	updateClauseInputs: [clauseBatchUpdateInput]
}

"clause batch update input"
input clauseBatchUpdateInput {
	clauseId: String!
	htmlOverride: String
	isOrderChanged: Boolean!
	isTemplateIdChanged: Boolean
	order: Int
	renderParameters: templateRenderParametersInput
	storeTemplateByValue: Boolean
	templateId: String
	type: String
}

"Input to clone a custom product"
input cloneProductInput {
	cloneProductId: productIdInput!
	issuerProductId: String
}

input cmsComponentRouteInput {
	children: cmsComponentRouteInput
	component: String
	metaJsonString: String
	name: String
	path: String
	propsJsonString: String
	redirect: String
}

input cmsConfigInput {
	allowedLocales: [String!]
	analyticsProvidersJsonString: String
	baseComponentsVariantsJsonString: String
	componentRoutes: [cmsComponentRouteInput!]
	defaultLocale: String
	endpointsJsonString: String
	guestLoginCredentials: cmsGuestLoginCredentialsInput
	head: cmsHeadConfigInput
	httpHeadersJsonString: String
	paymentProvidersJsonString: String
	themeJsonString: String
}

input cmsGuestLoginCredentialsInput {
	password: String!
	username: String!
}

input cmsHeadConfigInput {
	linkJsonString: String
	metaJsonString: String
	noScript: [cmsScriptConfigInput!]
	script: [cmsScriptConfigInput!]
	title: String
}

input cmsScriptConfigInput {
	afterLoad: Boolean
	async: Boolean
	body: Boolean
	defer: Boolean
	innerHTML: String
	src: String
}

input commissionInput {
	amount: Decimal
	currencyCode: currencyCodeEnumeration
	entityId: String
	jsonRule: String
	remark: String
}

"Commission rule input"
input commissionRuleInput {
	description: String
	jsonRule: String!
	name: String
	productId: productIdInput
}

"A commission rule search filter"
input commissionRuleWhereInput {
	and: [commissionRuleWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	entityId: String
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [commissionRuleWhereInput]
	productId: productIdWhereInput
}

"A company search filter"
input companyWhereInput {
	acceptsMarketing: Boolean
	and: [companyWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	email: String
	email_contains: String
	email_in: [String]
	facts_contains: factWhereInput
	fields: fieldsWhereInput
	hasMigrationBatchId: Boolean
	id: String
	id_contains: String
	id_in: [String]
	identities_contains: identityWhereInput
	internalCode: String
	internalCode_contains: String
	internalCode_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	migrationBatchId: String
	migrationBatchId_in: [String]
	name: String
	name_contains: String
	name_in: [String]
	natureOfBusiness: String
	natureOfBusiness_contains: String
	natureOfBusiness_in: [String]
	or: [companyWhereInput]
	registrationNumber: String
	registrationNumber_contains: String
	registrationNumber_in: [String]
	relationshipListType: String
	relationshipListType_in: [String]
	relationshipList_contains: relationshipListWhereInput
	source: String
	source_contains: String
	source_in: [String]
	status: String
	status_in: [String]
	tags_contains: String
	tags_exists: Boolean
	telephoneNumber: String
	telephoneNumber_contains: String
	telephoneNumber_in: [String]
	type: companyTypeEnumeration
	type_in: [companyTypeEnumeration]
}

input componentVersionInput {
	framework: String!
	version: String!
}

"A claim search filter"
input componentWhereInput {
	and: [componentWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	name: String
	or: [componentWhereInput]
	status: String
}

input conditionInput {
	jsonLogicRuleString: String
	type: String
}

input copyFileInput {
	key: String!
	newKey: String!
}

"Copies a proposal"
input copyProposalInput {
	copiedFromId: String!
}

"A course progression search filter"
input courseProgressionWhereInput {
	and: [courseProgressionWhereInput]
	courseId: String
	courseId_in: [String]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	entityId: String
	entityId_in: [String]
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [courseProgressionWhereInput]
}

"A course search filter"
input courseWhereInput {
	and: [courseWhereInput]
	categories_contains_some: [String]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	name_contains: String
	or: [courseWhereInput]
}

"Input to get an accessToken using otpLogin.Token and One Time Password"
input createAccessTokenFromOtpLoginInput {
	oneTimePassword: String!
	token: String!
}

"Create achievemen  input"
input createAchievementInput {
	achievementTypeId: String!
	entityId: String!
}

"Create achievement type input"
input createAchievementTypeInput {
	logic: achievementLogicInput
	type: String
}

input createAdminInput {
	email: String!
	password: String!
	username: String!
}

input createAppInput {
	absoluteRefreshTokenLifetime: Int
	accessTokenLifetime: Int
	activationTokenExpiryDisabled: Boolean
	appConfig: String
	appId: String!
	appName: String!
	defaultTimeZone: String
	email: String
	emailConfirmationTokenLifespan: Seconds
	emailSenderName: String
	redirectUris: [String]
	requires2FA: Boolean
	requiresEmail2FA: Boolean
	slidingRefreshTokenLifetime: Int
	urlRouting: urlRoutingInput
	useNotificationConfig: Boolean
}

input createBenefitDefinitionInput {
	benefitDefinitionTypeIds: [String!]
	businessId: String
	description: String
	fields: String
	name: String
	status: String
}

input createBenefitDefinitionTypeInput {
	businessId: String
	description: String
	fields: String
	name: String
	status: String
}

"Create case input"
input createCaseInput {
	caseNumber: String
	componentId: String
	description: String
	fields: String
	fieldsSchemaId: String
	holderId: String
	insuredIds: [String]
	name: String
	otherHolderIds: [String]
	source: String
	status: String
	workflowSchemaId: String
}

"Create Claim Batch Input"
input createClaimBatchInput {
	claimantId: String
	diagnosisCodes: [String]
	fields: String
	id: ID
	importBatchId: batchIdInput
	issuerNumber: String
	operationCodes: [String]
	panelId: String
	policyId: String
	providerId: String
	status: String
}

"Create claim input"
input createClaimInput {
	claimantId: String
	diagnosisCodes: [String]
	fields: String
	id: ID
	issuerNumber: String
	operationCodes: [String]
	panelId: String
	policyId: String
	providerId: String
	remark: String
	status: String
	tempAttachmentFolderKey: String
}

input createClauseHtmlTemplateInput {
	description: String
	graphQlQuery: String
	html: String
	logicalId: String
	name: String
	order: Int
	status: String
}

"A command to create a company"
input createCompanyInput {
	acceptsMarketing: Boolean
	addresses: [addressInput]
	contacts: [addContactInput]
	email: String
	facts: [addFactInput]
	fields: String
	identities: [addIdentityInput]
	internalCode: String
	internalCodeGenerationStrategy: internalCodeGenerationStrategy
	internalCodeLength: Int
	linkedTo: String
	nameFormat: String
	natureOfBusiness: String
	photoPath: String
	registrationNumber: String
	source: String
	status: String
	tags: [String]
	telephoneNumber: String
	type: companyTypeEnumeration
}

input createComponentInput {
	componentJsonString: String!
	name: String!
	status: componentStatusEnumeration
	version: componentVersionInput
	vueTemplate: String
}

"Create course input"
input createCourseInput {
	categories: [String]
	version: String
}

"Create Course Progression input"
input createCourseProgressionInput {
	courseId: String
	entityId: String
}

input createDataSchemaInput {
	description: String!
	name: String!
	schema: String!
	standard: dataSchemaStandardInput
	tags: [String]
	type: String
}

input createDynamicTemplateInput {
	description: String
	logicalId: String
	name: String
	tags: [String]
}

input createEmailMjmlTemplateInput {
	description: String
	graphQlQuery: String
	logicalId: String
	mjml: String
	name: String
	subject: String
}

input createFunctionTemplateInput {
	description: String
	engine: engineInput
	fileKey: String
	graphQlQuery: String
	inputs: [functionInputInput]
	logicalId: String
	name: String
	outputs: [functionOutputInput]
}

"Create guarantee of payment input"
input createGOPInput {
	currencyCode: currencyCodeEnumeration
	doctor: String
	estimatedAmount: Decimal
	fields: String
	issuerNumber: String
	memberId: String
	policyId: String
	providerId: String
	status: String
}

"A command to create an individual"
input createIndividualInput {
	acceptsMarketing: Boolean
	addresses: [addressInput]
	chineseFirstName: String
	chineseLastName: String
	contacts: [addContactInput]
	countryOfResidency: String
	dateOfBirth: Date
	email: String
	employmentStatus: String
	englishFirstName: String
	englishLastName: String
	facts: [addFactInput]
	fields: String
	gender: String
	identities: [addIdentityInput]
	incomeRange: rangeInput
	internalCode: String
	internalCodeGenerationStrategy: internalCodeGenerationStrategy
	internalCodeLength: Int
	linkedTo: String
	maritalStatus: String
	nameFormat: String
	occupation: String
	photoPath: String
	preferredCommunicationChannel: String
	preferredLanguage: String
	salutation: String
	source: String
	status: String
	tags: [String]
	telephoneNumber: String
	type: individualTypeEnumeration
}

"The insurer to be added"
input createInsurerInput {
	id: String!
	logoUrls: logoUrlsInput
}

"A command to create an internal user"
input createInternalInput {
	addresses: [addressInput]
	chineseFirstName: String
	chineseLastName: String
	contacts: [addContactInput]
	description: String
	email: String
	englishFirstName: String
	englishLastName: String
	facts: [addFactInput]
	fields: String
	gender: String
	identities: [addIdentityInput]
	internalCode: String
	internalCodeGenerationStrategy: internalCodeGenerationStrategy
	internalCodeLength: Int
	isActive: Boolean = true
	linkedTo: String
	nameFormat: String
	photoPath: String
	source: String
	status: String
	tags: [String]
	telephoneNumber: String
	title: String
}

"Create jacket input"
input createJacketInput {
	clauses: [addClauseToJacketInput]
	status: String
	title: String
}

input createKycApplicantInput {
	kycProviderEnum: kycProviderEnum!
}

"A command to create a link between entities"
input createLinkInput {
	link: String!
	sourceId: String!
	targetId: String!
	value: scalarValueInput
	values: [relationshipValueInput]
}

"Input to create a login"
input createLoginInput {
	appIdsToBeGrantedAccessTo: [String!]
	"Used only to know which emails to be sent for now."
	clientId: String
	email: String
	entityId: String
	ignorePasswordValidation: Boolean
	isEmailConfirmed: Boolean
	isPasswordValidationDobRequire: Boolean
	password: String
	username: String!
}

input createNotificationConfigInput {
	clientId: String!
	emailConfig: emailConfigInput
}

input createNotificationTemplateInput {
	description: String
	logicalId: String
	name: String
}

"Create notification trigger input"
input createNotificationTriggerInput {
	cronExpression: String!
	notification: sendNotificationInput
}

"A command to create an object"
input createObjectInput {
	addresses: [addressInput]
	contacts: [addContactInput]
	email: String
	facts: [addFactInput]
	fields: String
	identities: [addIdentityInput]
	internalCode: String
	internalCodeGenerationStrategy: internalCodeGenerationStrategy
	internalCodeLength: Int
	linkedTo: String
	nameFormat: String
	photoPath: String
	source: String
	status: String
	tags: [String]
	telephoneNumber: String
	typeId: String
}

"A command to create an internal user"
input createOrganizationInput {
	fields: String
	isActive: Boolean = true
	nameFormat: String
	photoPath: String
	source: String
	status: String
	tags: [String]
	type: String
}

"Input to request an otpLogin, which sends an One Time Password by sms. A smsTemplateId is needed"
input createOtpLoginInput {
	smsTemplateId: String
	token: String!
}

"Create panel provider tier input"
input createPanelProviderTierInput {
	description: String
	fields: String
	name: String
	panelId: String
	serviceItemAgreedFeeIds: [String]
}

input createPdfDrawingTemplateInput {
	description: String
	fileKey: String
	graphQlQuery: String
	logicalId: String
	name: String
	password: String
	passwordLiquid: String
}

"Input to create permission groups"
input createPermissionGroupInput {
	description: String!
	name: String!
	productTypes: [String]
}

input createPermissionSchemaInput {
	actionType: permissionSchemaActionType
	description: String
	name: String
	objectType: String!
	schema: String!
	stateCondition: fieldsWhereInput
	updateCondition: fieldsWhereInput
}

"Input to request a pre otp login token"
input createPreOtpLoginInput {
	clientId: String!
	email: String!
	phoneNumber: String!
}

"Input to create a new product"
input createProductInput {
	benefitInputs: [benefitInput]
	changeEffectiveDate: Date
	claimSettings: claimSettingsInput
	exclusionSettings: exclusionSettingsInput
	facts: [addFactInput]
	fields: String
	insurerId: String
	issuerProductId: String
	launchPeriodEndDate: Date
	launchPeriodStartDate: Date
	lifecycleStage: String
	loadingSettings: loadingSettingsInput
	productId: productIdInput!
	productTreeId: String
	rejectionSettings: rejectionSettingsInput
	representation: String
	status: String
	tags: [tagInput]
	underwriting: underwritingInput
	underwritingRules: String
}

"The product type to be added"
input createProductTypeInput {
	logoUrl: String
	typeId: String!
}

input createReviewInput {
	comment: String
	relatedId: String
	scores: [scoreInput]
	type: String
}

input createScriptInput {
	externalTableDataUrl: String
	externalTableDataUrls: [String!]
	inputSchema: String!
	name: String!
	outputSchema: String!
	referenceSourceCodeUrl: String
	sourceCode: String!
	type: scriptTypeEnum
}

input createServiceItemAgreedFeeInput {
	currency: String!
	rate: Decimal!
	serviceItemId: String!
}

input createServiceItemInput {
	description: String
	name: String!
}

input createSmsTemplateInput {
	bodyLiquid: String
	description: String
	graphQlQuery: String
	logicalId: String
	name: String
}

input createSubscriptionInput {
	endDate: DateTime
	interval: intervalType!
	intervalCount: Int
	offers: [addOfferInput]!
	startDate: DateTime
}

"an input for creating a transaction"
input createTransactionInput {
	amount: Decimal!
	claimId: String
	currencyCode: currencyCodeEnumeration
	dateTime: DateTime
	debitNoteNumber: String
	description: String
	dueDateTime: DateTimeOffset
	endorsementId: String
	fields: String
	method: paymentMethod
	policyId: String
	postDateTime: DateTimeOffset
	proposalId: String
	settledToTransactionId: String
	status: transactionStatusEnumeration
	transactionNumber: String
	type: String
}

input createUiSchemaInput {
	name: String!
	schema: String!
	standard: uiSchemaStandardInputGraphType
}

input createWkhtmltopdfTemplateInput {
	description: String
	footerSettings: headerFooterInput
	graphQlQuery: String
	headerSettings: headerFooterInput
	html: String
	logicalId: String
	marginSettings: marginSettingsInput
	name: String
	orientation: orientationEnumeration
	password: String
	passwordLiquid: String
}

input dataSchemaStandardInput {
	type: dataSchemaStandardTypeEnum
	version: String
}

input dataSchemaWhereInput {
	and: [dataSchemaWhereInput!]
	id: String
	id_in: [String!]
	or: [dataSchemaWhereInput!]
	tags_contains: [String!]
	type: String
}

input deleteBenefitDefinitionInput {
	benefitDefinitionId: String
}

input deleteBenefitDefinitionTypeInput {
	benefitDefinitionTypeId: String
}

input deleteDataSchemaInput {
	dataSchemaId: String!
}

input deleteServiceItemAgreedFeeInput {
	serviceItemAgreedFeeId: String!
}

input deleteServiceItemInput {
	serviceItemId: String!
}

input deleteUiSchemaInput {
	uiSchemaId: String!
}

"Diagnosis Batch Input"
input diagnosisBatchInput {
	create: [diagnosisInput]
	delete: [diagnosisRemoveInput]
	update: [diagnosisUpdateInput]
}

"Diagnosis Filter Input"
input diagnosisFilterInput {
	and: [diagnosisFilterInput]
	or: [diagnosisFilterInput]
	where: diagnosisFilterWhereInput
}

"Diagnosis Filter Where Input"
input diagnosisFilterWhereInput {
	chapter: String
	chapter_contains: String
	chapter_in: [String]
	classKind: String
	classKind_contains: String
	classKind_in: [String]
	code: String
	code_contains: String
	code_in: [String]
	depthInKind: Int
	depthInKind_in: [Int]
	fieldsWhere: fieldsWhereInput
	id: String
	id_in: [String]
	title: String
	title_contains: String
	title_in: [String]
}

"diagnosis input"
input diagnosisInput {
	chapter: String
	classKind: String
	code: String
	depthInKind: Int
	fields: String
	title: String
}

"diagnosis remove input"
input diagnosisRemoveInput {
	id: String
}

"The product diagnosis settings input"
input diagnosisSettingsInput {
	codes: [String]
}

"diagnosis update input"
input diagnosisUpdateInput {
	chapter: String
	classKind: String
	code: String
	depthInKind: Int
	fields: String
	id: String
	title: String
}

"Disability Batch Input"
input disabilityBatchInput {
	create: [disabilityInput]
	delete: [disabilityRemoveInput]
	update: [disabilityUpdateInput]
}

"Disability Filter Input"
input disabilityFilterInput {
	and: [disabilityFilterInput]
	or: [disabilityFilterInput]
	where: disabilityFilterWhereInput
}

"Disability Filter Where Input"
input disabilityFilterWhereInput {
	id: String
	id_in: [String]
	name: String
	name_contains: String
	name_in: [String]
}

"disability input"
input disabilityInput {
	name: String
}

"disability remove input"
input disabilityRemoveInput {
	id: String
}

"disability update input"
input disabilityUpdateInput {
	id: String
	name: String
}

input displayedBenefitCategoryInput {
	id: String!
	typeIds: [String!]!
}

input displayedBenefitsInput {
	benefitCategories: [displayedBenefitCategoryInput]!
	productType: String!
}

input displayedInsurersInput {
	insurerIds: [String!]!
	productType: String!
}

input displayedProductsInput {
	productIds: [productIdInput]!
	type: String!
}

input domainEncryptionInput {
	algorithmId: String!
	jsonPath: String!
	keyString: String
	parameters: [keyValueInput]
}

input emailConfigInput {
	bccs: [String]
	ccs: [String]
	emailName: String!
	emailSender: String!
}

input emailMessageAttachmentInput {
	key: String!
	name: String!
}

"An email message"
input emailMessageInput {
	attachments: [emailMessageAttachmentInput]
	bccs: [String]
	ccs: [String]
	from: String
	fromName: String
	htmlContent: String
	pdfAttachments: [pdfAttachmentInput]
	replyTo: String
	replyToName: String
	subject: String
	templateRendering: templateRenderingInput
	to: String
}

input encryptionConfig {
	domainEncryptions: [domainEncryptionInput]
	eventEncryptions: [eventEncryptionInput]
	parameters: [keyValueInput]
	type: String!
}

"An endorsemet search filter"
input endorsementWhereInput {
	id: String
	id_in: [String]
	lastModifiedAt_gt: Date
	lastModifiedAt_lt: Date
	source_exists: Boolean
	status: String
	status_in: [String]
	type: String
	type_in: [String]
}

input engineInput {
	id: String
	name: String
	runTime: String
	version: String
}

"An entity search filter"
input entityWhereInput {
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	email: String
	email_contains: String
	email_in: [String]
	facts_contains: factWhereInput
	fields: fieldsWhereInput
	id: String
	id_contains: String
	id_in: [String]
	identities_contains: identityWhereInput
	internalCode: String
	internalCode_contains: String
	internalCode_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	name: String
	name_contains: String
	name_in: [String]
	relationshipListType: String
	relationshipListType_in: [String]
	relationshipList_contains: relationshipListWhereInput
	source: String
	source_contains: String
	source_in: [String]
	status: String
	status_in: [String]
	tags_contains: String
	tags_exists: Boolean
	telephoneNumber: String
	telephoneNumber_contains: String
	telephoneNumber_in: [String]
}

input evaluateScriptInput {
	dataInput: String
	productId: productIdInput
	representation: String
	scriptId: String
}

input eventEncryptionInput {
	algorithmId: String!
	eventType: String!
	jsonPath: String!
	keyString: String
	parameters: [keyValueInput]
}

input excelRuleInput {
	resultCell: resultCellInput
}

input exchangeRateConversionOptionsInput {
	currencyCodes: [currencyCodeEnumeration]!
}

"The exclusion input"
input exclusionInput {
	benefitOptionKey: String
	benefitParentTypeId: String
	benefitTypeId: String
	code: String
	offerId: String
	remark: String
}

"The product exclusion settings input"
input exclusionSettingsInput {
	codes: [String]
}

input factBatchInput {
	addFactInputs: [addFactInput]
	updateFactInputs: [updateFactInput]
}

"Fact filter"
input factWhereInput {
	id: String
	type: String
	valueJsonString: String
}

"A FieldsDiff search filter"
input fieldsDiffWhereInput {
	from: Date
	to: Date
}

"fieldsWhere input"
input fieldsWhereInput {
	and: [fieldsWhereInput]
	condition: fieldsWhereCondition
	or: [fieldsWhereInput]
	path: String
	value: scalarValueInput
}

input fileSystemConfigInput {
	accessKeyId: String!
	accessKeySecret: String!
	bucketName: String!
	endpoint: String!
	providerId: String!
}

input fileSystemConfigWhere {
	and: [fileSystemConfigWhere]
	bucketName: String
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	id: String
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [fileSystemConfigWhere]
}

"a file filter"
input fileWhere {
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	keyPattern: String
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
}

input filesystem_MetadataMigrationCommandInput {
	bucketName: String
	prefix: String
}

input fontInput {
	emSize: Int!
	familyName: String!
	fontStyle: fontStyleInput
}

"Input to be send a forgot password link by email"
input forgotPasswordInput {
	clientId: String!
	dateOfBirth: DateTimeOffset
	email: String
	sendNotificationCommand: sendNotificationInput
	username: String
}

input functionInputInput {
	liquid: String
	name: String
	type: String
	var: String
}

input functionOutputInput {
	name: String
	var: String
}

input generateKycAuthTokenInput {
	kycProviderEnum: kycProviderEnum!
}

"A guarantee of payment search filter"
input gopWhereInput {
	and: [gopWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	fields: fieldsWhereInput
	id: String
	id_in: [String]
	issuerNumber: String
	issuerNumber_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	memberId: String
	memberId_in: [String]
	or: [gopWhereInput]
	providerId: String
	providerId_in: [String]
	status: String
	status_in: [String]
}

input headerFooterInput {
	center: String
	fontName: String
	fontSize: Int
	htmUrl: String
	html: String
	left: String
	line: Boolean
	right: String
	spacing: Float
}

"An identity search filter"
input identityWhereInput {
	id: String
	id_in: [String]
	type: String
	type_contains: String
	type_in: [String]
	value: String
	value_contains: String
	value_in: [String]
}

"A batch command to batch disabilities for an individual"
input individualDisabilityBatchInput {
	disabilityIdsToAdd: [String]
	disabilityIdsToRemove: [String]
}

"An individual search filter"
input individualWhereInput {
	acceptsMarketing: Boolean
	and: [individualWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	email: String
	email_contains: String
	email_in: [String]
	facts_contains: factWhereInput
	fields: fieldsWhereInput
	hasActivePolicy: Boolean
	id: String
	id_contains: String
	id_in: [String]
	identities_contains: identityWhereInput
	integrationExternalEntityId_in: [String]
	integrationSystemId: String
	internalCode: String
	internalCode_contains: String
	internalCode_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	name: String
	name_contains: String
	name_in: [String]
	or: [individualWhereInput]
	relationshipListType: String
	relationshipListType_in: [String]
	relationshipList_contains: relationshipListWhereInput
	source: String
	source_contains: String
	source_in: [String]
	status: String
	status_in: [String]
	tags_contains: String
	tags_exists: Boolean
	telephoneNumber: String
	telephoneNumber_contains: String
	telephoneNumber_in: [String]
	type: individualTypeEnumeration
	type_in: [individualTypeEnumeration]
}

"Input to initialize a policy"
input initializePolicyInput {
	description: String
	endDate: Date
	facts: [addFactInput]
	fields: String
	fieldsSchemaId: String
	generatedFrom: policyGeneratedFromInput
	holderId: String
	insuredIds: [String]
	isRenewal: Boolean
	issueDate: Date
	issuerNumber: String
	"Issuer number of policy originally renewed from, supposed to keep the same value each renewal"
	originalIssuerNumber: String
	otherHolderIds: [String]
	premium: premiumInput
	previousPolicyIds: [String]
	productId: productIdInput
	referralCode: String
	renewalNumber: String
	"Supposed to be incremented each time when we renewing policy"
	renewalVersion: Int
	source: String
	startDate: Date
	status: String
	values: [keyValueInput]
}

input initializeTenantEncryptionsInput {
	encryptionConfigs: [encryptionConfig]
}

input initializeTenantFileSystemInput {
	config: fileSystemConfigInput!
}

input initializeTenantNotificationsInput {
	configs: [createNotificationConfigInput]
}

input initializeTenantPoliciesInput {
	policyNumberConfigs: [addPolicyNumberConfigInput]!
}

input initializeTenantProductConfigInput {
	productConfigs: [productConfigInput]
}

input initializeTenantTransactionsInput {
	paymentConfig: paymentConfigInput!
}

input initializeTransactionInput {
	amount: Decimal!
	currencyCode: currencyCodeEnumeration!
	description: String
	method: paymentMethod
	policyId: String
	proposalId: String
	providerConfigId: String
	redirectToUrl: String
	transactionNumber: String
}

"An insurer filter"
input insurerWhere {
	id: String
	id_contains: String
	id_in: [String]
}

"An internal message"
input internalMessageInput {
	dataJsonString: String
	templateRendering: templateRenderingInput
}

input internalReviewInput {
	comment: String!
	status: String!
}

"An internal review filter"
input internalReviewWhere {
	status: String
	status_in: [String]
}

"An internal search filter"
input internalWhereInput {
	and: [internalWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	email: String
	email_contains: String
	email_in: [String]
	facts_contains: factWhereInput
	fields: fieldsWhereInput
	id: String
	id_contains: String
	id_in: [String]
	identities_contains: identityWhereInput
	internalCode: String
	internalCode_contains: String
	internalCode_in: [String]
	isActive: Boolean
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	name: String
	name_contains: String
	name_in: [String]
	or: [internalWhereInput]
	relationshipListType: String
	relationshipListType_in: [String]
	relationshipList_contains: relationshipListWhereInput
	source: String
	source_contains: String
	source_in: [String]
	status: String
	status_in: [String]
	tags_contains: String
	tags_exists: Boolean
	telephoneNumber: String
	telephoneNumber_contains: String
	telephoneNumber_in: [String]
	title: String
	title_contains: String
	title_in: [String]
}

"Invite an entity by creating a user and associate it to the entity from the specified entityId"
input inviteEntityInput {
	appIdsToBeGrantedAccessTo: [String!]
	email: String!
	entityId: String!
	isPasswordValidationDobRequire: Boolean
	"If null, will let this user chose his password"
	password: String
	permissionGroupIds: [String!]
	redirectQueryString: String
	sendNotification: sendNotificationInput
	telephoneNumber: String
	useDefaultPermissions: Boolean
	"If null, is equal to the email."
	username: String
}

"Invite an individual which creates a login and an individual and link them with limited permissions"
input inviteIndividualInput {
	chineseFirstName: String
	chineseLastName: String
	email: String!
	englishFirstName: String
	englishLastName: String
	entityId: String!
	"If null, will generate an individual code of 'internalCodeLength'. Default length is 6."
	internalCode: String
	"If 'internalCode' is null, will generate an internal code of 'internalCodeLength'. Default length is 6."
	internalCodeLength: Int
	nameFormat: String
	"If null, will let this user chose his password"
	password: String
	salutation: String
	telephoneNumber: String
	"If null, is equal to the email."
	username: String
}

"Invite an internal which creates a login and an internal and link them with limited permissions"
input inviteInternalInput {
	chineseFirstName: String
	chineseLastName: String
	email: String!
	englishFirstName: String
	englishLastName: String
	"if internal already exists."
	entityId: String
	"If null, will generate an internal code of 'internalCodeLength'. Default length is 6."
	internalCode: String
	"If 'internalCode' is null, will generate an internal code of 'internalCodeLength'. Default length is 6."
	internalCodeLength: Int
	invitedBy: String
	nameFormat: String
	"If null, will let this user chose his password"
	password: String
	telephoneNumber: String
	title: String
	"If null, is equal to the email."
	username: String
}

input jacketInstanceBatchInput {
	addJacketInstanceInputs: [addJacketInstanceInput]
	updateJacketInstanceInputs: [updateJacketInstanceInput]
}

"A jacket search filter"
input jacketWhereInput {
	and: [jacketWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [jacketWhereInput]
	status: String
	status_contains: String
	status_in: [String]
	title: String
	title_contains: String
}

input jobDetailInput {
	graphQlOperationType: String
	graphQlQuery: String
	graphQlVariables: String
	jobId: String!
	type: String!
}

input jobScheduleInput {
	cronExpression: String!
	description: String
	jobDetail: jobDetailInput
	name: String!
}

input jobScheduleWhereInput {
	and: jobScheduleWhereInput
	createdAt_gt: DateTime
	createdAt_lt: DateTime
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	id: String
	isActive: Boolean
	lastCheckedAt_gt: DateTime
	lastCheckedAt_lt: DateTime
	lastModifiedAt_gt: DateTime
	lastModifiedAt_lt: DateTime
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	name: String
	or: jobScheduleWhereInput
}

input keyValueInput {
	key: String!
	value: scalarValueInput
}

"The input for lesson item answers"
input lessonItemAnswerInput {
	answer: [String]
	itemId: String!
}

"The loading input"
input loadingInput {
	calculationJsonLogic: String
	code: String
	flat: Decimal
	offerId: String
	order: Int
	ratio: Decimal
}

"The product loading settings input"
input loadingSettingsInput {
	codes: [String]
	maxLoadingMultiplier: Decimal
}

"A login search filter"
input loginWhere {
	and: [loginWhere]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	email_in: [String]
	entity: entityWhereInput
	entityIds: [String]
	entityTypes: [String]
	excludePermissions: Boolean
	ids: [String]
	isEmailConfirmed: Boolean
	isTelephoneNumberConfirmed: Boolean
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [loginWhere]
	permissionGroupIds: [String]
	usernames: [String]
}

input logoUrlsInput {
	"flexible width color"
	typeA: String
	"flexible width grey"
	typeB: String
	"static width color"
	typeC: String
	"static width grey"
	typeD: String
	"static width left color"
	typeE: String
}

input marginSettingsInput {
	bottom: Float
	left: Float
	right: Float
	top: Float
}

input migrateInsurersInput {
	insurerInputs: [createInsurerInput]
}

input migratePricingsInput {
	priceLogicInputs: [priceLogicInput]
}

input migrateProductsInput {
	productInputs: [createProductInput]
}

input notificationConfigWhere {
	clientId: String
}

input notificationSubscriptionWhereInput {
	and: [notificationSubscriptionWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	entitiesIds_contains: String
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [notificationSubscriptionWhereInput]
	tags_some: tagWhere
	topic: String
	topic_in: [String]
}

input notificationTriggerWhereInput {
	and: [notificationTriggerWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [notificationTriggerWhereInput]
	sendNotificationCommand: sendNotificationCommandWhereInput
}

input notificationWhere {
	and: [notificationWhere]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	fromEntityId: String
	fromEntityId_in: [String]
	fromEntityId_not: String
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	offerId: String
	offerId_in: [String]
	or: [notificationWhere]
	policyId: String
	policyId_in: [String]
	status: String
	status_in: [String]
	status_not: String
	toEntityId: String
	toEntityId_in: [String]
	toTopic: String
	toTopicId: String
	toTopicId_in: [String]
	toTopic_in: [String]
	type: String
	type_in: [String]
}

input notifications_EmailMessageWhereInput {
	from: String
	templateRendering: notifications_TemplateRenderingWhereInput
	to: String
}

input notifications_GroupByInput {
	fieldName: String
}

input notifications_NotificationWhereInput {
	and: [notifications_NotificationWhereInput]
	createdAt_gt: DateTime
	createdAt_lt: DateTime
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	emailMessage: notifications_EmailMessageWhereInput
	emailMessageTo: String
	fromEntityId: String
	fromEntityId_in: [String]
	fromEntityId_not: String
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTime
	lastModifiedAt_lt: DateTime
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	offerId: String
	offerId_in: [String]
	or: [notifications_NotificationWhereInput]
	policyId: String
	policyId_in: [String]
	smsMessageTo: String
	status: String
	status_in: [String]
	status_not: String
	toEntityId: String
	toEntityId_in: [String]
	toTopic: String
	toTopicId: String
	toTopicId_in: [String]
	toTopic_in: [String]
	type: String
	type_in: [String]
}

input notifications_OrderByInput {
	fieldName: String
	type: notifications_OrderByType!
}

input notifications_ResendNotificationCommandInput {
	groupBy: notifications_GroupByInput
	orderBy: notifications_OrderByInput
	sendById: String
	where: notifications_NotificationWhereInput
}

input notifications_TemplateRenderingWhereInput {
	templateId: String
	templateId_in: [String]
}

"An object search filter"
input objectWhereInput {
	and: [objectWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	email: String
	email_contains: String
	email_in: [String]
	facts_contains: factWhereInput
	fields: fieldsWhereInput
	id: String
	id_contains: String
	id_in: [String]
	identities_contains: identityWhereInput
	internalCode: String
	internalCode_contains: String
	internalCode_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	name: String
	name_contains: String
	name_in: [String]
	or: [objectWhereInput]
	relationshipListType: String
	relationshipListType_in: [String]
	relationshipList_contains: relationshipListWhereInput
	source: String
	source_contains: String
	source_in: [String]
	status: String
	status_in: [String]
	tags_contains: String
	tags_exists: Boolean
	telephoneNumber: String
	telephoneNumber_contains: String
	telephoneNumber_in: [String]
}

input offerIdInput {
	caseId: String!
	offerId: String!
	proposalId: String!
}

input offerWhere {
	id: String
	id_in: [String]
	offerNumber: String
	offerNumber_in: [String]
	status: String
}

"The product operation settings input"
input operationSettingsInput {
	codes: [String]
}

"An organization search filter"
input organizationWhereInput {
	and: [organizationWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	email: String
	email_contains: String
	email_in: [String]
	facts_contains: factWhereInput
	fields: fieldsWhereInput
	id: String
	id_contains: String
	id_in: [String]
	identities_contains: identityWhereInput
	internalCode: String
	internalCode_contains: String
	internalCode_in: [String]
	isActive: Boolean
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	name: String
	name_contains: String
	name_in: [String]
	or: [organizationWhereInput]
	relationshipListType: String
	relationshipListType_in: [String]
	relationshipList_contains: relationshipListWhereInput
	source: String
	source_contains: String
	source_in: [String]
	status: String
	status_in: [String]
	tags_contains: String
	tags_exists: Boolean
	telephoneNumber: String
	telephoneNumber_contains: String
	telephoneNumber_in: [String]
	type: String
}

input otherIdInput {
	id: String!
	key: String!
}

input overrideEmailAttachmentReferenceInput {
	fileName: String!
	filePath: String!
}

input overrideEmailAttachmentTemplateInput {
	fileName: String!
	templateId: String!
}

input pageObjectInput {
	footerSettings: headerFooterInput
	headerSettings: headerFooterInput
	html: String
}

"A panel provider tier search filter"
input panelProviderTierWhereInput {
	and: [panelProviderTierWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [panelProviderTierWhereInput]
	panelId: String
	panelId_in: [String]
	serviceItemAgreedFeeId: fieldsWhereInput
	serviceItemAgreedFeeId_in: [String]
}

input paymentConfigInput {
	dokuMerchantId: Int
	dokuSharedKey: String
	isLiveMode: Boolean
	jetcoMerchantId: Int
	jetcoMicroserviceBaseUrl: String
	providerId: String!
	stripeApiLiveKey: String
	stripeApiTestKey: String
	stripeDestinationUserId: String
	stripeDestinatonFeeFlat: Decimal
	stripeDestinatonFeeRatio: Decimal
}

"the payment information to update"
input paymentInfosToUpdate {
	amount: Decimal
	comment: String
	currencyCode: currencyCodeEnumeration
	endDate: DateTime
	frequency: paymentFrequency
	method: paymentMethod
	name: String
	payorId: String
	startDate: DateTime
}

input pdfAttachmentInput {
	bytes: [Byte]
	fileName: String!
	footerSettings: headerFooterInput
	headerSettings: headerFooterInput
	htmlContent: String
	marginSettings: marginSettingsInput
	password: String
}

"A permission group search filter"
input permissionGroupWhereInput {
	id: String
	id_in: [String]
	name: String
	name_in: [String]
}

"A permission schemas filter"
input permissionSchemaWhereInput {
	actionType: permissionSchemaActionType
	and: [permissionSchemaWhereInput]
	id: String
	id_in: [String]
	name: String
	objectType: String
	or: [permissionSchemaWhereInput]
	schema: fieldsWhereInput
}

input planInput {
	productId: productIdInput
	tags: [tagInput]
}

"A plan filter"
input planWhereInput {
	and: [planWhereInput]
	id_in: [productIdInput]
	name_contains: String
	or: [planWhereInput]
	tags_some: tagWhere
}

input pointInput {
	x: Float!
	y: Float!
}

input policies_AddPolicyMemberInput {
	fields: Any
	memberId: String
	planId: String!
	policyId: String!
}

input policies_AddPolicyUnderwritingRemarkCommandInput {
	endorsementId: String
	fields: String
	id: String
	policyId: String
	remark: String
	remarkId: String
	remarkType: String
	underwritingId: String
}

input policies_BatchPolicyUnderwritingCommandInput {
	create: [policies_CreatePolicyUnderwritingCommandInput]
	delete: [policies_DeletePolicyUnderwritingCommandInput]
	endorsementId: String
	id: String
	policyId: String
	update: [policies_UpdatePolicyUnderwritingCommandInput]
}

input policies_BooleanOperationFilterInput {
	eq: Boolean
	neq: Boolean
}

input policies_CategoryOperationFilterInput {
	eq: policies_Category
	in: [policies_Category!]
	neq: policies_Category
	nin: [policies_Category!]
}

input policies_CreateAttachedRuleCommandOfpoliciesAttachedCommandPermissionInput {
	create: policies_policiesAttachedCommandPermissionInput
	id: String
}

input policies_CreateAttachedRuleCommandOfpoliciesAttachedExternalApiCallInput {
	create: policies_policiesAttachedExternalApiCallInput
	id: String
}

input policies_CreateAttachedRuleCommandOfpoliciesAttachedFilterInput {
	create: policies_policiesAttachedFilterInput
	id: String
}

input policies_CreateAttachedRuleCommandOfpoliciesAttachedObjectValidationInput {
	create: policies_policiesAttachedObjectValidationInput
	id: String
}

input policies_CreateAttachedRuleCommandOfpoliciesAttachedPostHandleValidationInput {
	create: policies_policiesAttachedPostHandleValidationInput
	id: String
}

input policies_CreatePolicyEventCommandInput {
	clientId: String
	contractHolderCompany: policies_UpdateCompanyCommandInput
	contractHolderIndividual: policies_UpdateIndividualCommandInput
	description: String
	endDate: DateTime
	eventType: policies_PolicyEventType!
	extraFields: String
	fields: String
	fieldsPatch: String
	fieldsSchemaId: String
	generatedFrom: policies_GeneratedFromInput
	holderId: String
	id: String
	importedById: String
	insuredIds: [String]
	isRenewal: Boolean! = false
	issueDate: DateTime
	issuerNumber: String
	lapseReason: String
	originalIssuerNumber: String
	otherHolderIds: [String]
	previousPolicyIds: [String]
	productId: policies_ProductIdInput
	productIdToUpdate: policies_ProductIdToUpdateInput
	referralCode: String
	renewalNumber: String
	renewalVersion: Int
	source: String
	startDate: DateTime
	status: String
	timestamp: DateTime!
	values: [policies_KeyScalarValueInput]
}

input policies_CreatePolicyUnderwritingCommandInput {
	endorsementId: String
	fields: String
	id: String
	policyId: String
	policyMemberId: String
	remarks: [policies_AddPolicyUnderwritingRemarkCommandInput]
	status: String
}

input policies_CustomReasonAddInput {
	category: policies_Category!
	name: String!
}

input policies_CustomReasonArchiveInput {
	id: String!
	value: Boolean!
}

input policies_CustomReasonDeleteInput {
	id: String!
}

input policies_CustomReasonUpdateInput {
	id: String!
	name: String!
}

input policies_DeleteAttachedRuleCommandOfpoliciesAttachedCommandPermissionInput {
	id: String
}

input policies_DeleteAttachedRuleCommandOfpoliciesAttachedExternalApiCallInput {
	id: String
}

input policies_DeleteAttachedRuleCommandOfpoliciesAttachedFilterInput {
	id: String
}

input policies_DeleteAttachedRuleCommandOfpoliciesAttachedObjectValidationInput {
	id: String
}

input policies_DeleteAttachedRuleCommandOfpoliciesAttachedPostHandleValidationInput {
	id: String
}

input policies_DeletePolicyMemberActivityCommandInput {
	id: String
	policyId: String
}

input policies_DeletePolicyMemberInput {
	policyId: String!
	policyMemberId: String!
}

input policies_DeletePolicyMembersInput {
	policyId: String!
	policyMemberIds: [String!]!
}

input policies_DeletePolicyUnderwritingCommandInput {
	endorsementId: String
	id: String
	policyId: String
}

input policies_DeletePolicyUnderwritingRemarkCommandInput {
	endorsementId: String
	id: String
	policyId: String
	remarkId: String
	underwritingId: String
}

input policies_ExternalApiCallInput {
	afterCall: [String!]
	beforeCall: [String!]
	contentType: String
	contextSlug: String
	expectedContentExpression: String
	expectedResponseExpression: String
	headers: [policies_KeyValuePairOfStringAndStringInput!]
	itemValidationExpression: String
	method: String!
	stringContent: String
	timeout: String
	url: String!
}

input policies_FieldsWhereInput {
	and: [policies_FieldsWhereInput]
	condition: policies_FieldsWhereCondition!
	or: [policies_FieldsWhereInput]
	path: String
	value: policies_ScalarValueInput
}

input policies_FormatArgumentInput {
	addOpOnResult: Int
	currentIncrement: Int
	dictionary: [policies_KeyValuePairOfStringAndStringInput!]
	expectedType: String
	format: String
	graphQlQuery: String
	jsonPath: String
	order: Int!
	splitIndex: Int
	splitOn: String
	type: String
}

input policies_GeneratedFromInput {
	caseId: String
	offerId: String
	proposalId: String
}

input policies_GenericPolicies_AttachedRuleFilterInput {
	and: [policies_GenericPolicies_AttachedRuleFilterInput]
	or: [policies_GenericPolicies_AttachedRuleFilterInput]
	where: policies_policies_AttachedRuleFilterInput
}

input policies_GenericPolicies_AttachedRuleQueryInput {
	asOf: DateTime
	first: Int
	groupBy: policies_GroupByInput
	includeEvents: Boolean
	orderBy: policies_OrderByInput
	orderBy2: [policies_OrderByInput!]
	skip: Int
	where: policies_GenericPolicies_AttachedRuleFilterInput
}

input policies_GenericPolicyMembersFilterInput {
	and: [policies_GenericPolicyMembersFilterInput]
	or: [policies_GenericPolicyMembersFilterInput]
	where: policies_PolicyMembersFilterInput
}

input policies_GroupByInput {
	fieldName: String
}

input policies_ImportPoliciesCommandInput {
	importPolicyCommands: [policies_ImportPolicyCommandInput]
}

input policies_ImportPolicyCommandInput {
	createPolicyEventCommands: [policies_CreatePolicyEventCommandInput]
	policyId: String
}

input policies_InsuredPersonDetailReportFilterInput {
	policyId: String!
}

input policies_IssueCertificateInput {
	insuredKey: String!
	policyKey: String!
}

input policies_KeyScalarValueInput {
	key: String
	value: policies_ScalarValueInput
}

input policies_KeyValuePairOfStringAndStringInput {
	key: String!
	value: String!
}

input policies_MemberInput {
	email: String
	hkid: String
	passportNo: String
	sequenceNo: String
	staffNo: String
}

input policies_MemberValidationInput {
	newMembers: [policies_MemberInput!]!
}

input policies_MemberValidationRuleInput {
	field: policies_MemberField!
	scope: policies_MemberValidationScope!
	type: policies_MemberValidationType!
}

input policies_MemberValidationWhereInput {
	companyId: String
	policyId: String
	rules: [policies_MemberValidationRuleInput!]!
	validateExistingMembers: Boolean
}

input policies_OrderByInput {
	fieldName: String
	type: policies_OrderByType!
}

input policies_PolicyMemberStatisticFilterInput {
	hasIndividualId: Boolean
	hasInternalCode: Boolean
	hasMovementsWithoutCreatedAtField: Boolean
	hasMovementsWithoutCreatedByIdField: Boolean
	hasStartDate: Boolean
	hasUniqueIndividualId: Boolean
	hasUniqueInternalCode: Boolean
	memberId: String
	policyId: String
}

input policies_PolicyMemberUploadFilterInput {
	and: [policies_PolicyMemberUploadFilterInput!]
	createdAt: Comparablepolicies_DateTimeOperationFilterInput
	id: policies_StringOperationFilterInput
	lastModifiedAt: Comparablepolicies_NullableOfDateTimeOperationFilterInput
	or: [policies_PolicyMemberUploadFilterInput!]
	path: policies_StringOperationFilterInput
	policyId: policies_StringOperationFilterInput
	status: policies_PolicyMemberUploadStatusOperationFilterInput
	validationErrors: Listpolicies_GenericIUserErrorFilterFilterInput
}

input policies_PolicyMemberUploadSortInput {
	createdAt: SortEnumType
	id: SortEnumType
	lastModifiedAt: SortEnumType
	path: SortEnumType
	policyId: SortEnumType
	status: SortEnumType
}

input policies_PolicyMemberUploadStatusOperationFilterInput {
	eq: policies_PolicyMemberUploadStatus
	in: [policies_PolicyMemberUploadStatus!]
	neq: policies_PolicyMemberUploadStatus
	nin: [policies_PolicyMemberUploadStatus!]
}

input policies_PolicyMembersFilterInput {
	createdAt_gt: DateTime
	createdAt_lt: DateTime
	createdById: String
	endorsementId: String
	endorsementId_in: [String]
	fields: policies_FieldsWhereInput
	havingEndDate: Boolean
	havingInternalCode: Boolean
	havingMovementType: Boolean
	havingStartDate: Boolean
	id: String
	id_in: [String]
	internalCode: String
	internalCode_contains: String
	internalCode_in: [String]
	isDependent: Boolean
	isPrinted: Boolean
	isRemoved: Boolean
	lastModifiedAt_gt: DateTime
	lastModifiedAt_lt: DateTime
	memberId: String
	memberId_in: [String]
	planId_contains: String
	planId_in: String
	underwritingResult: policies_PolicyMemberUnderwritingResult
	underwritingResult_in: [policies_PolicyMemberUnderwritingResult]
	validationResult: policies_PolicyMemberValidationResult
	validationResult_in: [policies_PolicyMemberValidationResult]
}

input policies_PolicyMembersWhereInput {
	approvedEndorsementsOnly: Boolean
	asOf: DateTime
	"Preview endorsement id. Actually, only one id can be passed."
	endorsementId_In: [String]
	"When false - allows to see terminated members."
	filterOutTerminatedMemberMovements: Boolean
	"When false - allows to see underwriting rejected/pending members."
	filterOutUnderwritingNotApproved: Boolean
	first: Int
	groupBy: policies_GroupByInput
	includeEvents: Boolean
	individualId: String
	isTerminated: Boolean
	optionalPolicyFiltering: Boolean
	orderBy: policies_OrderByInput
	orderBy2: [policies_OrderByInput!]
	policyId_In: [String]
	skip: Int
	timestamp_gt: DateTime
	where: policies_GenericPolicyMembersFilterInput
}

input policies_PolicyNumberValidateInput {
	code: String!
}

input policies_PolicyUnderwritingCalculationInput {
	ignoreIsTerminated: Boolean
	otherFields: String
	policyId: String!
}

input policies_PremiumToUpdateInput {
	amount: Decimal
	currencyCode: policies_CurrencyCode
	discountCodes: [String]
	grossAmount: Decimal
	isIsPricedAtStartDateChanged: Boolean!
	isPricedAtStartDate: Boolean!
}

input policies_ProductIdInput {
	plan: String
	type: String
	version: String
}

input policies_ProductIdToUpdateInput {
	plan: String
	type: String
	version: String
}

input policies_RangeInput {
	exclusiveMaximum: Boolean!
	exclusiveMinimum: Boolean!
	maximum: Float!
	minimum: Float!
}

input policies_ReasonAddInput {
	customReason: policies_CustomReasonAddInput
	systemReason: policies_SystemReasonAddInput
}

input policies_ReasonArchiveInput {
	customReason: policies_CustomReasonArchiveInput
	systemReason: policies_SystemReasonArchiveInput
}

input policies_ReasonDeleteInput {
	customReason: policies_CustomReasonDeleteInput
}

input policies_ReasonFilterInput {
	and: [policies_ReasonFilterInput!]
	archived: policies_BooleanOperationFilterInput
	category: policies_CategoryOperationFilterInput
	createdAt: Comparablepolicies_DateTimeOperationFilterInput
	id: policies_StringOperationFilterInput
	lastModifiedAt: Comparablepolicies_NullableOfDateTimeOperationFilterInput
	name: policies_StringOperationFilterInput
	or: [policies_ReasonFilterInput!]
	type: policies_StringOperationFilterInput
}

input policies_ReasonSortInput {
	archived: SortEnumType
	category: SortEnumType
	createdAt: SortEnumType
	id: SortEnumType
	lastModifiedAt: SortEnumType
	name: SortEnumType
	type: SortEnumType
}

input policies_ReasonUpdateInput {
	customReason: policies_CustomReasonUpdateInput
	systemReason: policies_SystemReasonUpdateInput
}

input policies_ReferenceGeneratorConfigInput {
	arguments: [policies_FormatArgumentInput]
	format: String
	type: String
}

input policies_RegisterPolicyMemberUploadInput {
	path: String!
	policyId: String!
}

input policies_ReplayEventsInput {
	all: Boolean!
	policyIds: [String]
}

input policies_ResendNotificationPolicyIssuedCommandInput {
	bccsTo: [String]
	policyId: String
}

input policies_ResendToIssuerCommandInput {
	issuerNumber_in: [String]
}

input policies_ScalarValueInput {
	arrayValue: [policies_ScalarValueInput]
	booleanValue: Boolean
	dateValue: DateTime
	numberValue: Decimal
	objectValue: [policies_KeyScalarValueInput]
	stringValue: String
}

input policies_SettableOfNullableJsonObjectInput {
	value: Any
}

input policies_SettableOfNullableOfStringInput {
	value: String
}

input policies_SettableOfStringInput {
	value: String!
}

input policies_StringOperationFilterInput {
	and: [policies_StringOperationFilterInput!]
	contains: String
	endsWith: String
	eq: String
	in: [String]
	ncontains: String
	nendsWith: String
	neq: String
	nin: [String]
	nstartsWith: String
	or: [policies_StringOperationFilterInput!]
	startsWith: String
}

input policies_SystemReasonAddInput {
	category: policies_Category!
	name: String!
}

input policies_SystemReasonArchiveInput {
	id: String!
	value: Boolean!
}

input policies_SystemReasonUpdateInput {
	id: String!
	name: String!
}

input policies_UpdateAttachedRuleCommandOfpoliciesAttachedCommandPermissionInput {
	id: String
	update: policies_policiesAttachedCommandPermissionInput
}

input policies_UpdateAttachedRuleCommandOfpoliciesAttachedExternalApiCallInput {
	id: String
	update: policies_policiesAttachedExternalApiCallInput
}

input policies_UpdateAttachedRuleCommandOfpoliciesAttachedFilterInput {
	id: String
	update: policies_policiesAttachedFilterInput
}

input policies_UpdateAttachedRuleCommandOfpoliciesAttachedObjectValidationInput {
	id: String
	update: policies_policiesAttachedObjectValidationInput
}

input policies_UpdateAttachedRuleCommandOfpoliciesAttachedPostHandleValidationInput {
	id: String
	update: policies_policiesAttachedPostHandleValidationInput
}

input policies_UpdateCompanyCommandInput {
	acceptsMarketing: Boolean
	commandId: String
	endorsementId: String
	entityId: String
	id: String
	internalCode: String
	modifiedById: String
	nameFormat: String
	natureOfBusiness: String
	photoPath: String
	registrationNumber: String
	source: String
	timestamp: DateTime!
}

input policies_UpdateIndividualCommandInput {
	acceptsMarketing: Boolean
	chineseFirstName: String
	chineseLastName: String
	commandId: String
	countryOfResidency: String
	dateOfBirth: DateTime
	employmentStatus: String
	endorsementId: String
	englishFirstName: String
	englishLastName: String
	entityId: String
	gender: String
	id: String
	incomeRange: policies_RangeInput
	internalCode: String
	maritalStatus: String
	modifiedById: String
	nameFormat: String
	occupation: String
	photoPath: String
	preferredCommunicationChannel: String
	preferredLanguage: String
	salutation: String
	source: String
	timestamp: DateTime!
}

input policies_UpdatePolicyMemberInput {
	fields: policies_SettableOfNullableJsonObjectInput
	memberId: policies_SettableOfNullableOfStringInput
	planId: policies_SettableOfStringInput
	policyId: String!
	policyMemberId: String!
}

input policies_UpdatePolicyUnderwritingCommandInput {
	endorsementId: String
	fields: String
	id: String
	policyId: String
	status: String
}

input policies_UpdatePolicyUnderwritingRemarkCommandInput {
	endorsementId: String
	fields: String
	id: String
	policyId: String
	remark: String
	remarkId: String
	remarkType: String
	underwritingId: String
}

input policies_UserErrorFilterInput {
	and: [policies_UserErrorFilterInput!]
	code: policies_StringOperationFilterInput
	message: policies_StringOperationFilterInput
	or: [policies_UserErrorFilterInput!]
}

input policies_policiesAttachedCommandPermissionInput {
	action: policies_AttachedRuleAllowAction!
	command: String!
	commandExpression: String
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input policies_policiesAttachedExternalApiCallInput {
	apiCalls: [policies_ExternalApiCallInput!]!
	description: String
	eventExpression: String
	forEach: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input policies_policiesAttachedFilterInput {
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input policies_policiesAttachedObjectValidationInput {
	action: policies_AttachedRuleAllowAction!
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input policies_policiesAttachedPostHandleValidationInput {
	action: policies_AttachedRuleAllowAction!
	description: String
	eventExpression: String
	group: Int!
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input policies_policies_AttachedRuleFilterInput {
	id: String
	userExpression: String
}

input policyClauseBatchInput {
	addClauseInputs: [addClauseToPolicyInput]
	removeClauseInputs: [removeClauseFromPolicyInput]
	updateClauseInputs: [updateClauseOnPolicyInput]
}

"Filter policies based on their endorsements"
input policyEndorsementWhereInput {
	status: String
	status_in: [String]
	type: String
	type_in: [String]
}

input policyGeneratedFromInput {
	caseId: String!
	offerId: String!
	proposalId: String!
}

input policyJacketInstanceBatchInput {
	addJacketInstanceInputs: [addPolicyJacketInstanceInput]
	updateJacketInstanceInputs: [updatePolicyJacketInstanceInput]
}

"Policy member create input"
input policyMemberInput {
	"DateTime when the member was created."
	createdAt: DateTime
	"MemberId the member is dependent of"
	dependentOf: String
	endDate: Date
	fields: String
	"Internal code of the member, assigned when the policy gets issued, supposed to be used for individual creation"
	internalCode: String
	memberId: String
	planId: String
	startDate: Date
	underwritingResult: PolicyMemberUnderwritingResult
	validationResult: PolicyMemberValidationResult
}

"Policy Members Batch Input"
input policyMembersBatchInput {
	create: [policyMemberInput]
	delete: [policyMemberInput]
	update: [policyMemberInput]
}

"Policy Members Filter Aggregate Input"
input policyMembersFilterAggregateInput {
	and: [policyMembersFilterAggregateInput]
	or: [policyMembersFilterAggregateInput]
	where: policyMembersFilterInput
}

"Policy Members Filter Input"
input policyMembersFilterInput {
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	endorsementId: String
	endorsementId_in: [String]
	fields: fieldsWhereInput
	havingEndDate: Boolean
	havingMovementType: Boolean
	havingStartDate: Boolean
	internalCode: String
	internalCode_contains: String
	internalCode_in: [String]
	isPrinted: Boolean
	isRemoved: Boolean
	isTerminated: Boolean
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	memberId_in: [String]
	planId_contains: String
	planId_in: [String]
	underwritingResult: PolicyMemberUnderwritingResult
	underwritingResult_in: [PolicyMemberUnderwritingResult]
	validationResult: PolicyMemberValidationResult
	validationResult_in: [PolicyMemberValidationResult]
}

input policyMembersWhereInput {
	asOf: DateTime
	endorsementId_In: [String]
	first: Int
	orderBy: sortInput
	policyId_In: [String]
	skip: Int
}

input policyUnderwritingFilter {
	fields: fieldsWhereInput
	id_in: [String]
	memberId_in: [String]
	status_in: [String]
}

input policyUnderwritingFilterInput {
	and: [policyUnderwritingFilter]
	or: [policyUnderwritingFilter]
	where: policyUnderwritingFilter
}

"A policy search filter"
input policyWhereInput {
	and: [policyWhereInput]
	contractHolder: individualWhereInput
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	description: String
	description_contains: String
	endDate: DateTimeOffset
	endDate_gt: DateTimeOffset
	endDate_lt: DateTimeOffset
	endorsement: policyEndorsementWhereInput
	facts_contains: factWhereInput
	fields: fieldsWhereInput
	fieldsDiff_contains: fieldsDiffWhereInput
	holder: entityWhereInput
	id: String
	id_in: [String]
	isHighestPriorityRenewalPerPolicy: Boolean
	isIssued: Boolean
	isRenewal: Boolean
	issueDate_gt: DateTimeOffset
	issueDate_lt: DateTimeOffset
	issuerNumber_contains: String
	issuerNumber_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [policyWhereInput]
	originalIssuerNumber_contains: String
	originalIssuerNumber_in: [String]
	previousPolicyIds_contains: String
	previousPolicyIds_contains_every: [String]
	previousPolicyIds_contains_some: [String]
	productId: productIdWhereInput
	referralCode: String
	renewalVersion: Int
	renewalVersion_gt: Int
	renewalVersion_lt: Int
	source: String
	source_in: [String]
	startDate: DateTimeOffset
	startDate_gt: DateTimeOffset
	startDate_lt: DateTimeOffset
	status_in: [String]
	status_not_in: [String]
	tags_some: tagWhere
}

input premiumInput {
	amount: Decimal
	currencyCode: currencyCodeEnumeration
	discountCodes: [String]
	grossAmount: Decimal
	isPricedAtStartDate: Boolean
}

input priceInput {
	amount: Decimal!
	currencyCode: currencyCodeEnumeration
}

"The loading input"
input priceLogicInput {
	amountLogic: String
	currencyCode: currencyCodeEnumeration
	options: [pricingOptionInput]
	productId: productIdInput
}

input pricingOptionInput {
	key: String!
	valueJsonString: String
}

"an input for processing a transaction"
input processTransactionInput {
	providerToken: String!
	remark: String
}

input productConfigInput {
	clientId: String!
	displayedBenefits: [displayedBenefitsInput]
	displayedInsurers: [displayedInsurersInput]
	displayedProductIds: [displayedProductsInput]
	displayedProducts: [displayedProductsInput]
	displayedTypes: [String]
}

input productConfigWhere {
	and: [productConfigWhere]
	clientId: String
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	id: String
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [productConfigWhere]
}

"A product id input"
input productIdInput {
	plan: String!
	type: String!
	version: String
}

"A product id input"
input productIdInputToUpdateInput {
	plan: String
	type: String
	version: String
}

"A product id filter"
input productIdWhereInput {
	plan: String
	plan_contains: String
	plan_in: [String]
	type: String
	type_in: [String]
	version: String
	version_contains: String
	version_in: [String]
	version_ncontains: String
}

"A reference to record of product tree resolution"
input productTreeRecordInput {
	recordId: String!
	type: String!
}

"A product type filter"
input productTypeWhereInput {
	and: [productTypeWhereInput]
	or: [productTypeWhereInput]
	tenantId: String
	tenantId_in: [String]
	typeId: String
	typeId_in: [String]
}

"A product filter"
input productWhereInput {
	and: [productWhereInput]
	benefits_some: benefitWhere
	changeEffectiveDate_gt: Date
	changeEffectiveDate_lt: Date
	fields: fieldsWhereInput
	id_in: [productIdInput]
	insurer: insurerWhere
	internalReviews_some: internalReviewWhere
	issuerProductId: String
	launchPeriodEndDate_gt: Date
	launchPeriodEndDate_lt: Date
	launchPeriodStartDate_gt: Date
	launchPeriodStartDate_lt: Date
	lifecycleStage: String
	name_contains: String
	or: [productWhereInput]
	productId: productIdWhereInput
	productTreeId_exists: Boolean
	representation: fieldsWhereInput
	status: String
	status_in: [String]
	status_not_in: [String]
	tags_some: tagWhere
	tenantId: String
	tenantId_in: [String]
}

input products_DiscountCodeApplyInput {
	discountCode: String
}

input products_DiscountCodeFilterInput {
	id: String
	id_in: [String]
	name: String
	name_contains: String
	name_in: [String]
	productIds_contains: products_ProductIdWhereInput
	productIds_exists: Boolean
	productIds_in: [products_ProductIdInput]
	productTypeId: String
	productTypeId_in: [String]
	type: products_DiscountType
	validFrom_gt: DateTime
	validFrom_gte: DateTime
	validFrom_lt: DateTime
	validFrom_lte: DateTime
	validTo_exists: Boolean
	validTo_gt: DateTime
	validTo_gte: DateTime
	validTo_lt: DateTime
	validTo_lte: DateTime
}

input products_DiscountCodeProductsUpsertInput {
	byId: String
	discountCodeId: String
	productIds: [products_ProductIdInput]
}

input products_DiscountCodeUpsertInput {
	byId: String
	description: String
	id: String
	name: String
	productTypeId: String
	redemptionLimit: Int
	type: products_DiscountType
	validFrom: DateTime
	validTo: DateTime
	value: Decimal
}

input products_GenericDiscountCode3BatchInput {
	create: [products_DiscountCodeUpsertInput]
	delete: [products_DiscountCodeUpsertInput]
	update: [products_DiscountCodeUpsertInput]
}

input products_GenericDiscountCodeFilterInput {
	and: [products_GenericDiscountCodeFilterInput]
	or: [products_GenericDiscountCodeFilterInput]
	where: products_DiscountCodeFilterInput
}

input products_GenericDiscountCodeQueryInput {
	asOf: DateTime
	first: Int
	groupBy: products_GroupByInput
	includeEvents: Boolean
	orderBy: products_OrderByInput
	orderBy2: [products_OrderByInput!]
	skip: Int
	where: products_GenericDiscountCodeFilterInput
}

input products_GenericProductImportHistoryRecordFilterInput {
	and: [products_GenericProductImportHistoryRecordFilterInput]
	or: [products_GenericProductImportHistoryRecordFilterInput]
	where: products_ProductImportHistoryRecordFilterInput
}

input products_GenericProductImportHistoryRecordQueryInput {
	asOf: DateTime
	first: Int
	groupBy: products_GroupByInput
	includeEvents: Boolean
	orderBy: products_OrderByInput
	orderBy2: [products_OrderByInput!]
	skip: Int
	where: products_GenericProductImportHistoryRecordFilterInput
}

input products_GenericSbu3BatchInput {
	create: [products_SbuUpsertInput]
	delete: [products_SbuUpsertInput]
	update: [products_SbuUpsertInput]
}

input products_GenericSbuFilterInput {
	and: [products_GenericSbuFilterInput]
	or: [products_GenericSbuFilterInput]
	where: products_SbuFilterInput
}

input products_GenericSbuQueryInput {
	asOf: DateTime
	first: Int
	groupBy: products_GroupByInput
	includeEvents: Boolean
	orderBy: products_OrderByInput
	orderBy2: [products_OrderByInput!]
	skip: Int
	where: products_GenericSbuFilterInput
}

input products_GroupByInput {
	fieldName: String
}

input products_OrderByInput {
	fieldName: String
	type: products_OrderByType!
}

input products_ProductIdInput {
	plan: String
	type: String
	version: String
}

input products_ProductIdWhereInput {
	plan: String
	plan_contains: String
	plan_in: [String]
	type: String
	type_in: [String]
	version: String
	version_contains: String
	version_in: [String]
	version_ncontains: String
}

input products_ProductImportHistoryRecordFilterInput {
	productId_in: [products_ProductIdInput]
}

input products_SbuFilterInput {
	id: String
	id_in: [String]
}

input products_SbuUpsertInput {
	amount: Decimal
	byId: String
	endDate: DateTime
	id: String
	startDate: DateTime
}

"a proposal filter"
input proposalWhere {
	id: String
	id_in: [String]
	isIssued: Boolean
	issuedAt_gt: Date
	issuedAt_lt: Date
	name: String
	name_contains: String
	offers_contains: offerWhere
	offers_every: offerWhere
	offers_exist: Boolean
	policyId_contains: String
	policyId_contains_every: [String]
	policyId_contains_some: [String]
	proposalNumber: String
	proposalNumber_contains: String
	referralCode: String
	renewalHistory: renewalHistoryWhereInput
	status: String
}

input providerSettingsInput {
	entityIds: [String]
}

input pushMessageDataInput {
	type: String!
	value: String!
}

"A push message"
input pushMessageInput {
	content: String
	data: [pushMessageDataInput]
	title: String
	token: String
	topic: String
}

"Input for a range"
input rangeInput {
	exclusiveMaximum: Boolean
	exclusiveMinimum: Boolean
	maximum: Float
	minimum: Float
}

input refundInput {
	amount: Decimal
	currencyCode: currencyCodeEnumeration
	remark: String
}

"Register an individual which creates a login and an individual and link them with limited permissions"
input registerIndividualInput {
	chineseFirstName: String
	chineseLastName: String
	email: String!
	englishFirstName: String
	englishLastName: String
	"If null, will generate an individual code of 'internalCodeLength'. Default length is 6."
	internalCode: String
	"If 'internalCode' is null, will generate an internal code of 'internalCodeLength'. Default length is 6."
	internalCodeLength: Int
	isEmailConfirmed: Boolean
	nameFormat: String
	"If null, will let this user chose his password"
	password: String
	salutation: String
	telephoneNumber: String
	"If null, is equal to the email."
	username: String
}

"Reject guarantee of payment input"
input rejectGOPInput {
	codes: [String]
	remarks: String
}

input rejectionReasonInput {
	description: String
}

"The product rejection settings input"
input rejectionSettingsInput {
	codes: [String]
}

"Relationship list filter"
input relationshipListWhereInput {
	targetId: String
	targetId_in: [String]
	type: String
	type_in: [String]
}

"A relationship value"
input relationshipValueInput {
	key: String!
	value: String!
}

"An object search filter"
input relationshipWhereInput {
	and: [relationshipWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	entityId_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [relationshipWhereInput]
	type: String
	type_in: [String]
	value: scalarValueInput
	value_not: scalarValueInput
}

"Remark upsert model"
input remarkUpsert {
	fields: String
	id: String!
	remarkFull: String
	remarkShort: String
}

"Claim remarks filter"
input remarkWhere {
	and: [remarkWhere]
	fields: fieldsWhereInput
	id: String
	id_in: [String]
	or: [remarkWhere]
	remarkFull_contains: String
	remarkShort_contains: String
}

input removeBenefitInput {
	optionKey: String
	typeId: String!
}

input removeClauseFromPolicyInput {
	clauseId: String!
}

input removeDataSchemaFromProductTypeInput {
	dataSchemaId: String!
	productTypeId: String!
}

"A command to remove a link between entities"
input removeLinkInput {
	link: String!
	sourceId: String!
	targetId: String!
}

input removeScriptFromProductInput {
	productId: productIdInput!
	scriptId: String!
}

input removeScriptInput {
	scriptId: String!
}

input removeTargetedPermissionSchemaFromLoginInput {
	loginId: String!
	permissionSchemaId: String!
	targetIds: [String!]
}

"Input to remove a permission to a target to a login"
input removeTargettedPermissionInput {
	type: String!
	value: String!
}

input removeTemplateRelationshipFromProductInput {
	productId: productIdInput
	templateRelationshipId: String!
}

input removeUiSchemaFromDataSchemaInput {
	dataSchemaId: String!
	uiSchemaId: String!
}

"Renews a proposal"
input renewProposalInput {
	overrideStartDateAndEndDateAutomatically: Boolean
	proposalNumber: String
	renewedFromId: String!
}

"Renewal history input"
input renewalHistoryInput {
	renewedFromId: String
	renewedToId: String
}

input renewalHistoryWhereInput {
	isRenewed: Boolean
	renewedById: String
	renewedFromId: String
}

input requestManager_AddressInput {
	addressLine1: String
	addressLine2: String
	addressLine3: String
	addressLine4: String
	addressType: String
	country: requestManager_COUNTRY
	postCode: String
	useForMail: Boolean
	validFrom: DateTime
	validTo: DateTime
}

input requestManager_ContactInput {
	contactChannel: String
	email: String
	phoneArea: String
	phoneCountry: requestManager_COUNTRY
	phoneNumber: String
	validFrom: DateTime
	validTo: DateTime
}

input requestManager_DateRangeFilterInput {
	from: DateTime
	to: DateTime
}

input requestManager_ExternalRefSortInput {
	domain: requestManager_SortEnumType
	domainAggregate: requestManager_SortEnumType
	refId: requestManager_SortEnumType
	type: requestManager_SortEnumType
}

input requestManager_IdentityInput {
	expiryDate: DateTime
	identifierNumber: String
	identifyDocumentId: String
	identifyType: String
	issuanceCountry: requestManager_COUNTRY
	issueDate: DateTime
	validFrom: DateTime
	validTo: DateTime
}

input requestManager_MarketingPreferenceSortInput {
	email: requestManager_SortEnumType
	phone: requestManager_SortEnumType
	post: requestManager_SortEnumType
	sMS: requestManager_SortEnumType
}

input requestManager_OrganizationInput {
	glyphOperatingName: String
	glyphRegisteredName: String
	operatingName: String
	organizationType: String
	registeredName: String
	registrationCountry: requestManager_COUNTRY
	registrationDate: DateTime
	registrationNumber: String
}

input requestManager_OrganizationPartySortInput {
	communications: requestManager_ExternalRefSortInput
	dateCreated: requestManager_SortEnumType
	documents: requestManager_ExternalRefSortInput
	goneAway: requestManager_SortEnumType
	isDeleted: requestManager_SortEnumType
	language: requestManager_SortEnumType
	marketingPreference: requestManager_MarketingPreferenceSortInput
	masterPartyID: requestManager_SortEnumType
	organization: requestManager_OrganizationSortInput
	partyAccountID: requestManager_SortEnumType
	partyID: requestManager_SortEnumType
	paymentMethods: requestManager_ExternalRefSortInput
	requestToBeForgotten: requestManager_RequestToBeForgottenSortInput
	sanctions: requestManager_SortEnumType
	type: requestManager_SortEnumType
	validFrom: DateTime
	validTo: DateTime
}

input requestManager_OrganizationSearchFilterInput {
	operatingName: String
	partyAccountID: String
	postCode: String
	registrationNumber: String
	search: String
}

input requestManager_OrganizationSortInput {
	glyphOperatingName: requestManager_SortEnumType
	glyphRegisteredName: requestManager_SortEnumType
	operatingName: requestManager_SortEnumType
	organizationType: requestManager_SortEnumType
	registeredName: requestManager_SortEnumType
	registrationCountry: requestManager_SortEnumType
	registrationDate: requestManager_SortEnumType
	registrationNumber: requestManager_SortEnumType
}

input requestManager_PersonInput {
	dateOfBirth: DateTime
	dateOfDeath: DateTime
	ethnicity: String
	firstName: String
	gender: String
	glyphName: String
	identities: [requestManager_IdentityInput]
	middleName: String
	mothersMaidenName: String
	nationality: requestManager_COUNTRY
	pep: Boolean
	preferredCommOption: String
	preferredPronouns: String
	prefix: String
	residency: requestManager_COUNTRY
	salutation: String
	suffix: String
	surname: String
}

input requestManager_PersonPartySortInput {
	communications: requestManager_ExternalRefSortInput
	dateCreated: requestManager_SortEnumType
	documents: requestManager_ExternalRefSortInput
	goneAway: requestManager_SortEnumType
	isDeleted: requestManager_SortEnumType
	language: requestManager_SortEnumType
	marketingPreference: requestManager_MarketingPreferenceSortInput
	masterPartyID: requestManager_SortEnumType
	partyAccountID: requestManager_SortEnumType
	partyID: requestManager_SortEnumType
	paymentMethods: requestManager_ExternalRefSortInput
	person: requestManager_PersonSortInput
	requestToBeForgotten: requestManager_RequestToBeForgottenSortInput
	sanctions: requestManager_SortEnumType
	type: requestManager_SortEnumType
	validFrom: DateTime
	validTo: DateTime
}

input requestManager_PersonSearchFilterInput {
	dateOfBirth: requestManager_DateRangeFilterInput
	firstName: String
	idNumber: String
	partyAccountID: String
	phoneNumber: String
	postCode: String
	search: String
	surname: String
}

input requestManager_PersonSortInput {
	dateOfBirth: requestManager_SortEnumType
	dateOfDeath: requestManager_SortEnumType
	ethnicity: requestManager_SortEnumType
	firstName: requestManager_SortEnumType
	gender: requestManager_SortEnumType
	glyphName: requestManager_SortEnumType
	middleName: requestManager_SortEnumType
	mothersMaidenName: requestManager_SortEnumType
	nationality: requestManager_SortEnumType
	pep: requestManager_SortEnumType
	preferredCommOption: requestManager_SortEnumType
	preferredPronouns: requestManager_SortEnumType
	prefix: requestManager_SortEnumType
	residency: requestManager_SortEnumType
	salutation: requestManager_SortEnumType
	suffix: requestManager_SortEnumType
	surname: requestManager_SortEnumType
}

input requestManager_RegisterPartyCommandInput {
	addresses: [requestManager_AddressInput]
	contacts: [requestManager_ContactInput]
	organization: requestManager_OrganizationInput
	partyAccountID: String
	partyType: requestManager_PartyType
	person: requestManager_PersonInput
}

input requestManager_RequestToBeForgottenSortInput {
	dateRequested: requestManager_SortEnumType
	decision: requestManager_SortEnumType
	notes: requestManager_SortEnumType
	request: requestManager_SortEnumType
}

"The input to review a policy"
input requestPolicyReviewInput {
	isApproved: Boolean!
	note: String
}

input resultCellInput {
	columnIndex: Int
	rowIndex: Int
	type: cellType
}

"reverse a claim"
input reverseClaimInput {
	reason: String!
	withStatus: String!
}

input reviewWhereInput {
	and: [reviewWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	or: [reviewWhereInput]
	relatedId: String
	relatedId_in: [String]
	type: String
	type_in: [String]
}

"A representation of a sclar value object"
input scalarValueInput {
	arrayValue: [scalarValueInput]
	booleanValue: Boolean
	dateValue: DateTime
	numberValue: Decimal
	objectValue: [keyValueInput]
	stringValue: String
}

input scoreInput {
	comment: String
	type: String
	value: Decimal
}

input scriptWhereInput {
	and: [scriptWhereInput!]
	id: String
	id_in: [String!]
	or: [scriptWhereInput!]
}

input sendNotificationCommandWhereInput {
	toEntityId: String
	toEntityId_in: [String]
}

"The input to send notifications"
input sendNotificationInput {
	chatMessage: chatMessageInput
	emailMessage: emailMessageInput
	fromEntityId: String
	internalMessage: internalMessageInput
	offerId: String
	policyId: String
	pushMessage: pushMessageInput
	smsMessage: smsMessageInput
	toEntityId: String
	toEntityIds: [String]
	toTopic: String
	toTopicId: String
	type: String
	useConfig: Boolean
}

"Update panel provider tier input"
input serviceItemAgreedFeeBatchInput {
	addIds: [String]
	removeIds: [String]
}

input serviceItemAgreedFeeWhereInput {
	and: [serviceItemAgreedFeeWhereInput!]
	currency: String
	currency_in: [String!]
	id: String
	id_in: [String!]
	or: [serviceItemAgreedFeeWhereInput!]
	serviceItemId: String
	serviceItemId_in: [String!]
}

input serviceItemWhereInput {
	and: [serviceItemWhereInput!]
	id: String
	id_in: [String!]
	name: String
	name_in: [String!]
	or: [serviceItemWhereInput!]
}

"A sms message"
input smsMessageInput {
	body: String
	from: String
	templateRendering: templateRenderingInput
	to: String
}

"Sort items"
input sortInput {
	"The field name onto which to sort"
	fieldName: String!
	"'asc' or 'desc'"
	type: String!
}

"Stakeholder filter"
input stakeholderWhere {
	entityId: String
	entityId_in: [String]
	id: String
	id_in: [String]
	type: String
	type_in: [String]
}

input statisticsMetadataInput {
	productCode: String
	vendor: String
}

input tagInput {
	type: String!
}

"A tag filter"
input tagWhere {
	id: String
	id_in: [String]
	type: String
	type_in: [String]
}

input templateRelationshipWhereInput {
	action: String
	and: [templateRelationshipWhereInput!]
	createdAt_gt: Date
	createdAt_lt: Date
	createdById: String
	createdById_contains: String
	createdById_in: [String!]
	id: String
	id_in: [String!]
	lastModifiedAt_gt: Date
	lastModifiedAt_lt: Date
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String!]
	or: [templateRelationshipWhereInput!]
}

input templateRenderParametersInput {
	contentJsonString: String
	name: String!
	overrideAttachmentReferences: [overrideEmailAttachmentReferenceInput]
	overrideAttachmentTemplates: [overrideEmailAttachmentTemplateInput]
	statisticsMetadata: statisticsMetadataInput
	variablesJsonString: String
}

input templateRenderingInput {
	input: templateRenderParametersInput
	logicalId: String
	templateId: String
}

"A claim search filter"
input templateWhereInput {
	and: [templateWhereInput]
	createdAt_gt: DateTimeOffset
	createdAt_lt: DateTimeOffset
	createdById: String
	createdById_contains: String
	createdById_in: [String]
	description_contains: String
	has_LogicalId: Boolean
	id: String
	id_in: [String]
	lastModifiedAt_gt: DateTimeOffset
	lastModifiedAt_lt: DateTimeOffset
	lastModifiedById: String
	lastModifiedById_contains: String
	lastModifiedById_in: [String]
	logicalId: String
	logicalId_in: [String]
	name: String
	name_contains: String
	or: [templateWhereInput]
	status: String
	status_contains: String
	status_in: String
	tags_contains: String
	type: String
	type_in: String
}

input templates_GenericTemplateStatisticsFilterInput {
	and: [templates_GenericTemplateStatisticsFilterInput]
	or: [templates_GenericTemplateStatisticsFilterInput]
	where: templates_TemplateStatisticsFilterInput
}

input templates_GenericTemplateStatisticsQueryInput {
	asOf: DateTime
	first: Int
	groupBy: templates_GroupByInput
	includeEvents: Boolean
	orderBy: templates_OrderByInput
	orderBy2: [templates_OrderByInput!]
	skip: Int
	where: templates_GenericTemplateStatisticsFilterInput
}

input templates_GroupByInput {
	fieldName: String
}

input templates_OrderByInput {
	fieldName: String
	type: templates_OrderByType!
}

input templates_TemplateStatisticsFilterInput {
	createdAt_gte: DateTime
	createdAt_lte: DateTime
	id: String
	id_in: [String]
	productCode: String
	productCode_contains: String
	templateId: String
	templateId_in: [String]
	vendor: String
	vendor_contains: String
}

"A transaction search filter"
input transactionWhereInput {
	and: [transactionWhereInput]
	dateTime_gt: DateTime
	dateTime_lt: DateTime
	debitNoteNumber: String
	endorsementId: String
	endorsementId_in: [String]
	fields: fieldsWhereInput
	hasDebitNoteNumber: Boolean
	id: String
	id_in: [String]
	isSettled: Boolean
	or: [transactionWhereInput]
	paymentProviderId: String
	policyId: String
	policyId_in: [String]
	settledToTransactionId: String
	stakeholderIds_contains: String
	status: transactionStatusEnumeration
	transactionNumber: String
	transactionNumber_contains: String
	type: String
}

input transactions_BatchTransactionsCommandInput {
	create: [transactions_CreateTransactionCommandInput]
	delete: [transactions_DeleteTransactionCommandInput]
	update: [transactions_UpdateTransactionCommandInput]
}

input transactions_CreateCheckoutSessionRequestInput {
	failureUrl: String
	priceId: String
	successUrl: String
}

input transactions_CreateTransactionCommandInput {
	accountCode: String
	accountType: String
	amount: Decimal
	billId: String
	claimId: String
	createdById: String
	currencyCode: transactions_CurrencyCode
	dateTime: DateTime
	debitNoteNumber: String
	description: String
	dueDateTime: DateTime
	endorsementId: String
	fields: String
	method: transactions_PaymentMethodType
	policyId: String
	postDateTime: DateTime
	proposalId: String
	settledToTransactionId: String
	status: transactions_TransactionStatus
	subscriptionId: String
	timestamp: DateTime
	transactionNumber: String
	type: String
}

input transactions_DeleteTransactionCommandInput {
	deletedById: String
	transactionId: String
}

input transactions_ExternalRefInput {
	providerConfigId: String
	ref: String
}

input transactions_ExternalRefToUpdateInput {
	isProviderConfigIdChanged: Boolean!
	isRefChanged: Boolean!
	providerConfigId: String
	ref: String
}

input transactions_ProviderSubscriptionCommandInput {
	amount: Int!
	createdById: String
	currencyCode: String!
	endDate: DateTime
	entityId: String!
	externalRef: transactions_ExternalRefInput
	interval: transactions_Interval!
	intervalCount: Int
	paymentDates: [DateTime!]
	paymentMethodId: String
	productId: String!
	providerConfigId: String
	startDate: DateTime
}

input transactions_RemoveSubscriptionDiscountCommandInput {
	dates: [DateTime!]
	interval: transactions_Interval!
	modifiedById: String
	subscriptionId: String
}

input transactions_SubscriptionDiscountInput {
	date: DateTime!
	discountAmount: Decimal!
	interval: transactions_Interval!
}

input transactions_UpdateTransactionCommandInput {
	amount: Decimal
	claimId: String
	currencyCode: transactions_CurrencyCode
	dateTime: DateTime
	debitNoteNumber: String
	description: String
	dueDateTime: DateTime
	endorsementId: String
	externalRef: transactions_ExternalRefToUpdateInput
	fields: String
	isAmountChanged: Boolean
	isClaimIdChanged: Boolean
	isCurrencyCodeChanged: Boolean
	isDateTimeChanged: Boolean
	isDebitNoteNumberChanged: Boolean
	isDescriptionChanged: Boolean
	isDueDateTimeChanged: Boolean
	isEndorsementIdChanged: Boolean
	isExternalRefChanged: Boolean
	isFieldsChanged: Boolean
	isMethodChanged: Boolean
	isPolicyIdChanged: Boolean
	isPostDateTimeChanged: Boolean
	isProposalIdChanged: Boolean
	isProviderIdChanged: Boolean
	isProviderTransactionIdChanged: Boolean
	isSettledToTransactionIdChanged: Boolean
	isStatusChanged: Boolean
	isTransactionNumberChanged: Boolean
	isTypeChanged: Boolean
	method: transactions_PaymentMethodType
	modifiedById: String
	policyId: String
	postDateTime: DateTime
	proposalId: String
	providerId: String
	providerTransactionId: String
	settledToTransactionId: String
	status: transactions_TransactionStatus
	transactionId: String
	transactionNumber: String
	type: String
}

input transactions_UpsertSubscriptionDiscountCommandInput {
	addedById: String
	discounts: [transactions_SubscriptionDiscountInput]
	subscriptionId: String
}

"Treatment Batch Input"
input treatmentBatchInput {
	create: [treatmentInput]
	delete: [treatmentRemoveInput]
	update: [treatmentUpdateInput]
}

"Treatment Filter Input"
input treatmentFilterInput {
	and: [treatmentFilterInput]
	or: [treatmentFilterInput]
	where: treatmentFilterWhereInput
}

"Treatment Filter Where Input"
input treatmentFilterWhereInput {
	category: String
	category_contains: String
	category_in: [String]
	code: String
	code_contains: String
	code_in: [String]
	id: String
	id_in: [String]
	name: String
	name_contains: String
	name_in: [String]
	subSystem: String
	subSystem_contains: String
	subSystem_in: [String]
	system: String
	system_contains: String
	system_in: [String]
}

"treatment input"
input treatmentInput {
	category: String
	code: String
	name: String
	subSystem: String
	system: String
}

"treatment remove input"
input treatmentRemoveInput {
	id: String
}

"treatment update input"
input treatmentUpdateInput {
	category: String
	code: String
	id: String
	name: String
	subSystem: String
	system: String
}

input uiSchemaStandardInputGraphType {
	type: uiSchemaStandardTypeEnum
	version: String
}

input uiSchemaWhereInput {
	and: [uiSchemaWhereInput]
	createdAt_gt: DateTime
	createdAt_lt: DateTime
	id: String
	id_in: [String]
	name: String
	name_in: [String]
	or: [uiSchemaWhereInput]
	schema: fieldsWhereInput
}

input underwritingInput {
	excelPath: String
	excelRules: excelRuleInput
	jsonLogicRules: String
	sourceType: String
}

"update achievement  input"
input updateAchievementInput {
	achievementTypeId: String
	entityId: String
}

"update achievement type input"
input updateAchievementTypeInput {
	logic: achievementLogicInput
	type: String
}

"A command to update an address for a user (customer or internal user)"
input updateAddressInput {
	fields: [updateAdressFieldInput]
	id: String!
	type: String!
}

"A command to update an address field"
input updateAdressFieldInput {
	type: String!
	value: String
}

input updateAppInput {
	absoluteRefreshTokenLifetime: Int
	accessTokenLifetime: Int
	activationTokenExpiryDisabled: Boolean
	appConfig: String
	appName: String
	defaultTimeZone: String
	email: String
	emailConfirmationTokenLifespan: Seconds
	emailSenderName: String
	redirectUris: [String]
	requires2FA: Boolean
	requiresEmail2FA: Boolean
	slidingRefreshTokenLifetime: Int
	urlRouting: urlRoutingInput
	useNotificationConfig: Boolean
}

"Updates a benefit of a claim"
input updateBenefitClaimInput {
	benefitDescription: String
	benefitName: String
	benefitTypeId: String
	currencyCode: currencyCodeEnumeration
	remark: String
	value: scalarValueInput
	values: [claimValueInput]
}

input updateBenefitDefinitionInput {
	benefitDefinitionId: String
	benefitDefinitionTypeIds: [String!]
	businessId: String
	description: String
	fields: String
	name: String
	status: String
}

input updateBenefitDefinitionTypeInput {
	benefitDefinitionTypeId: String
	businessId: String
	description: String
	fields: String
	name: String
	status: String
}

"an input for a benefit"
input updateBenefitInput {
	condition: conditionInput
	currencyCode: currencyCodeEnumeration
	isValueInput: Boolean
	parentOptionKeys: [String]
	parentTypeId: String
	value: scalarValueInput
	valueJsonString: String
}

"update case input"
input updateCaseInput {
	caseNumber: String
	componentId: String
	description: String
	fields: String
	fieldsPatch: String
	fieldsSchemaId: String
	holderId: String
	insuredIds: [String]
	name: String
	otherHolderIds: [String]
	source: String
	status: String
	workflowSchemaId: String
}

"Update Claim Batch Input"
input updateClaimBatchInput {
	claimId: String!
	diagnosisCodes: [String]
	exportBatchId: batchIdInput
	fields: String
	fieldsPatch: String
	importBatchId: batchIdInput
	issuerNumber: String
	operationCodes: [String]
	policyId: String
	providerId: String
	status: String
	updateType: String
}

"Update claim input"
input updateClaimInput {
	claimantId: String
	diagnosisCodes: [String]
	fields: String
	fieldsPatch: String
	issuerNumber: String
	operationCodes: [String]
	policyId: String
	providerId: String
	remark: String
	status: String
	updateType: String
}

input updateClauseHtmlTemplateInput {
	description: String
	graphQlQuery: String
	html: String
	logicalId: String
	name: String
	order: Int
	status: String
}

"update clause input"
input updateClauseInput {
	htmlOverride: String
	isOrderChanged: Boolean!
	isTemplateIdChanged: Boolean
	order: Int
	renderParameters: templateRenderParametersInput
	storeTemplateByValue: Boolean
	templateId: String
	type: String
}

input updateClauseOnPolicyInput {
	clauseId: String!
	htmlOverride: String
	isHtmlOverrideChanged: Boolean
	isOrderChanged: Boolean!
	isRenderParametersChanged: Boolean
	isTemplateIdChanged: Boolean
	isTypeChanged: Boolean
	order: Int
	renderParameters: templateRenderParametersInput
	storeTemplateByValue: Boolean
	templateId: String
	type: String
}

"A command to update a company"
input updateCompanyInput {
	acceptsMarketing: Boolean
	fields: String
	fieldsPatch: String
	nameFormat: String
	natureOfBusiness: String
	photoPath: String
	registrationNumber: String
	source: String
	status: String
	tags: [String]
}

input updateComponentInput {
	componentJsonString: String
	name: String
	status: componentStatusEnumeration
	version: componentVersionInput
	vueTemplate: String
}

"A command to update a contact detail for a user (customer or internal user)"
input updateContactInput {
	id: String!
	type: String!
	value: String
}

"A command to update a contract company"
input updateContractCompanyInput {
	acceptsMarketing: Boolean
	fields: String
	id: String
	nameFormat: String
	natureOfBusiness: String
	photoPath: String
	registrationNumber: String
	source: String
	tags: [String]
}

"A command to update a contract individual"
input updateContractIndividualInput {
	acceptsMarketing: Boolean
	chineseFirstName: String
	chineseLastName: String
	countryOfResidency: String
	dateOfBirth: Date
	employmentStatus: String
	englishFirstName: String
	englishLastName: String
	fields: String
	gender: String
	id: String
	incomeRange: rangeInput
	internalCode: String
	maritalStatus: String
	nameFormat: String
	occupation: String
	photoPath: String
	preferredCommunicationChannel: String
	preferredLanguage: String
	salutation: String
	source: String
	tags: [String]
}

"A command to update an object"
input updateContractObjectInput {
	fields: String
	id: String
	internalCode: String
	nameFormat: String
	photoPath: String
	source: String
	status: String
	tags: [String]
	typeId: String
}

"update course input"
input updateCourseInput {
	categories: [String]
	version: String
}

"update Course Progression input"
input updateCourseProgressionInput {
	courseId: String
	entityId: String
}

input updateDataSchemaInput {
	dataSchemaId: String!
	description: String!
	name: String!
	schema: String!
	standard: dataSchemaStandardInput
	tags: [String]
	type: String
}

input updateDiscountOfOfferInput {
	calculationJsonLogic: String
	name: String
	order: Int
}

input updateDynamicTemplateInput {
	description: String
	logicalId: String
	name: String
	tags: [String]
}

input updateDynamicValueOfTemplateInput {
	value: scalarValueInput
	valueJsonString: String
}

input updateEmailAttachmentReferenceInput {
	fileName: String
	filePath: String
}

input updateEmailAttachmentTemplateInput {
	attachmentTemplateId: String!
	fileName: String!
}

input updateEmailMjmlTemplateInput {
	description: String
	graphQlQuery: String
	logicalId: String
	mjml: String
	name: String
	subject: String
}

"Update Endorsement Input"
input updateEndorsementInput {
	cancellationMotive: String
	effectiveDate: DateTime
	isCancellationMotiveChanged: Boolean
	isEffectiveDateChanged: Boolean
	isReasonOfChangeChanged: Boolean
	isStatusChanged: Boolean
	reasonOfChange: String
	status: String
}

"Update fact input"
input updateFactInput {
	id: String
	type: String
	value: scalarValueInput
	values: scalarValueInput
}

input updateFileSystemConfigInput {
	accessKeyId: String
	accessKeySecret: String
	bucketName: String
	endpoint: String
	providerId: String
}

input updateFunctionTemplateInput {
	description: String
	engine: engineInput
	fileKey: String
	graphQlQuery: String
	logicalId: String
	name: String
}

"Update guarantee of payment input"
input updateGOPInput {
	currencyCode: currencyCodeEnumeration
	doctor: String
	estimatedAmount: Decimal
	fields: String
	fieldsPatch: String
	providerId: String
	status: String
	updateType: String
}

"A command to update an identity for a user (customer or internal user)"
input updateIdentityInput {
	id: String!
	type: String!
	value: String
}

"A command to update an individual"
input updateIndividualInput {
	acceptsMarketing: Boolean
	chineseFirstName: String
	chineseLastName: String
	countryOfResidency: String
	dateOfBirth: Date
	employmentStatus: String
	englishFirstName: String
	englishLastName: String
	fields: String
	fieldsPatch: String
	gender: String
	incomeRange: rangeInput
	internalCode: String
	maritalStatus: String
	nameFormat: String
	occupation: String
	photoPath: String
	preferredCommunicationChannel: String
	preferredLanguage: String
	salutation: String
	source: String
	status: String
	tags: [String]
	type: individualTypeEnumeration
}

"A command to update an internal"
input updateInternalInput {
	chineseFirstName: String
	chineseLastName: String
	description: String
	englishFirstName: String
	englishLastName: String
	fields: String
	fieldsPatch: String
	gender: String
	internalCode: String
	isActive: Boolean
	nameFormat: String
	photoPath: String
	source: String
	status: String
	tags: [String]
	title: String
}

"An input for updating an internal review of a product"
input updateInternalReviewInput {
	comment: String
	id: String!
	status: String
}

"Update jacket input"
input updateJacketInput {
	clauses: [addClauseToJacketInput]
	status: String
	title: String
}

"instance of jacket to update from offer"
input updateJacketInstanceInput {
	instanceId: String!
	order: Int
}

"update course progression input"
input updateLessonCompletionInput {
	itemAnswers: [lessonItemAnswerInput]
	lessonId: String
}

"Updates an item of a lesson"
input updateLessonItemInput {
	modifiedById: String
	type: lessonItemTypes
}

"Updates a lesson of a section of a course"
input updateLessonOfSectionInput {
	durationInSeconds: Int
	modifiedById: String
	passingRatio: Decimal
	version: String
	weight: Decimal
}

"A command to update a note for a user or a policy"
input updateNoteInput {
	content: String
	id: String
	title: String
}

input updateNotificationTemplateInput {
	description: String
	logicalId: String
	name: String
}

"A command to update an object"
input updateObjectInput {
	fields: String
	fieldsPatch: String
	internalCode: String
	nameFormat: String
	photoPath: String
	source: String
	status: String
	tags: [String]
	typeId: String
}

"updates an offer of a quote"
input updateOfferInput {
	contractId: String
	endDate: Date
	fields: String
	fieldsSchemaId: String
	offerNumber: String
	policyNumber: String
	premium: premiumInput
	pricing: String
	productId: productIdInput
	productTreeId: String
	prorationBehaviour: prorationBehaviourEnumeration
	startDate: Date
	status: String
	underwriting: String
	values: [keyValueInput]
}

"Updates an option of a lesson item"
input updateOptionOfLessonItemInput {
	isCorrect: Boolean
	modifiedById: String
}

"A command to update an internal"
input updateOrganizationInput {
	fields: String
	fieldsPatch: String
	isActive: Boolean
	nameFormat: String
	photoPath: String
	source: String
	status: String
	tags: [String]
	type: String
}

input updatePageObjectOfWkhtmltopdfTemplateInput {
	footerSettings: headerFooterInput
	headerSettings: headerFooterInput
	html: String
	id: String!
}

"Update panel provider tier input"
input updatePanelProviderTierInput {
	description: String
	fields: String
	name: String
	panelId: String
}

input updatePdfDrawingInput {
	font: fontInput
	liquidSource: String
	page: Int
	point1: pointInput
	point2: pointInput
	textAlignment: textAlignmentEnumeration
	verticalAlignment: verticalAlignmentEnumeration
}

input updatePermissionSchemaInput {
	actionType: permissionSchemaActionType
	description: String
	name: String
	objectType: String
	permissionSchemaId: String
	schema: String
	stateCondition: fieldsWhereInput
	updateCondition: fieldsWhereInput
}

"Input to update a policy"
input updatePolicyInput {
	"only populate either `ContractHolderIndividual` or `ContractHolderCompany` but not both."
	contractHolderCompany: updateContractCompanyInput
	"only populate either `ContractHolderIndividual` or `ContractHolderCompany` but not both."
	contractHolderIndividual: updateContractIndividualInput
	description: String
	endDate: Date
	extraFields: String
	fields: String
	fieldsPatch: String
	fieldsSchemaId: String
	holderId: String
	insuredIds: [String]
	issueDate: Date
	issuerNumber: String
	lapseReason: String
	premium: premiumInput
	productId: productIdInputToUpdateInput
	referralCode: String
	source: String
	startDate: Date
	status: String
	values: [keyValueInput]
}

"instance of jacket to update from policy"
input updatePolicyJacketInstanceInput {
	instanceId: String!
	order: Int
}

input updatePricingOptionInput {
	key: String
	valueJsonString: String
}

input updateProductConfigInput {
	clientId: String
	displayedBenefits: [displayedBenefitsInput]
	displayedInsurers: [displayedInsurersInput]
	displayedProducts: [displayedProductsInput]
	displayedTypes: [String]
}

"Input to update a custom product"
input updateProductInput {
	changeEffectiveDate: Date
	claimSettings: claimSettingsInput
	exclusionSettings: exclusionSettingsInput
	fields: String
	fieldsPatch: String
	insurerId: String
	isFieldsChanged: Boolean
	isRepresentationChanged: Boolean
	launchPeriodEndDate: Date
	launchPeriodStartDate: Date
	lifecycleStage: String
	loadingSettings: loadingSettingsInput
	productTreeId: String
	rejectionSettings: rejectionSettingsInput
	representation: String
	representationPatch: String
	status: String
	underwriting: underwritingInput
	underwritingRules: String
}

"update proposal input"
input updateProposalInput {
	expiryDate: Date
	name: String
	proposalNumber: String
	referralCode: String
	status: String
	totalPrice: premiumInput
}

input updateReviewInput {
	comment: String
	relatedId: String
	type: String
}

input updateScoreInput {
	comment: String
	type: String
	value: Decimal
}

input updateScriptInput {
	externalTableDataUrl: String
	externalTableDataUrls: [String!]
	inputSchema: String
	name: String
	outputSchema: String
	referenceSourceCodeUrl: String
	scriptId: String!
	sourceCode: String
	type: scriptTypeEnum
}

input updateServiceItemAgreedFeeInput {
	currency: String
	id: String!
	isCurrencyChanged: Boolean
	isRateChanged: Boolean
	isServiceItemIdChanged: Boolean
	rate: Decimal
	serviceItemId: String
}

input updateServiceItemInput {
	description: String
	id: String!
	isDescriptionChanged: Boolean
	isNameChanged: Boolean
	name: String
}

input updateSmsTemplateInput {
	bodyLiquid: String
	description: String
	graphQlQuery: String
	logicalId: String
	name: String
}

input updateStakeholderInput {
	entityId: String!
	type: String!
}

input updateSubscriptionInput {
	endDate: DateTime
	paymentMethodId: String
}

"an input for creating a transaction"
input updateTransactionInput {
	amount: Float
	claimId: String
	currencyCode: currencyCodeEnumeration
	dateTime: DateTime
	debitNoteNumber: String
	description: String
	dueDateTime: DateTimeOffset
	endorsementId: String
	fields: String
	method: paymentMethod
	policyId: String
	postDateTime: DateTimeOffset
	proposalId: String
	settledToTransactionId: String
	status: transactionStatusEnumeration
	transactionId: String
	transactionNumber: String
	type: String
}

input updateUiSchemaInput {
	id: String!
	name: String!
	schema: String!
	standard: uiSchemaStandardInputGraphType
}

input updateWkhtmltopdfTemplateInput {
	description: String
	footerSettings: headerFooterInput
	graphQlQuery: String
	headerSettings: headerFooterInput
	html: String
	logicalId: String
	marginSettings: marginSettingsInput
	name: String
	orientation: orientationEnumeration
	password: String
	passwordLiquid: String
}

"Input to upsert l10n clone product name"
input upsertL10nCloneProductNameInput {
	"'zh-HK' or 'zh-CN' or 'en'"
	locale: String!
	value: String!
}

"Input to upsert l10ns"
input upsertL10nInput {
	"For product: 'products-{id}-name' or 'products-{id}-description'"
	key: String!
	"'zh-HK' or 'zh-CN' or 'en'"
	locale: String!
	value: String!
}

input urlRoutingInput {
	order: Int
	regexPattern: String
	url: String
}

input userStorageItemCreateInput {
	fields: String
	key: String
}

input userStorageItemUpdateInput {
	fields: String
	key: String
}

input userStorageItemsWhereInput {
	and: [userStorageItemsWhereInput]
	key_contains: String
	key_in: [String]
	or: [userStorageItemsWhereInput]
}

input users_AddAddressCommandInput {
	addedById: String
	fields: [users_KeyValuePairOfStringAndStringInput!]
	id: String
	type: String
}

input users_AddressBatchCommandInput {
	addAddressCommands: [users_AddAddressCommandInput]
	entityId: String
	type: users_EntityTypes!
	updateAddressCommands: [users_UpdateAddressCommandInput]
}

input users_AgentReminderFilterInput {
	agentCode: String
	agentCode_contains: String
	agentCode_in: [String]
	branchCode: String
	branchCode_contains: String
	branchCode_in: [String]
	count: Int
	count_gt: Int
	count_gte: Int
	count_lt: Int
	count_lte: Int
	createdAt_gt: DateTime
	createdAt_gte: DateTime
	createdAt_lt: DateTime
	createdAt_lte: DateTime
	from_gt: DateTime
	from_gte: DateTime
	from_lt: DateTime
	from_lte: DateTime
	id: String
	isChecked: Boolean
	lastModifiedAt_gt: DateTime
	lastModifiedAt_gte: DateTime
	lastModifiedAt_lt: DateTime
	lastModifiedAt_lte: DateTime
	to_gt: DateTime
	to_gte: DateTime
	to_lt: DateTime
	to_lte: DateTime
	type: String
	type_in: [String]
}

input users_AgentReminderUpsertInput {
	agentCode: String
	branchCode: String
	count: Int
	from: DateTime
	id: String
	isChecked: Boolean
	to: DateTime
	type: String
}

input users_AgreedFeeFilterInput {
	id: String
	id_in: [String]
	organizationNegotiatedItemId: String
	organizationNegotiatedItemId_in: [String]
}

input users_AgreedFeeGroupFilterInput {
	from_gt: String
	from_gte: String
	from_lt: String
	from_lte: String
	id: String
	id_in: [String]
	to_gt: String
	to_gte: String
	to_lt: String
	to_lte: String
}

input users_AgreedFeeGroupUpsertInput {
	agreedFeeIds: [String]
	from: DateTime
	id: String
	remarks: String
	to: DateTime
}

input users_AgreedFeeUpsertInput {
	currency: String
	id: String
	organizationNegotiatedItemId: String
	rate: Decimal
}

input users_CreateAttachedRuleCommandOfusersAttachedCommandPermissionInput {
	create: users_usersAttachedCommandPermissionInput
	id: String
}

input users_CreateAttachedRuleCommandOfusersAttachedExternalApiCallInput {
	create: users_usersAttachedExternalApiCallInput
	id: String
}

input users_CreateAttachedRuleCommandOfusersAttachedFilterInput {
	create: users_usersAttachedFilterInput
	id: String
}

input users_CreateAttachedRuleCommandOfusersAttachedObjectValidationInput {
	create: users_usersAttachedObjectValidationInput
	id: String
}

input users_CreateAttachedRuleCommandOfusersAttachedPostHandleValidationInput {
	create: users_usersAttachedPostHandleValidationInput
	id: String
}

input users_CreateKycCheckCommandInput {
	entityId: String
	kycProviderEnum: users_KycProviderEnum!
	reportNames: [String]
}

input users_DeleteAttachedRuleCommandOfusersAttachedCommandPermissionInput {
	id: String
}

input users_DeleteAttachedRuleCommandOfusersAttachedExternalApiCallInput {
	id: String
}

input users_DeleteAttachedRuleCommandOfusersAttachedFilterInput {
	id: String
}

input users_DeleteAttachedRuleCommandOfusersAttachedObjectValidationInput {
	id: String
}

input users_DeleteAttachedRuleCommandOfusersAttachedPostHandleValidationInput {
	id: String
}

input users_ExternalApiCallInput {
	afterCall: [String!]
	beforeCall: [String!]
	contentType: String
	contextSlug: String
	expectedContentExpression: String
	expectedResponseExpression: String
	headers: [users_KeyValuePairOfStringAndStringInput!]
	itemValidationExpression: String
	method: String!
	stringContent: String
	timeout: String
	url: String!
}

input users_FieldsWhereInput {
	and: [users_FieldsWhereInput]
	condition: users_FieldsWhereCondition!
	or: [users_FieldsWhereInput]
	path: String
	value: users_ScalarValueInput
}

input users_GenericAgentReminder3BatchInput {
	create: [users_AgentReminderUpsertInput]
	delete: [users_AgentReminderUpsertInput]
	update: [users_AgentReminderUpsertInput]
}

input users_GenericAgentReminderFilterInput {
	and: [users_GenericAgentReminderFilterInput]
	or: [users_GenericAgentReminderFilterInput]
	where: users_AgentReminderFilterInput
}

input users_GenericAgentReminderQueryInput {
	asOf: DateTime
	first: Int
	groupBy: users_GroupByInput
	includeEvents: Boolean
	orderBy: users_OrderByInput
	orderBy2: [users_OrderByInput!]
	skip: Int
	where: users_GenericAgentReminderFilterInput
}

input users_GenericAgreedFee3BatchInput {
	create: [users_AgreedFeeUpsertInput]
	delete: [users_AgreedFeeUpsertInput]
	update: [users_AgreedFeeUpsertInput]
}

input users_GenericAgreedFeeFilterInput {
	and: [users_GenericAgreedFeeFilterInput]
	or: [users_GenericAgreedFeeFilterInput]
	where: users_AgreedFeeFilterInput
}

input users_GenericAgreedFeeGroup3BatchInput {
	create: [users_AgreedFeeGroupUpsertInput]
	delete: [users_AgreedFeeGroupUpsertInput]
	update: [users_AgreedFeeGroupUpsertInput]
}

input users_GenericAgreedFeeGroupFilterInput {
	and: [users_GenericAgreedFeeGroupFilterInput]
	or: [users_GenericAgreedFeeGroupFilterInput]
	where: users_AgreedFeeGroupFilterInput
}

input users_GenericAgreedFeeGroupQueryInput {
	asOf: DateTime
	first: Int
	groupBy: users_GroupByInput
	includeEvents: Boolean
	orderBy: users_OrderByInput
	orderBy2: [users_OrderByInput!]
	skip: Int
	where: users_GenericAgreedFeeGroupFilterInput
}

input users_GenericAgreedFeeQueryInput {
	asOf: DateTime
	first: Int
	groupBy: users_GroupByInput
	includeEvents: Boolean
	orderBy: users_OrderByInput
	orderBy2: [users_OrderByInput!]
	skip: Int
	where: users_GenericAgreedFeeFilterInput
}

input users_GenericNegotiatedItem3BatchInput {
	create: [users_NegotiatedItemUpsertInput]
	delete: [users_NegotiatedItemUpsertInput]
	update: [users_NegotiatedItemUpsertInput]
}

input users_GenericNegotiatedItemFilterInput {
	and: [users_GenericNegotiatedItemFilterInput]
	or: [users_GenericNegotiatedItemFilterInput]
	where: users_NegotiatedItemFilterInput
}

input users_GenericNegotiatedItemQueryInput {
	asOf: DateTime
	first: Int
	groupBy: users_GroupByInput
	includeEvents: Boolean
	orderBy: users_OrderByInput
	orderBy2: [users_OrderByInput!]
	skip: Int
	where: users_GenericNegotiatedItemFilterInput
}

input users_GenericNetwork3BatchInput {
	create: [users_NetworkUpsertInput]
	delete: [users_NetworkUpsertInput]
	update: [users_NetworkUpsertInput]
}

input users_GenericNetworkFilterInput {
	and: [users_GenericNetworkFilterInput]
	or: [users_GenericNetworkFilterInput]
	where: users_NetworkFilterInput
}

input users_GenericNetworkQueryInput {
	asOf: DateTime
	first: Int
	groupBy: users_GroupByInput
	includeEvents: Boolean
	orderBy: users_OrderByInput
	orderBy2: [users_OrderByInput!]
	skip: Int
	where: users_GenericNetworkFilterInput
}

input users_GenericOrganizationNegotiatedItem3BatchInput {
	create: [users_OrganizationNegotiatedItemUpsertInput]
	delete: [users_OrganizationNegotiatedItemUpsertInput]
	update: [users_OrganizationNegotiatedItemUpsertInput]
}

input users_GenericOrganizationNegotiatedItemFilterInput {
	and: [users_GenericOrganizationNegotiatedItemFilterInput]
	or: [users_GenericOrganizationNegotiatedItemFilterInput]
	where: users_OrganizationNegotiatedItemFilterInput
}

input users_GenericOrganizationNegotiatedItemQueryInput {
	asOf: DateTime
	first: Int
	groupBy: users_GroupByInput
	includeEvents: Boolean
	orderBy: users_OrderByInput
	orderBy2: [users_OrderByInput!]
	skip: Int
	where: users_GenericOrganizationNegotiatedItemFilterInput
}

input users_GenericOrganizationProviderTier3BatchInput {
	create: [users_OrganizationProviderTierUpsertInput]
	delete: [users_OrganizationProviderTierUpsertInput]
	update: [users_OrganizationProviderTierUpsertInput]
}

input users_GenericOrganizationProviderTierFilterInput {
	and: [users_GenericOrganizationProviderTierFilterInput]
	or: [users_GenericOrganizationProviderTierFilterInput]
	where: users_OrganizationProviderTierFilterInput
}

input users_GenericOrganizationProviderTierQueryInput {
	asOf: DateTime
	first: Int
	groupBy: users_GroupByInput
	includeEvents: Boolean
	orderBy: users_OrderByInput
	orderBy2: [users_OrderByInput!]
	skip: Int
	where: users_GenericOrganizationProviderTierFilterInput
}

input users_GenericServiceRate3BatchInput {
	create: [users_ServiceRateCreateInput]
	delete: [users_ServiceRateDeleteInput]
	update: [users_ServiceRateUpdateInput]
}

input users_GenericServiceRateFilterInput {
	and: [users_GenericServiceRateFilterInput]
	or: [users_GenericServiceRateFilterInput]
	where: users_ServiceRateFilterInput
}

input users_GenericServiceRateQueryInput {
	asOf: DateTime
	first: Int
	groupBy: users_GroupByInput
	includeEvents: Boolean
	orderBy: users_OrderByInput
	orderBy2: [users_OrderByInput!]
	skip: Int
	where: users_GenericServiceRateFilterInput
}

input users_GenericServicingAgentChangeLog3BatchInput {
	create: [users_ServicingAgentChangeLogUpsertInput]
	delete: [users_ServicingAgentChangeLogUpsertInput]
	update: [users_ServicingAgentChangeLogUpsertInput]
}

input users_GenericServicingAgentChangeLogFilterInput {
	and: [users_GenericServicingAgentChangeLogFilterInput]
	or: [users_GenericServicingAgentChangeLogFilterInput]
	where: users_ServicingAgentChangeLogFilterInput
}

input users_GenericServicingAgentChangeLogQueryInput {
	asOf: DateTime
	first: Int
	groupBy: users_GroupByInput
	includeEvents: Boolean
	orderBy: users_OrderByInput
	orderBy2: [users_OrderByInput!]
	skip: Int
	where: users_GenericServicingAgentChangeLogFilterInput
}

input users_GenericUsers_AttachedRuleFilterInput {
	and: [users_GenericUsers_AttachedRuleFilterInput]
	or: [users_GenericUsers_AttachedRuleFilterInput]
	where: users_users_AttachedRuleFilterInput
}

input users_GenericUsers_AttachedRuleQueryInput {
	asOf: DateTime
	first: Int
	groupBy: users_GroupByInput
	includeEvents: Boolean
	orderBy: users_OrderByInput
	orderBy2: [users_OrderByInput!]
	skip: Int
	where: users_GenericUsers_AttachedRuleFilterInput
}

input users_GroupByInput {
	fieldName: String
}

input users_IntegrationCommandInput {
	entityId: String
	externalEntityId: String
	externalProductId: String
	systemId: String
}

input users_KeyScalarValueInput {
	key: String
	value: users_ScalarValueInput
}

input users_KeyValuePairOfStringAndStringInput {
	key: String!
	value: String!
}

input users_NegotiatedItemFilterInput {
	fields: users_FieldsWhereInput
	id: String
}

input users_NegotiatedItemUpsertInput {
	fields: String
	id: String
}

input users_NetworkFilterInput {
	id: String
	id_in: [String]
}

input users_NetworkUpsertInput {
	byId: String
	id: String
	metroValue: Decimal
	pointValue: Decimal
	type: String
}

input users_OrderByInput {
	fieldName: String
	type: users_OrderByType!
}

input users_OrganizationNegotiatedItemFilterInput {
	id: String
	id_in: [String]
	negotiatedItemId: String
	negotiatedItemId_in: [String]
	organizationCode: String
	organizationCode_in: [String]
	organizationId: String
	organizationId_in: [String]
}

input users_OrganizationNegotiatedItemUpsertInput {
	id: String
	negotiatedItemId: String
	organizationCode: String
	organizationId: String
}

input users_OrganizationProviderTierFilterInput {
	description: String
	id: String
	id_in: String
	name: String
	organizationId: String
	organizationId_in: String
}

input users_OrganizationProviderTierUpsertInput {
	agreedFeeGroupIds: [String]
	description: String
	fields: String
	id: String
	name: String
	organizationId: String
}

input users_ScalarValueInput {
	arrayValue: [users_ScalarValueInput]
	booleanValue: Boolean
	dateValue: DateTime
	numberValue: Decimal
	objectValue: [users_KeyScalarValueInput]
	stringValue: String
}

input users_ServiceRateCreateInput {
	byId: String
	doctorId: String
	id: String
	networkType: String!
	providerId: String
	rate: Decimal!
	serviceCode: String!
}

input users_ServiceRateDeleteInput {
	byId: String
	id: String!
}

input users_ServiceRateFilterInput {
	doctorId: String
	doctorId_in: [String!]
	id: String
	id_in: [String!]
	networkType: String
	providerId: String
	providerId_in: [String!]
}

input users_ServiceRateUpdateInput {
	byId: String
	id: String!
	networkType: String
	rate: Decimal
	serviceCode: String
}

input users_ServicingAgentChangeLogFilterInput {
	createdAt_gt: DateTime
	createdAt_gte: DateTime
	createdAt_lt: DateTime
	createdAt_lte: DateTime
	currentServicingAgentCode: String
	currentServicingAgentCode_contains: String
	currentServicingAgentCode_in: [String]
	currentServicingAgentName: String
	currentServicingAgentName_contains: String
	id: String
	lastModifiedAt_gt: DateTime
	lastModifiedAt_gte: DateTime
	lastModifiedAt_lt: DateTime
	lastModifiedAt_lte: DateTime
	newServicingAgentCode: String
	newServicingAgentCode_contains: String
	newServicingAgentCode_in: String
	newServicingAgentName: String
	newServicingAgentName_contains: String
	policyName: String
	policyName_contains: String
	policyNo: String
	policyNo_contains: String
	policyNo_in: [String]
	status: String
	status_in: [String]
}

input users_ServicingAgentChangeLogUpsertInput {
	currentServicingAgentCode: String
	currentServicingAgentName: String
	errorCode: String
	id: String
	message: String
	newServicingAgentCode: String
	newServicingAgentName: String
	policyName: String
	policyNo: String
	status: String
}

input users_UpdateAddressCommandInput {
	fields: [users_KeyValuePairOfStringAndStringInput!]
	id: String
	modifiedById: String
	type: String
}

input users_UpdateAttachedRuleCommandOfusersAttachedCommandPermissionInput {
	id: String
	update: users_usersAttachedCommandPermissionInput
}

input users_UpdateAttachedRuleCommandOfusersAttachedExternalApiCallInput {
	id: String
	update: users_usersAttachedExternalApiCallInput
}

input users_UpdateAttachedRuleCommandOfusersAttachedFilterInput {
	id: String
	update: users_usersAttachedFilterInput
}

input users_UpdateAttachedRuleCommandOfusersAttachedObjectValidationInput {
	id: String
	update: users_usersAttachedObjectValidationInput
}

input users_UpdateAttachedRuleCommandOfusersAttachedPostHandleValidationInput {
	id: String
	update: users_usersAttachedPostHandleValidationInput
}

input users_UpdateKycStatusCommandInput {
	entityId: String
	status: users_KycStatusEnum!
}

input users_usersAttachedCommandPermissionInput {
	action: users_AttachedRuleAllowAction!
	command: String!
	commandExpression: String
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input users_usersAttachedExternalApiCallInput {
	apiCalls: [users_ExternalApiCallInput!]!
	description: String
	eventExpression: String
	forEach: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input users_usersAttachedFilterInput {
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input users_usersAttachedObjectValidationInput {
	action: users_AttachedRuleAllowAction!
	description: String
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input users_usersAttachedPostHandleValidationInput {
	action: users_AttachedRuleAllowAction!
	description: String
	eventExpression: String
	group: Int!
	id: String
	lang: String
	langVersion: String
	objectExpression: String
	order: Long
	userExpression: String
}

input users_users_AttachedRuleFilterInput {
	id: String
	userExpression: String
}
